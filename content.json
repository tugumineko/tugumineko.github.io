{"meta":{"title":"tugumineko","subtitle":"鶫ねこ","description":"鶫ねこ","author":"tugumineko","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2024-05-05T13:23:31.903Z","updated":"2024-05-05T13:23:31.903Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2024-05-05T05:04:05.176Z","updated":"2024-05-05T05:04:05.176Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"做题家 互联网魔怔人"},{"title":"我的朋友们","date":"2024-05-05T13:22:53.684Z","updated":"2024-05-05T13:22:53.684Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2024-05-05T05:03:28.430Z","updated":"2024-05-05T05:03:28.430Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2024-05-05T05:02:45.737Z","updated":"2024-05-05T05:02:45.737Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"线性代数二次型学习小记","slug":"Quadratic-form","date":"2024-12-06T15:29:06.000Z","updated":"2024-12-06T16:07:38.989Z","comments":true,"path":"2024/12/06/Quadratic-form/","permalink":"http://example.com/2024/12/06/Quadratic-form/","excerpt":"","text":"二次型就是可以用二元参数表示的多项式，系数用二次型矩阵表示，这个二次型矩阵很值得研究。 二次型矩阵可以表示二次曲线 二次型矩阵一定是实对称矩阵，这意味着它可以被正交对角化。 为什么要被正交对角化呢？这是因为，如果要在合同变换前后保持二次型全等不变，变换矩阵需要满足QTQ=EQ^TQ=EQTQ=E，即Q是正交矩阵。 这样的话，我们只要使用特征值分解并且确保向量正交化，就可以轻松完成对角化，进而完成标准化，获得我们所需的信息 二次型矩阵的合同变换可以转化为标准型，且不同基向量组下表示同一个二次型的实对称矩阵是一组合同矩阵。其中对应的合同变换矩阵是对应的基变换矩阵，他一定可逆。 下面开始椭圆标准化和求长短轴的过程： 我们从给定的二次型方程(椭圆)开始： ax2+2bxy+cy2=1ax^2 + 2bxy + cy^2 = 1 ax2+2bxy+cy2=1 这个方程是一个二次型，可以写成矩阵形式： Q(x,y)=[xy][abbc][xy]=1Q(x, y) = \\begin{bmatrix} x &amp; y \\end{bmatrix} \\begin{bmatrix} a &amp; b \\\\ b &amp; c \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} = 1 Q(x,y)=[x​y​][ab​bc​][xy​]=1 这里的系数矩阵是对称矩阵： A=[abbc]A = \\begin{bmatrix} a &amp; b \\\\ b &amp; c \\end{bmatrix} A=[ab​bc​] 我们希望通过合同对角化（正交变换）将这个矩阵转化为对角矩阵，从而得到标准椭圆的形式。这样就可以得到长短轴。 假设矩阵 AAA 的特征向量分别为 v1v_1v1​ 和 v2v_2v2​，则矩阵 PPP 由这两个特征向量组成，且： P=[v1v2]P = \\begin{bmatrix} v_1 &amp; v_2 \\end{bmatrix} P=[v1​​v2​​] 如果我们使用矩阵 PPP 进行坐标变换，即令新的坐标 x′x&#x27;x′ 为： x′=P−1xx&#x27; = P^{-1} x x′=P−1x 那么，经过坐标变换后，二次型方程变为： x′TΛx′=1x&#x27;^T \\Lambda x&#x27; = 1 x′TΛx′=1 其中 Λ=diag(λ1,λ2)\\Lambda = \\text{diag}(\\lambda_1, \\lambda_2)Λ=diag(λ1​,λ2​) 是对角矩阵，包含了二次型的特征值。 x1′21λ12+x2′21λ22=1\\frac{x_1&#x27;^2}{\\frac{1}{\\sqrt{\\lambda_1}}^2} + \\frac{x_2&#x27;^2}{\\frac{1}{\\sqrt{\\lambda_2}}^2} = 1 λ1​​1​2x1′2​​+λ2​​1​2x2′2​​=1 这意味着： 长轴的半长轴 a=1λ1a = \\frac{1}{\\sqrt{\\lambda_1}}a=λ1​​1​, 短轴的半长轴 b=1λ2b = \\frac{1}{\\sqrt{\\lambda_2}}b=λ2​​1​. 为了对角化矩阵 AAA，我们首先求解其特征值和特征向量。特征值 λ1\\lambda_1λ1​ 和 λ2\\lambda_2λ2​ 是矩阵 AAA 的解，满足以下特征方程： det⁡(A−λI)=0\\det(A - \\lambda I) = 0 det(A−λI)=0 即： det⁡[a−λbbc−λ]=0\\det\\begin{bmatrix} a - \\lambda &amp; b \\\\ b &amp; c - \\lambda \\end{bmatrix} = 0 det[a−λb​bc−λ​]=0 计算行列式： (a−λ)(c−λ)−b2=0(a - \\lambda)(c - \\lambda) - b^2 = 0 (a−λ)(c−λ)−b2=0 展开后得到： λ2−(a+c)λ+(ac−b2)=0\\lambda^2 - (a + c)\\lambda + (ac - b^2) = 0 λ2−(a+c)λ+(ac−b2)=0 这个方程的解就是矩阵 ( A ) 的特征值 ( \\lambda_1 ) 和 ( \\lambda_2 )，分别为： λ1,λ2=(a+c)±(a+c)2−4(ac−b2)2\\lambda_1, \\lambda_2 = \\frac{(a + c) \\pm \\sqrt{(a + c)^2 - 4(ac - b^2)}}{2} λ1​,λ2​=2(a+c)±(a+c)2−4(ac−b2)​​ 这两个特征值即为二次型的主轴方向上的系数，它们决定了椭圆的长短轴。 12345678float det = (cov.x * cov.z - cov.y * cov.y);if (det == 0.0f) return;float det_inv = 1.f / det;float3 conic = &#123; cov.z * det_inv, -cov.y * det_inv, cov.x * det_inv &#125;;float mid = 0.5f * (cov.x + cov.z);float lambda = mid + sqrt(max(0.01f, mid * mid - det));float my_radius = extent * sqrt(lambda);","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}],"author":"tugumineko"},{"title":"论文阅读：Mini-Splatting2:Building 360 Scenes within Minutes via Aggresive Gaussian Densification","slug":"mini-splatting","date":"2024-12-02T10:39:01.000Z","updated":"2024-12-07T08:43:13.638Z","comments":true,"path":"2024/12/02/mini-splatting/","permalink":"http://example.com/2024/12/02/mini-splatting/","excerpt":"","text":"简述 本文基于3DGS辐射场方法，提出了一种新的点云分布和优化策略框架，从而在维持3DGS visualization质量差别不大的情况下，实现个位数分钟级的训练速度。最终达到了render quality和optimization efficiency的trade-off. 该方法以不透明度确定的Gaussian importance为基础(core metric)，提出(1)aggressive Gaussian densification，利用光线求交得出depth point重构点云(depth reinitialization)，同时加入critical Gaussian identification&amp;&amp;aggresive Gaussian clone,防止depth reinitialization导致的点云数量爆炸和图像质量破坏的问题。(2)visiability Gaussian culling，每次训练都预计算visibility mask，从而加快计算过程。 最终减少点云数量，加快早期优化速度，并且使得高斯的密集化能够在一个很短的时期内完成。 在细节上，修改densification、culling框架代码，优化processCUDA光栅化进程，达到optimization speed, the number of Gaussians,and rendering quality的balance. Gaussian importance 由Compressing Volumetric Radiance Fields to 1 MB可知，大多数体素对渲染结果的影响最小，这表明网格模型中的冗余很大，并且可以在不降低渲染质量的情况下进行剪枝(prune)。 我们将Gaussian importance定义为该区域内(?)不透明度最大的高斯的不透明度。因为这种Gaussian importance对渲染结果影响较大。 aggressive Gaussian densification depth reinitialization 找到该区域不透明度最大的椭球，将其与椭球光线求交得到的点云的中点作为深度点(depth point) d(x)=dimaxmid(x),where imax=arg⁡max⁡iwid(x) = d^{\\text{mid}}_{i_{\\text{max}}}(x), \\quad \\text{where} \\, i_{\\text{max}} = \\arg\\max_{i} w_i d(x)=dimax​mid​(x),whereimax​=argimax​wi​ 创建深度贴图，利用类似屏幕后处理的方法重建和合并点云，即depth initalization，从而加快早期的优化迭代。 然而，这种简单的点云优化方法，会导致场景不够泛化，点云数量爆炸和图像质量破坏的问题。 通过加入critical Gaussian identification&amp;&amp;aggresive Gaussian clone，我们可以解决这些问题。 cirtical Gaussian identification 在早期的优化迭代时期，几乎所有的训练过程中的Gaussian处于under-construction状态，单纯地进行clone可以认为是一种降低Gaussian importance的行为，不利于控制高斯数量，所以我们采用了represent the object surface。即cirtical Gaussian identification. 还是找到该区域内不透明度最大的椭球GimaxG_{i_{max}}Gimax​​，将它的贡献作为alpha blend的估计 我们使用逆分布函数得到Gaussian critcal,其中βp\\beta_pβp​代表prune threshold,本文设置为0.99，得到的θp\\theta_pθp​为GimaxG_{i_{max}}Gimax​​前1%的Gaussian，即Gaussian critical θp=F−1(βp)\\theta_p = F^{-1}(\\beta_p) θp​=F−1(βp​) aggressive Gaussian clone 由于直接将原有的高斯作为点云的结构不利于早期优化，我们借鉴了3D Gaussian Splatting as Markov Chain Monte Carlo，达到了平滑的高斯密集化。将clone过程应用于所有的critical Gaussian，并且简化了高斯中心的计算过程，将clone数设置为2。即： Pnew=PoldP_{\\text{new}} = P_{\\text{old}} Pnew​=Pold​ αnew=1−1−αold\\quad \\alpha_{\\text{new}} = 1 - \\sqrt{1 - \\alpha_{\\text{old}}} αnew​=1−1−αold​​ Σnew=(αold)2⋅(2αnew−(αnew)22)−2⋅Σold\\quad \\Sigma_{\\text{new}} = (\\alpha_{\\text{old}})^2 \\cdot \\left( 2\\alpha_{\\text{new}} - \\frac{(\\alpha_{\\text{new}})^2}{\\sqrt{2}} \\right)^{-2} \\cdot \\Sigma_{\\text{old}} Σnew​=(αold​)2⋅(2αnew​−2​(αnew​)2​)−2⋅Σold​ Overall Aggressive Densification Pipeline 我们保留了3DGS原有的progressive densification，并且在500次迭代开始每250次进行一次critical Gaussian identification&amp;&amp;aggresive Gaussian clone，在2K次迭代开始进行Depth reinitialization。将整个密集化过程缩短至3K迭代，从而将整个30K次的迭代过程缩短至18K次。 并且整个渲染管线可以兼容Mini-Splatting framework，允许Mini-Splatting simplification在第3K次迭代和8K次迭代。 visibility Gaussian culling 对于第kkk次训练视图，首先通过对所有与高斯 GiG_iGi​相交的光线 jjj的混合权重wijkw_{ij}^{k}wijk​求和来计算Gaussian importance IikI_i^kIik​。 具体计算公式为： Iik=∑j=1JwijiI_i^k = \\sum_{j=1}^{J} w_{ij}^i Iik​=j=1∑J​wiji​ 其中JJJ是与高斯GiG_iGi​相交的总光线数。 可见性掩码VikV_i^kVik​是通过一个指示函数 III来计算的，该函数比较IikI_i^kIik​是否超过了预定义的阈值τ\\tauτ。 如果IikI_i^kIik​大于阈值τ\\tauτ，则Vik=1V_i^k = 1Vik​=1（表示可见）；否则Vik=0V_i^k = 0Vik​=0（表示不可见）。 该计算公式为： Vik=I(Iik&gt;τ)V_i^k = \\mathcal I(I_i^k &gt; \\tau) Vik​=I(Iik​&gt;τ) 确保只有在Gaussian importance前 1%的高斯才被认为是visability的。 并且在500到13K的迭代过程中，通过在每次训练视角下预计算visbility mask,剔除不必要的Gaussian，减小计算开销，加快计算过程。 Implementation 为了减小内存负担，在密集化过程中关闭了球谐系数的迭代优化，并且让训练在一个较小的分辨率下运行。 代码实现细节 depth reinitalization 123456789101112131415if iteration == args.depth_reinit_iter: num_depth = gaussians._xyz.shape[0]*args.num_depth_factor # interesction_preserving for better point cloud reconstruction result at the early stage, not affect rendering quality gaussians.interesction_preserving(scene, render_simp, iteration, args, pipe, background) pts, rgb = gaussians.depth_reinit(scene, render_depth, iteration, num_depth, args, pipe, background) gaussians.reinitial_pts(pts, rgb) gaussians.training_setup(opt) gaussians.init_culling(len(scene.getTrainCameras())) mask_blur = torch.zeros(gaussians._xyz.shape[0], device=&#x27;cuda&#x27;) torch.cuda.empty_cache() # print(gaussians._xyz.shape) 先找到透明度最大的椭球 获取accum_weights,area_proj,area_max变量,我们可以看到，这里进行了一个简单的光栅化过程， 它们都是数组，(1)accum_weights是计算高斯贡献的累积不透明度，(2)area_proj是计算高斯贡献的不透明度的次数（覆盖的像素的个数），(3)area_max是计算这个高斯在每个像素渲染过程的所有高斯中贡献最大的次数 12# in gaussian_renderer/init.pydef render_simp(viewpoint_camera, pc : GaussianModel, pipe, bg_color : torch.Tensor, scaling_modifier = 1.0, override_color = None, culling=None): ... 123456789101112131415161718192021222324# Rasterize visible Gaussians to image, obtain their radii (on screen). rendered_image, radii, \\accum_weights_ptr, accum_weights_count, accum_max_count = rasterizer.render_simp( means3D = means3D, means2D = means2D, dc = dc, shs = shs, culling = culling, colors_precomp = colors_precomp, opacities = opacity, scales = scales, rotations = rotations, cov3D_precomp = cov3D_precomp)# Those Gaussians that were frustum culled or had a radius of 0 were not visible.# They will be excluded from value updates used in the splitting criteria.return &#123;&quot;render&quot;: rendered_image, &quot;viewspace_points&quot;: screenspace_points, &quot;visibility_filter&quot; : (radii &gt; 0).nonzero(), &quot;radii&quot;: radii, &quot;accum_weights&quot;: accum_weights_ptr, &quot;area_proj&quot;: accum_weights_count, &quot;area_max&quot;: accum_max_count, &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// in forward.cutemplate &lt;uint32_t CHANNELS&gt;__global__ void __launch_bounds__(BLOCK_X * BLOCK_Y)render_simpCUDA( const uint2* __restrict__ ranges, const uint32_t* __restrict__ point_list, int W, int H, const float2* __restrict__ points_xy_image, const float* __restrict__ features, float* __restrict__ accum_weights_p, int* __restrict__ accum_weights_count, float* __restrict__ accum_max_count, const float4* __restrict__ conic_opacity, float* __restrict__ final_T, uint32_t* __restrict__ n_contrib, const float* __restrict__ bg_color, float* __restrict__ out_color )&#123; // Identify current tile and associated min/max pixel range. auto block = cg::this_thread_block(); uint32_t horizontal_blocks = (W + BLOCK_X - 1) / BLOCK_X; uint2 pix_min = &#123; block.group_index().x * BLOCK_X, block.group_index().y * BLOCK_Y &#125;; uint2 pix_max = &#123; min(pix_min.x + BLOCK_X, W), min(pix_min.y + BLOCK_Y , H) &#125;; uint2 pix = &#123; pix_min.x + block.thread_index().x, pix_min.y + block.thread_index().y &#125;; uint32_t pix_id = W * pix.y + pix.x; float2 pixf = &#123; (float)pix.x, (float)pix.y &#125;; // Check if this thread is associated with a valid pixel or outside. // Done threads can help with fetching, but don&#x27;t rasterize // Load start/end range of IDs to process in bit sorted list. // Allocate storage for batches of collectively fetched data. // Initialize helper variables // ... // Iterate over batches until all done or range is complete // ... // Iterate over current batch for (int j = 0; !done &amp;&amp; j &lt; min(BLOCK_SIZE, toDo); j++) &#123; // Keep track of current position in range contributor++; // Resample using conic matrix (cf. &quot;Surface // Splatting&quot; by Zwicker et al., 2001) float2 xy = collected_xy[j]; float2 d = &#123; xy.x - pixf.x, xy.y - pixf.y &#125;; float4 con_o = collected_conic_opacity[j]; float power = -0.5f * (con_o.x * d.x * d.x + con_o.z * d.y * d.y) - con_o.y * d.x * d.y; if (power &gt; 0.0f) continue; // Eq. (2) from 3D Gaussian splatting paper. // Obtain alpha by multiplying with Gaussian opacity // and its exponential falloff from mean. // Avoid numerical instabilities (see paper appendix). float alpha = min(0.99f, con_o.w * exp(power)); if (alpha &lt; 1.0f / 255.0f) continue; float test_T = T * (1 - alpha); if (test_T &lt; 0.0001f) &#123; done = true; continue; &#125; // Eq. (3) from 3D Gaussian splatting paper. for (int ch = 0; ch &lt; CHANNELS; ch++) C[ch] += features[collected_id[j] * CHANNELS + ch] * alpha * T; if(weight_max&lt;alpha * T) &#123; weight_max=alpha * T; idx_max = collected_id[j]; flag_update = 1; &#125; atomicAdd(&amp;(accum_weights_p[collected_id[j]]), alpha * T); atomicAdd(&amp;(accum_weights_count[collected_id[j]]), 1); T = test_T; // Keep track of last range entry to update this // pixel. last_contributor = contributor; &#125; &#125; if(flag_update==1) &#123; atomicAdd(&amp;(accum_max_count[idx_max]), 1); &#125; // All threads that treat valid pixel write out their final // rendering data to the frame and auxiliary buffers. // ...&#125; 首先进行intersection_preserving对高斯进行筛选，对于每个训练视图，均进行光栅化，这样就能得到高斯对这些视图做的贡献相关信息，在这里，我将做出了最大贡献的高斯命名为有效高斯，剩余的就是被较高权重高斯完全覆盖的高斯，对渲染影响较小，可以舍去。重要性的计算分为outdoor和indoor，outdoor则需要加权，累计单位面积的不透明度贡献值，至于为什么这样做，我认为可能是outdoor空白场景较多，点云稀疏，高斯比较大，容易受到投影面积的影响。 接下来就是对重要性进行排序，选出贡献在前1%的高斯，剩下的全部被剪枝 1234567891011121314151617181920212223242526def interesction_preserving(self, scene, render_simp, iteration, args, pipe, background): imp_score = torch.zeros(self._xyz.shape[0]).cuda() accum_area_max = torch.zeros(self._xyz.shape[0]).cuda() views = scene.getTrainCameras_warn_up(iteration, args.warn_until_iter, scale=1.0, scale2=2.0).copy() for view in views: render_pkg = render_simp(view, self, pipe, background, culling=self._culling[:,view.uid]) accum_weights = render_pkg[&quot;accum_weights&quot;] area_proj = render_pkg[&quot;area_proj&quot;] area_max = render_pkg[&quot;area_max&quot;] accum_area_max = accum_area_max+area_max if args.imp_metric==&#x27;outdoor&#x27;: mask_t=area_max!=0 temp=imp_score+accum_weights/area_proj imp_score[mask_t] = temp[mask_t] else: imp_score=imp_score+accum_weights imp_score[accum_area_max==0]=0 non_prune_mask = init_cdf_mask(importance=imp_score, thres=0.99) self.prune_points(non_prune_mask==False) return self._xyz, SH2RGB(self._features_dc+0)[:,0] 接下来就是depth_reinit过程了,得到accum_alpha累计透明度(这个似乎和深度没关系)和out_pts表示的向量信息(方向表示光线方向，模长是深度),且为定义的深度点（光线相交椭球的中点）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155template &lt;uint32_t CHANNELS&gt;__global__ void __launch_bounds__(BLOCK_X * BLOCK_Y)render_depthCUDA( const uint2* __restrict__ ranges, const uint32_t* __restrict__ point_list, int W, int H, const float2* __restrict__ points_xy_image, const float* __restrict__ features, const float4* __restrict__ conic_opacity, float* __restrict__ final_T, uint32_t* __restrict__ n_contrib, const float* __restrict__ bg_color, float* __restrict__ out_color, float* __restrict__ out_pts, float* __restrict__ out_depth, float* accum_alpha, int* __restrict__ gidx, float* __restrict__ discriminants, const float* __restrict__ means3D, const glm::vec3* __restrict__ scales, const glm::vec4* __restrict__ rotations, const float* __restrict__ viewmatrix, const float* __restrict__ projmatrix, const glm::vec3* __restrict__ cam_pos )&#123; float3 p_proj_r = &#123; Pix2ndc(pixf.x, W), Pix2ndc(pixf.y, H), 1&#125;; //inverse process of &#x27;Transform point by projecting&#x27; float p_hom_x_r = p_proj_r.x*(1.0000001); float p_hom_y_r = p_proj_r.y*(1.0000001); // self.zfar = 100.0, self.znear = 0.01 float p_hom_z_r = (100-100*0.01)/(100-0.01); float p_hom_w_r = 1; float3 p_hom_r=&#123;p_hom_x_r, p_hom_y_r, p_hom_z_r&#125;; float4 p_orig_r=transformPoint4x4(p_hom_r, projmatrix_inv); glm::vec3 ray_direction=&#123; p_orig_r.x-ray_origin.x, p_orig_r.y-ray_origin.y, p_orig_r.z-ray_origin.z, &#125;; glm::vec3 normalized_ray_direction = glm::normalize(ray_direction); // Iterate over batches until all done or range is complete // ... // Iterate over current batch for (int j = 0; !done &amp;&amp; j &lt; min(BLOCK_SIZE, toDo); j++) &#123; // Resample using conic matrix (cf. &quot;Surface // Splatting&quot; by Zwicker et al., 2001) float2 xy = collected_xy[j]; float2 d = &#123; xy.x - pixf.x, xy.y - pixf.y &#125;; float4 con_o = collected_conic_opacity[j]; float power = -0.5f * (con_o.x * d.x * d.x + con_o.z * d.y * d.y) - con_o.y * d.x * d.y; if (power &gt; 0.0f) continue; float alpha = min(0.99f, con_o.w * exp(power)); if (alpha &lt; 1.0f / 255.0f) continue; float test_T = T * (1 - alpha); if (test_T &lt; 0.0001f) &#123; done = true; continue; &#125; for (int ch = 0; ch &lt; CHANNELS; ch++) C[ch] += features[collected_id[j] * CHANNELS + ch] * alpha * T; // compute Gaussian depth // Normalize quaternion to get valid rotation glm::vec4 q = rotations[collected_id[j]];// / glm::length(rot); float rot_r = q.x; float rot_x = q.y; float rot_y = q.z; float rot_z = q.w; // Compute rotation matrix from quaternion // ... glm::vec3 temp=&#123; ray_origin.x-means3D[3*collected_id[j]+0], ray_origin.y-means3D[3*collected_id[j]+1], ray_origin.z-means3D[3*collected_id[j]+2], &#125;; glm::vec3 rotated_ray_origin = R * temp; glm::vec3 rotated_ray_direction = R * normalized_ray_direction; ///除法映射到椭球标准坐标系 glm::vec3 a_t= rotated_ray_direction/(scales[collected_id[j]]*3.0f)*rotated_ray_direction/(scales[collected_id[j]]*3.0f); float a = a_t.x + a_t.y + a_t.z; glm::vec3 b_t= rotated_ray_direction/(scales[collected_id[j]]*3.0f)*rotated_ray_origin/(scales[collected_id[j]]*3.0f); float b = 2*(b_t.x + b_t.y + b_t.z); glm::vec3 c_t= rotated_ray_origin/(scales[collected_id[j]]*3.0f)*rotated_ray_origin/(scales[collected_id[j]]*3.0f); float c = c_t.x + c_t.y + c_t.z-1; float discriminant=b*b-4*a*c; float depth = (-b/2/a)/glm::length(ray_direction); if(depth&lt;0) continue; if(weight_max&lt;alpha * T) &#123; weight_max=alpha * T; depth_max=depth; discriminant_max=discriminant; idx_max=collected_id[j]; point_rec = ray_origin+(-b/2/a)*normalized_ray_direction; &#125; T = test_T; last_contributor = contributor; &#125; &#125; // All threads that treat valid pixel write out their final // rendering data to the frame and auxiliary buffers. if (inside) &#123; final_T[pix_id] = T; n_contrib[pix_id] = last_contributor; for (int ch = 0; ch &lt; CHANNELS; ch++) out_color[ch * H * W + pix_id] = C[ch] + T * bg_color[ch]; for (int ch = 0; ch &lt; 3; ch++) out_pts[ch * H * W + pix_id] = point_rec[ch]; out_depth[pix_id] = depth_max; accum_alpha[pix_id] = T; discriminants[pix_id] = discriminant_max; gidx[pix_id]=idx_max; &#125;&#125; 选取一定比例的深度点（比例根据累积不透明度和自己的定义调整） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def depth_reinit(self, scene, render_depth, iteration, num_depth, args, pipe, background): out_pts_list=[] gt_list=[] ## 预热(warn up)时使用scale2，即(width/2 x height/2),0.5倍的分辨率 views = scene.getTrainCameras_warn_up(iteration, args.warn_until_iter, scale=1.0, scale2=2.0).copy() ## 每个视图都要计算 for view in views: gt = view.original_image[0:3, :, :] ## 渲染深度图，获取相关信息 render_depth_pkg = render_depth(view, self, pipe, background, culling=self._culling[:,view.uid]) out_pts = render_depth_pkg[&quot;out_pts&quot;] accum_alpha = render_depth_pkg[&quot;accum_alpha&quot;] prob=1-accum_alpha prob = prob/prob.sum() prob = prob.reshape(-1).cpu().numpy() ## 根据深度选择采样比例 factor=1/(gt.shape[1]*gt.shape[2]*len(views)/num_depth) N_xyz=prob.shape[0] num_sampled=int(N_xyz*factor) ## 加权随机采样，prob越高(opacity越高)的点云越容易被选中 indices = np.random.choice(N_xyz, size=num_sampled, p=prob,replace=False) &#x27;&#x27;&#x27; print(f&quot;Normalized prob: &#123;prob&#125;&quot;) print(f&quot;Reshaped and moved to numpy: &#123;prob&#125;&quot;) print(f&quot;Factor: &#123;factor&#125;&quot;) print(f&quot;N_xyz (Total samples): &#123;N_xyz&#125;&quot;) print(f&quot;Number of sampled points: &#123;num_sampled&#125;&quot;) print(f&quot;Sampled indices: &#123;indices&#125;&quot;) &#x27;&#x27;&#x27; out_pts = out_pts.permute(1,2,0).reshape(-1,3) gt = gt.permute(1,2,0).reshape(-1,3) out_pts_list.append(out_pts[indices]) gt_list.append(gt[indices]) out_pts_merged=torch.cat(out_pts_list) gt_merged=torch.cat(gt_list) return out_pts_merged, gt_merged 最终只保留深度点和相应的颜色,之后在进行合并 12345678910111213141516171819202122232425## after depth reinitdef reinitial_pts(self, pts, rgb): fused_point_cloud = pts fused_color = RGB2SH(rgb) features = torch.zeros((fused_color.shape[0], 3, (self.max_sh_degree + 1) ** 2)).float().cuda() features[:, :3, 0 ] = fused_color features[:, 3:, 1:] = 0.0 # print(&quot;Number of points at initialisation : &quot;, fused_point_cloud.shape[0]) dist2 = torch.clamp_min(distCUDA2(fused_point_cloud), 0.0000001) scales = torch.log(torch.sqrt(dist2))[...,None].repeat(1, 3) rots = torch.zeros((fused_point_cloud.shape[0], 4), device=&quot;cuda&quot;) rots[:, 0] = 1 opacities = inverse_sigmoid(0.1 * torch.ones((fused_point_cloud.shape[0], 1), dtype=torch.float, device=&quot;cuda&quot;)) self._xyz = nn.Parameter(fused_point_cloud.contiguous().requires_grad_(True)) self._features_dc = nn.Parameter(features[:,:,0:1].transpose(1, 2).contiguous().requires_grad_(True)) self._features_rest = nn.Parameter(features[:,:,1:].transpose(1, 2).contiguous().requires_grad_(True)) self._scaling = nn.Parameter(scales.requires_grad_(True)) self._rotation = nn.Parameter(rots.requires_grad_(True)) self._opacity = nn.Parameter(opacities.requires_grad_(True)) self.max_radii2D = torch.zeros((self.get_xyz.shape[0]), device=&quot;cuda&quot;) 可以看到，作者通过控制比例，使得depth_reinit前后点云数量基本相等，但是根据深度贴图实现了点的重构","categories":[{"name":"3DV","slug":"3DV","permalink":"http://example.com/categories/3DV/"}],"tags":[{"name":"3dgs","slug":"3dgs","permalink":"http://example.com/tags/3dgs/"}],"author":"tugumineko"},{"title":"3DGS实时渲染简述","slug":"3dgs-sketch","date":"2024-11-25T02:38:22.000Z","updated":"2024-11-25T13:49:42.359Z","comments":true,"path":"2024/11/25/3dgs-sketch/","permalink":"http://example.com/2024/11/25/3dgs-sketch/","excerpt":"","text":"前置知识：高斯分布，协方差矩阵，线性变换，四元数，机器学习，计算机图形学/计算机视觉，高性能计算 定义： 3DGS实时渲染，即3D Gaussian Splatting in Real-time Rendering，使用了3D gaussian作为基底，对输入的SfM点云的位置(x,y,z)和颜色(r,g,b)进行gaussian model初始化，通过GPU并行计算，运用计算机图形学的传统光栅化方法将高斯渲染到屏幕上面，通过渲染结果做偏微分做loss反向传播并更新高斯参数，利用随机梯度下降进行学习，并且交错迭代优化。 具体细节： 为什么选用高斯？ 高斯可以近似为椭球，渲染到2D屏幕上近似为圆，不仅可以实现以圆为基底的光栅化渲染，而且具有可微的性质，所以可学习。 2阶协方差矩阵转换为二次曲线得到椭圆表达式 偏微分得到位置mean和协方差矩阵(用scale和quternion表示)，颜色(r,g,b)，opacity α\\alphaα，反深度，椭球曲线conic等信息，与L1和SSIM Loss做反向传播进行优化更新 高斯有很多优秀的性质，加快计算以达到实时渲染 协方差矩阵表示3D高斯在各个坐标轴的缩放及旋转，相应地可以通过旋转矩阵和缩放矩阵表示协方差矩阵 3D高斯通过矩阵变换后得到的还是一个3D高斯，我们光栅化时转换坐标系时需要用到 两个高斯做卷积还是一个高斯，并且得到的高斯的协方差矩阵是两个高斯的协方差矩阵之和，后面做EWA反走样时会用到 3D高斯沿着某个轴做积分可以得到2D高斯，而且这个2D高斯的协方差矩阵就是3D高斯的协方差矩阵的左上角2x2部分 如何进行光栅化？ 3D -&gt; 2D 转换坐标系，从3D高斯投影为2D高斯，注意这里的3D椭球从不同视角看投影出来的2D椭圆是不同的。我们使用了协方差矩阵为核心，从世界空间到相机空间是一个仿射变换。而从相机空间齐次空间是一个非线性变换，不满足上述性质，论文中提出了一种近似的放射投影变换(local affine approximation),是二阶泰勒展开得到的Jacobian Matrix,然后做积分得到2D高斯，而且根本不用做积分运算，因为2D高斯协方差矩阵已经得到了。 为了减少阴影和混叠，我们需要反走样Antialiasing，我们对信号增加一个低通滤波器以避免混叠现象。经过证明，对整个信号的卷积等价于对足迹函数的卷积，即2D协方差矩阵对角线的两个数加上定值0.3，让所有高斯&quot;胖&quot;一些，让更多高斯贡献到某一像素上。 用协方差矩阵得到相应的椭球形状，然后近似成圆，得到半径和圆心(2Dmean)，找到这个圆对应了几个Tile，用球谐函数拟合这个圆的颜色，按位深度排序得到 [Tile | Sphere] 键值对，以Tile为Block，Pixel为Thread进行GPU并行计算，加快渲染速度。 渲染方程 ∑kcλkokgk(qk⊗h)(x^)\\sum_{k}^{} c_{\\lambda k}o_{k}g_{k}(q_{k}\\otimes h)(\\hat{x}) k∑​cλk​ok​gk​(qk​⊗h)(x^) 对应到3DGS算法上面，cλkc_{\\lambda k}cλk​表示某个高斯的颜色(feature)，oko_{k}ok​是累计的透明度，gkg_{k}gk​是这次的透明度，卷积经过预计算的协方差矩阵可以得出。 其中： 颜色是输入的颜色，但是为了让不同视角看起来的颜色不同(高光和漫反射)，我们使用球谐函数拟合出不同视角的颜色。 透明度乘以足迹函数就是高斯分布，即概率 这样，我们不断进行累加，运用GPU并行计算，就可以得到一个2D视图场景。 怎样做反向传播？ 对于一个可学习模型的反向传播，我们要先知道输入项和输出项。 在这里，我们可以认为输入项是逐像素的颜色张量 Prgb(p,3)P_{rgb}(p,3)Prgb​(p,3)。 输出项是高斯的相关参数，包括：逐高斯的颜色张量Grgb(g,3)G_{rgb}(g,3)Grgb​(g,3)、逐高斯的不透明度Gopacity(g,1)G_{opacity}(g,1)Gopacity​(g,1)、椭球中心的位置Gpoint3D(g,3)G_{point3D}(g,3)Gpoint3D​(g,3)、椭球的旋转角度Grotation(g,4)G_{rotation}(g,4)Grotation​(g,4)、椭球的轴长Gscale(g,3)G_{scale}(g,3)Gscale​(g,3)。 由于是梯度下降法，然后就是计算梯度，利用Loss函数偏微分计算出即可。 具体就是Pytorch和Loss比较，在前向传播后会返回一个Loss对输出值的偏微分，即dLdPrgb(p,3)\\frac {dL}{dP_{rgb}(p,3)}dPrgb​(p,3)dL​,然后我们可以通过换元一步步计算出对应的偏微分，即得到梯度。 在这里，Loss为L1和D-SSIM的组合损失函数，其中D-SSIM权重为0.2 训练时如何优化？ 增加高斯的数量。 论文中使用了一种基于gradient的densification方法对高斯密度进行调节。 论文将需要调节的高斯分为两类: under-reconstruction:高斯并不能填满需要表达的几何 over-reconstrucition:高斯过大导致完全覆盖了一片区域 这些需要调节的高斯的位置梯度往往很大，因为优化器更倾向于把这些错误纠正。 论文中直接算历史平均位置梯度，如果在某次调节中发现这个高斯的平均梯度大于某个预定值，就认为这个高斯需要调节。 对高斯进行剪枝。 当透明度小于0.005时，就认为这个高斯不存在（大片空白场景），将其剪枝 当高斯scale过大时或者投影到屏幕上过大时，将其剪枝 每过3000次迭代将所有高斯的透明度设置为0.01，这样优化器就会忽略增加那些错误的高斯的透明度从而做到剪枝掉空中的’floater’的作用。 增加球谐函数的维度。 每过1000次迭代增加一个球谐函数的维度，最高为3 通过学习率变化策略。 先warm-up再下降 不同的参数交错训练，且使用不同的优化器和初始学习率","categories":[{"name":"CV","slug":"CV","permalink":"http://example.com/categories/CV/"},{"name":"CG","slug":"CG","permalink":"http://example.com/categories/CG/"},{"name":"3DV","slug":"3DV","permalink":"http://example.com/categories/3DV/"}],"tags":[{"name":"3dgs","slug":"3dgs","permalink":"http://example.com/tags/3dgs/"}],"author":"tugumineko"},{"title":"2024/11/11环境配置踩坑","slug":"softras-environment","date":"2024-11-11T15:05:21.000Z","updated":"2024-11-12T06:35:48.439Z","comments":true,"path":"2024/11/11/softras-environment/","permalink":"http://example.com/2024/11/11/softras-environment/","excerpt":"","text":"今天在跑Soft Rasterizer (SoftRas)这一篇论文代码时出现了很多的问题，由于是一篇2019年的论文，有很多版本兼容的问题，于是记录下来。 前言 有一些由于版本兼容出现的警告版本过高/过低/不匹配其实大多数是不用管的，注意区分 CUDA 10不兼容 首先是按照论文所给的环境(Python3 and PyTorch 1.6.0. CUDA (10.1))跑不了,因为CUDA 10不能兼容30系显卡。 所以要更换兼容更高版本的PyTorch,我这里使用的是PyTorch 1.9.0,使用如下代码可以查看版本： 1234567python - &lt;&lt;-EOFimport platformimport torchprint(f&quot;Python : &#123;platform.python_version()&#125;&quot;)print(f&quot;PyTorch: &#123;torch.__version__&#125;&quot;)print(f&quot; CUDA : &#123;torch.version.cuda&#125;&quot;)EOF gcc/g++版本过高 主要参考以下博客Linux系统 利用conda更改gcc、g++版本(非root用户)建立软连接实现,注意不要忘记下载g++ gcc和g++版本一定要检查是否一样 gcc降级导致环境变量崩溃 参考博客非root用户构建项目代码踩坑记录_conda 安装 gcc_cannot find /lib64/libpthread.so.0 英文版ld-cannot-find-lib64-libpthread-so-0-ld-cannot-find-usr-lib64-libpthread-non 12cannot find /lib64/libpthread.so.0cannot find /usr/lib64/libpthread_nonshared.a 具体为什么会这样呢，可能还要到以后去探究 由于更改版本无法安装的依赖 比如我这里python是3.7，而pytorch是1.9.0，这样导致pytorch需要的包没有或者没有对应的版本，其实直接pip/conda安装对应的最高版本/库即可 参考链接： 可微渲染 SoftRas 实践 Linux系统 利用conda更改gcc、g++版本(非root用户) 非root用户构建项目代码踩坑记录_conda 安装 gcc_cannot find /lib64/libpthread.so.0 ld-cannot-find-lib64-libpthread-so-0-ld-cannot-find-usr-lib64-libpthread-non error: Couldn’t find a setup script in /tmp/easy_install-ian85kkj/scikit_image-0.23.2.tar.gz","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"cuda","slug":"cuda","permalink":"http://example.com/categories/cuda/"}],"tags":[{"name":"渲染","slug":"渲染","permalink":"http://example.com/tags/%E6%B8%B2%E6%9F%93/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"author":"tugumineko"},{"title":"3dgs real-time radiance rendering","slug":"3dgs-real-time-radiance-rendering","date":"2024-11-05T10:36:13.000Z","updated":"2024-12-06T10:01:17.035Z","comments":true,"path":"2024/11/05/3dgs-real-time-radiance-rendering/","permalink":"http://example.com/2024/11/05/3dgs-real-time-radiance-rendering/","excerpt":"","text":"introduce 3D Gaussians as a flexible and expressive scene representation. input: cameras calibrated with Structure-from-Motion(SfM) initalize the set of 3D Gaussians with the sparse point cloud produced for free as part of the SfM process. (only SfM points as input) optimization of the properities of the 3D Gaussians - 3D position, opacity α\\alphaα (?), anisotropic covarianice, and SH coefficients - interleaved with adaptive density control steps, where we add and occasionally remove 3D Gaussians during optimization produce （reasonably compact,unstructured,and precise representation of the scene） real-time rendering solution that uses fast GPU sorting algorithms ansd is inspired by tile-based rasterization. (visibility-aware, allows anisotropic splatting and fast back-propagation(反向传播) to achieve high-quality novel view synthesis) light field (光场) The first novel-view synthesis approaches were based on light fields. SfM estimates a sparse point cloud during camera calibration. Rendering using volumetric ray-marching has a significant cost due to the large number of samples required to query the volume. recent methods have focused on faster training and/or rendering mostly by expoiting(开发) three design choices: the use of spatial data structures to store (neural) features that are subsequently interpolated during volumetric ray-matching different encoding MLP capacity Many methods has limits: struggle to represent empty space effectively,depending in part on the scene/capture type image quality is limited in large part by the choice of the structured grids used for acceleration, and rendering speed is hindered(阻碍) by the need to query many samples for a given ray-marching step. aliasing(走样) image formation model(成像模型) Point-based alpha-blending and NeRF-style volumetric rendering The color C is given by volumetric rendering along a ray:(?) A typical neutral point-based approach computes the color C of a pixel by blending N order points overlapping the pixel:(?) –&gt; Points are an unstructured,discrete representation that is flexible enough to allow creation,destruction,and displacement of geometry similar to NeRF. –&gt; This is achieved by optimizing opacity(?什么意思) and positions. –&gt; optimization of anisotropic covariance, interleaved optimization/density control, and efficient depth sorting for rendering allow us to handle complete, complex scenes including background, both indoors and outdoors and with large depth complexity. OVERVIEW The input to our method is a set of images of a static scene, together with the corresponding cameras calibrated by SfM [Schönberger and Frahm 2016] which produces a sparse point cloud as a side effect. From these points we create a set of 3D Gaussians (Sec. 4), defined by a position (mean), covariance matrix and opacity 𝛼, that allows a very flexible optimization regime. This results in a reasonably compact(简化) representation of the 3D scene, in part because highly anisotropic volumetric splats(高度各向异性的体积斑点) can be used to represent fine structures compactly. The directional appearance component (color) of the radiance field is represented via spherical harmonics (SH), following standard practice [Fridovich-Keil and Yu et al. 2022; Müller et al. 2022]. Our algorithm proceeds to create the radiance field representation (Sec. 5) via a sequence of optimization steps of 3D Gaussian parameters, i.e., position, covariance, 𝛼 and SH coefficients interleaved with operations for adaptive control of the Gaussian density. The key to the efficiency of our method is our tile-based rasterizer (Sec. 6) that allows 𝛼-blending of anisotropic splats, respecting visibility order thanks to fast sorting. Out fast rasterizer also includes a fast backward pass by tracking accumulated 𝛼 values, without a limit on the number of Gaussians that can receive gradients. The overview of our method is illustrated in Fig. 2. input : a set of images of a static scene + the corresponding cameras calibrated by SfM (produces a sparse point cloud [side effect?]) -&gt; 3D Gaussians (include a position(mean), covariance matrix and opacity alpha) compact representation of the 3D scene SH -&gt; The directional appearance component(color) of the radiance field optimization regime(?) Model the geometry as a set of 3D Gaussians that don’t require normals. affine(仿射) 推公式： 3D Gaussian表示了一个三维数据组，满足三维的高斯分布，经过推导之后可以用协方差矩阵的逆和协方差矩阵的行列式表示。 数据需要经过Camera Calibration,所以协方差矩阵也要经过相应的变换，方法是左乘W(世界坐标系到摄像机坐标系的变换矩阵)和J(3D摄像机坐标系到2D像素坐标系的jacobian matrix，为了抵消非线性变换带来的影响)，由于是分布变换，所以还要右乘对应的矩阵的转置。 协方差矩阵经过特征值分解的特征向量和特征值矩阵，在几何意义上是旋转矩阵和缩放矩阵的平方(因为是方差)的形式对应，用V表示旋转矩阵，用L表示特征值矩阵有: ∑=VLV−1\\sum = VLV^{-1} ∑=VLV−1 在论文中用 R 表示旋转矩阵 用 S 表示缩放矩阵，则有： ∑=RSSR−1\\sum = RSSR^{-1} ∑=RSSR−1 用 T 表示变换矩阵，则可以写成： ∑=RSSTRT=RS(SR)T=TTT\\sum = RSS^{T}R^{T} = RS(SR)^{T} = TT^{T} ∑=RSSTRT=RS(SR)T=TTT 此外，为了节约计算量，使用四元数表示旋转矩阵 covariance matrices have physical meaning only when they are positive semi-definite. --&gt; cannot directly optimize the covariance matrix ∑\\sum∑ to obtain 3D Gaussians that represent the radiance field. constrain(约束) So, use the formula : ∑=RSSTRT=RS(SR)T=TTT\\sum = RSS^{T}R^{T} = RS(SR)^{T} = TT^{T} ∑=RSSTRT=RS(SR)T=TTT And store them separately : a 3D vector sss for scaling a quaternion qqq to represent rotation derive the gradients for all parameters explicitly --&gt; avoid significant overhead due to automatic differentiation during training. optimization: positions ppp,α\\alphaα,covarivance ∑\\sum∑,SH coefficients The optimization of these parameters is interleaved with steps that control the density of the Gaussians to better represent the scene. Inevitably, geometry may be incorrectly palced due to the ambiguities of 3D to 2D projection. --&gt; our optimization thus needs to be able to create geometry and also destroy or mobe geometry if it is incorrect. The quality of the parameters of the covarivances of the 3D Gaussians is critical. --&gt; large homogeneous areas can be captured with a small number of large anisotropic Gaussians. Stochastic Gradient Descent sigmoid activation function for α\\alphaα exponential activation function for the scale of the covariance Reason : to constrain it in the [0 - 1) range and obtain smooth gradients. densify every 100 iterations and remove any Gaussians that are essentially transparent. densify Gaussians with an average magnitude of view-space position gradients above a threshold τpos\\tau_{pos}τpos​ under-reconstructed regions – regions with missing geometric features over-reconstructed regions – regions where Gaussians cover large area in the scene. cover the new geometry that must be created (For small Gaussian that are in under-reconstructed regions) --&gt; clone the gaussians. simply creating a copy of the same size, and moving it in the direction of the positional gradient large Gaussians in regions with high variance need to be split into smaller Gaussians, also initialize their position by using the original 3D Gaussian as a PDF for sampling. A effective way to moderate the increase in the number of Gaussians is to set the α\\alphaα value close to zero every N = 3000 iterations Our fast rasterizer allows efficient backpropagation over an arbitrary number of blended Gaussians with low additional memory consumption, requiring only a constant overhead per pixel. Specially, we only keep Gaussians with a 99% confidence interval intersecting the view frustum. Additionally, we use a guard band to trivially reject Gaussians at extreme positions. instantiate each Gaussian according to the number of tiles they overlap and assign each instance a key that combines view space depth and tile ID. sort Gaussians based on these keys using a single fast GPU Radix Sort. (α\\alphaα blending) these approximations become negligible as splats approach the size of individual pixels. During rasterization, the saturation of α\\alphaα is the only stopping cirterion. During the backward pass, we must therefore recover the full sequence of blended points per-pixel in the forward pass. traverse the per-tile lists again. To facilitate gradient computation, we now traverse them back-to-front. Rasterization The traversal starts from the last point that affected any pixel in the tile, and loading of points into shared memory again happens collaboratively. Additionally, each pixel will only start overlap testing and processing of points if their depth is lower than or equal to the depth of the last point that contributed to its color during the forward pass. (深度测试?) recover intermediate opacities by storing only the total accumulated opacity at the end of the forward pass. Specifically, each point stores the final accumulated opacity α\\alphaα in the forward process. We divide this by each point’s α\\alphaα in our back-to-front traversal to obtain the required coefficients for gradient computation. implementation SH coefficient optimization is sensitive to the lack of angular information. optimizing only the zero-order component, and then introduce one band of the SH after every 1000 interations unitl all 4 bands of SH are represented. Initialization with SfM points helps Densification splitting big Gaussians is important to allow good reconstruction of the background cloning the small Gaussians instead of splitting them allows for a better and faster convergence especially when thin structures appear in the scene. Unlimited is better. If we limit the number of points that receive gradients, the effect on visual quality is significant. The use of anisotropic volumetric splats enables modelling of fine structures and has a significant impact on visual quality. spherical harmonics improves (?) limitations popping artifacts when our optimization creates large Gaussians view-dependent appearance reason: trivial rejection of Gaussians via a guard band in the rasterizer simple visibility algorithm,which can lead to Gaussians suddenly switching depth/blending order (antialiasing) do not apply any regularization(正则化) to our optimization the GPU memory figure could be significantly reduced by a careful low-level implementation of the optimization logic. (i.e. Compression techniques method) 可微的3D Gaussian Splatting 初始化利用SfM的点云，包含 Position(Mean)、Covariance Matrix、Opacity α\\alphaα 、Spherical harmonics 其中： 点的位置(也即3D Gaussian的均值)、 协方差矩阵，决定Gaussian形状 不透明度，用于渲染，把他点往图像平面上投的时候，它们的扩散痕迹是通过这个不透明度，叠加在一起的 球谐函数，用来拟合视角相关的外观 （球谐函数本身就是用一组正交基的线性组合来拟合光场） 3D Gaussian，需要一种图元，能够在拥有场景表达能力的时候可微，且显式地支持快速渲染 3D Gaussian点云里面的参数可以在迭代优化的过程中更新，而且能够很容易地用splat的方法，来投影到2D图像上，做非常快的α\\alphaα混合 （rendering） Jacobian Matrix的推导 投影公式 投影公式用于将三维空间中的点 (x,y,z)(x, y, z)(x,y,z) 映射到二维屏幕平面上的点 (x′,y′)(x&#x27;, y&#x27;)(x′,y′)。 (1)相机坐标系与视图坐标系 首先假设点 (x,y,z)(x, y, z)(x,y,z) 是在相机坐标系下的三维坐标。相机位于原点，视线沿 zzz-轴正方向。 (x,y,z)( x, y, z )(x,y,z) 表示点的三维位置。 zzz 是点与相机的距离。 (2)转换到投影平面(深度透视) 在相机的投影模型中，投影平面通常设置为距离相机原点为 1 的位置（即 z=1z = 1z=1)。通过投影，三维点 (x,y,z)(x, y, z)(x,y,z) 会映射到投影平面上的点 (xp,yp,1)(x_p, y_p, 1)(xp​,yp​,1)，投影关系为： xp=xz,yp=yzx_p = \\frac{x}{z}, \\quad y_p = \\frac{y}{z} xp​=zx​,yp​=zy​ 其中： x/z 表示水平视角下点的位置与深度的比例。 y/z 表示垂直视角下点的位置与深度的比例。 为了将投影平面的坐标 (xp,yp)(x_p, y_p)(xp​,yp​) 转换为屏幕上的像素坐标，需要考虑相机的焦距 fxf_xfx​ 和 fyf_yfy​（单位像素），以及屏幕的分辨率和尺度变换。投影公式为： x′=fx⋅xp=fx⋅xz,y′=fy⋅yp=fy⋅yzx&#x27; = f_x \\cdot x_p = \\frac{f_x \\cdot x}{z}, \\quad y&#x27; = f_y \\cdot y_p = \\frac{f_y \\cdot y}{z} x′=fx​⋅xp​=zfx​⋅x​,y′=fy​⋅yp​=zfy​⋅y​ 其中： fx=Width2⋅tan⁡(水平视角FovX/2)f_x = \\frac{\\text{Width}}{2 \\cdot \\tan(\\text{水平视角FovX} / 2)} fx​=2⋅tan(水平视角FovX/2)Width​ fy=Height2⋅tan⁡(垂直视角FovY/2)f_y = \\frac{\\text{Height}}{2 \\cdot \\tan(\\text{垂直视角FovY} / 2)} fy​=2⋅tan(垂直视角FovY/2)Height​ 其中fx,fyf_x, f_yfx​,fy​是相机内参，定义了投影比例。 结合以上推导，透视投影公式可以写为： x′=fx⋅xz,y′=fy⋅yzx&#x27; = \\frac{f_x \\cdot x}{z}, \\quad y&#x27; = \\frac{f_y \\cdot y}{z} x′=zfx​⋅x​,y′=zfy​⋅y​ 推导Jacobian矩阵 在计算机图形学和3D变换中，Jacobian 矩阵用于描述从一个空间（例如世界坐标系）到另一个空间（例如视图空间或屏幕空间）的坐标映射变化率。在这个例子中，Jacobian 矩阵 J 描述从 3D 视图空间到 2D 投影空间（屏幕坐标）的变化。 Jacobian 矩阵是投影变换对输入坐标的偏导数矩阵： J=∂(x′,y′)∂(x,y,z)J = \\frac{\\partial(x&#x27;, y&#x27;)}{\\partial(x, y, z)} J=∂(x,y,z)∂(x′,y′)​ 它表示投影变换中，每个 3D 坐标分量的微小变化对 2D 坐标的影响。 将以上偏导数写成矩阵形式： J=[∂x′∂x∂x′∂y∂x′∂z∂y′∂x∂y′∂y∂y′∂z]=[fxz0−fx⋅xz20fyz−fy⋅yz2]J = \\begin{bmatrix} \\frac{\\partial x&#x27;}{\\partial x} &amp; \\frac{\\partial x&#x27;}{\\partial y} &amp; \\frac{\\partial x&#x27;}{\\partial z} \\\\ \\frac{\\partial y&#x27;}{\\partial x} &amp; \\frac{\\partial y&#x27;}{\\partial y} &amp; \\frac{\\partial y&#x27;}{\\partial z} \\end{bmatrix} = \\begin{bmatrix} \\frac{f_x}{z} &amp; 0 &amp; -\\frac{f_x \\cdot x}{z^2} \\\\ 0 &amp; \\frac{f_y}{z} &amp; -\\frac{f_y \\cdot y}{z^2} \\end{bmatrix} J=[∂x∂x′​∂x∂y′​​∂y∂x′​∂y∂y′​​∂z∂x′​∂z∂y′​​]=[zfx​​0​0zfy​​​−z2fx​⋅x​−z2fy​⋅y​​] 1234glm::mat3 J = glm::mat3( focal_x / t.z, 0.0f, -(focal_x * t.x) / (t.z * t.z), 0.0f, focal_y / t.z, -(focal_y * t.y) / (t.z * t.z), 0, 0, 0); 这个矩阵用在后续的高斯分布投影中，用来减轻非线性变换对视图带来的影响 协方差矩阵转换为几何表达的椭圆 在二维高斯分布中，等概率密度的轮廓是一个椭圆，其定义如下： (x−μ)TΣ−1(x−μ)=c(x - \\mu)^T \\Sigma^{-1} (x - \\mu) = c (x−μ)TΣ−1(x−μ)=c 其中把(x−μ)(x-\\mu)(x−μ)当作向量基，协方差矩阵的逆矩阵看作基的系数，可以转化为一个xy坐标系上面的二次曲线 我们将椭圆的隐式方程由协方差逆矩阵 Σ−1\\Sigma^{-1}Σ−1 给出： [x y][Σ11−1Σ12−1Σ12−1Σ22−1][xy]=1[x \\; y] \\begin{bmatrix} \\Sigma^{-1}_{11} &amp; \\Sigma^{-1}_{12} \\\\ \\Sigma^{-1}_{12} &amp; \\Sigma^{-1}_{22} \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} = 1 [xy][Σ11−1​Σ12−1​​Σ12−1​Σ22−1​​][xy​]=1 展开后： Σ11−1⋅x2+2⋅Σ12−1⋅xy+Σ22−1⋅y2=1\\Sigma^{-1}_{11} \\cdot x^2 + 2 \\cdot \\Sigma^{-1}_{12} \\cdot xy + \\Sigma^{-1}_{22} \\cdot y^2 = 1 Σ11−1​⋅x2+2⋅Σ12−1​⋅xy+Σ22−1​⋅y2=1 我们知道对称矩阵协方差矩阵为： Σ=[cov.xcov.ycov.ycov.z]\\Sigma = \\begin{bmatrix} \\text{cov.x} &amp; \\text{cov.y} \\\\ \\text{cov.y} &amp; \\text{cov.z} \\end{bmatrix} Σ=[cov.xcov.y​cov.ycov.z​] 其逆矩阵 Σ−1\\Sigma^{-1}Σ−1： Σ−1=1det⁡(Σ)[cov.z−cov.y−cov.ycov.x]\\Sigma^{-1} = \\frac{1}{\\det(\\Sigma)} \\begin{bmatrix} \\text{cov.z} &amp; -\\text{cov.y} \\\\ -\\text{cov.y} &amp; \\text{cov.x} \\end{bmatrix} Σ−1=det(Σ)1​[cov.z−cov.y​−cov.ycov.x​] 所以可以得出对应二次曲线的系数 a=Σ11−1=cov.zdet⁡(Σ)a = \\Sigma^{-1}_{11} = \\frac{\\text{cov.z}}{\\det(\\Sigma)}a=Σ11−1​=det(Σ)cov.z​ b=Σ12−1=−cov.ydet⁡(Σ)b = \\Sigma^{-1}_{12} = -\\frac{\\text{cov.y}}{\\det(\\Sigma)}b=Σ12−1​=−det(Σ)cov.y​ c=Σ22−1=cov.xdet⁡(Σ)c = \\Sigma^{-1}_{22} = \\frac{\\text{cov.x}}{\\det(\\Sigma)}c=Σ22−1​=det(Σ)cov.x​ 为了表示为参数形式： conic={Σ11−1,Σ12−1,Σ22−1}={cov.zdet⁡(Σ),−cov.ydet⁡(Σ),cov.xdet⁡(Σ)}\\text{conic} = \\{\\Sigma^{-1}_{11}, \\Sigma^{-1}_{12}, \\Sigma^{-1}_{22}\\} = \\{\\frac{\\text{cov.z}}{\\det(\\Sigma)}, -\\frac{\\text{cov.y}}{\\det(\\Sigma)}, \\frac{\\text{cov.x}}{\\det(\\Sigma)}\\} conic={Σ11−1​,Σ12−1​,Σ22−1​}={det(Σ)cov.z​,−det(Σ)cov.y​,det(Σ)cov.x​} 123456789101112131415161718192021// Compute 2D screen-space covariance matrixfloat3 cov = computeCov2D(p_orig, focal_x, focal_y, tan_fovx, tan_fovy, cov3D, viewmatrix);// 调整cov对角线项，避免无法求逆，且增加泛化程度constexpr float h_var = 0.3f;const float det_cov = cov.x * cov.z - cov.y * cov.y;cov.x += h_var;cov.z += h_var;const float det_cov_plus_h_cov = cov.x * cov.z - cov.y * cov.y;float h_convolution_scaling = 1.0f;if(antialiasing) h_convolution_scaling = sqrt(max(0.000025f, det_cov / det_cov_plus_h_cov)); // max for numerical stability// Invert covariance (EWA algorithm)const float det = det_cov_plus_h_cov;if (det == 0.0f) return;float det_inv = 1.f / det;float3 conic = &#123; cov.z * det_inv, -cov.y * det_inv, cov.x * det_inv &#125;; 求旋转椭圆的长短轴 我们从给定的二次型方程(椭圆)开始： ax2+2bxy+cy2=1ax^2 + 2bxy + cy^2 = 1 ax2+2bxy+cy2=1 这个方程是一个二次型，可以写成矩阵形式： Q(x,y)=[xy][abbc][xy]=1Q(x, y) = \\begin{bmatrix} x &amp; y \\end{bmatrix} \\begin{bmatrix} a &amp; b \\\\ b &amp; c \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} = 1 Q(x,y)=[x​y​][ab​bc​][xy​]=1 这里的系数矩阵是对称矩阵： A=[abbc]A = \\begin{bmatrix} a &amp; b \\\\ b &amp; c \\end{bmatrix} A=[ab​bc​] 我们希望通过合同对角化（正交变换）将这个矩阵转化为对角矩阵，从而得到标准椭圆的形式。这样就可以得到长短轴。 假设矩阵 AAA 的特征向量分别为 v1v_1v1​ 和 v2v_2v2​，则矩阵 PPP 由这两个特征向量组成，且： P=[v1v2]P = \\begin{bmatrix} v_1 &amp; v_2 \\end{bmatrix} P=[v1​​v2​​] 如果我们使用矩阵 PPP 进行坐标变换，即令新的坐标 x′x&#x27;x′ 为： x′=P−1xx&#x27; = P^{-1} x x′=P−1x 那么，经过坐标变换后，二次型方程变为： x′TΛx′=1x&#x27;^T \\Lambda x&#x27; = 1 x′TΛx′=1 其中 Λ=diag(λ1,λ2)\\Lambda = \\text{diag}(\\lambda_1, \\lambda_2)Λ=diag(λ1​,λ2​) 是对角矩阵，包含了二次型的特征值。 x1′21λ12+x2′21λ22=1\\frac{x_1&#x27;^2}{\\frac{1}{\\sqrt{\\lambda_1}}^2} + \\frac{x_2&#x27;^2}{\\frac{1}{\\sqrt{\\lambda_2}}^2} = 1 λ1​​1​2x1′2​​+λ2​​1​2x2′2​​=1 这意味着： 长轴的半长轴 a=1λ1a = \\frac{1}{\\sqrt{\\lambda_1}}a=λ1​​1​, 短轴的半长轴 b=1λ2b = \\frac{1}{\\sqrt{\\lambda_2}}b=λ2​​1​. 为了对角化矩阵 AAA，我们首先求解其特征值和特征向量。特征值 λ1\\lambda_1λ1​ 和 λ2\\lambda_2λ2​ 是矩阵 AAA 的解，满足以下特征方程： det⁡(A−λI)=0\\det(A - \\lambda I) = 0 det(A−λI)=0 即： det⁡[a−λbbc−λ]=0\\det\\begin{bmatrix} a - \\lambda &amp; b \\\\ b &amp; c - \\lambda \\end{bmatrix} = 0 det[a−λb​bc−λ​]=0 计算行列式： (a−λ)(c−λ)−b2=0(a - \\lambda)(c - \\lambda) - b^2 = 0 (a−λ)(c−λ)−b2=0 展开后得到： λ2−(a+c)λ+(ac−b2)=0\\lambda^2 - (a + c)\\lambda + (ac - b^2) = 0 λ2−(a+c)λ+(ac−b2)=0 这个方程的解就是矩阵 ( A ) 的特征值 ( \\lambda_1 ) 和 ( \\lambda_2 )，分别为： λ1,λ2=(a+c)±(a+c)2−4(ac−b2)2\\lambda_1, \\lambda_2 = \\frac{(a + c) \\pm \\sqrt{(a + c)^2 - 4(ac - b^2)}}{2} λ1​,λ2​=2(a+c)±(a+c)2−4(ac−b2)​​ 这两个特征值即为二次型的主轴方向上的系数，它们决定了椭圆的长短轴。 分布变换","categories":[{"name":"CV","slug":"CV","permalink":"http://example.com/categories/CV/"},{"name":"CG","slug":"CG","permalink":"http://example.com/categories/CG/"}],"tags":[{"name":"3dgs","slug":"3dgs","permalink":"http://example.com/tags/3dgs/"}],"author":"tugumineko"},{"title":"cv,cg相关概念","slug":"cv-concepts","date":"2024-11-05T07:43:13.000Z","updated":"2024-11-11T15:39:40.251Z","comments":true,"path":"2024/11/05/cv-concepts/","permalink":"http://example.com/2024/11/05/cv-concepts/","excerpt":"","text":"相机校正 Camera Calibration 前言 从这里开始是研究现实世界转化到屏幕空间的关系，注意和图形学分别开 在图像测量过程以及机器视觉应用中，为确定空间物体表面某点的三维几何位置与其在图像中对应点之间的相互关系，必须建立相机成像的几何模型，这些几何模型参数就是相机参数 Camera Calibration简单来说就是求解世界空间到像素空间的过程，也就是求解最终的投影矩阵的过程 坐标系 （coordinate system） 世界坐标系、相机坐标系、图像坐标系、像素坐标系 标定 （calibration） 使用棋盘作为标定物，二维物体相对于三维物体会缺少一部分信息，于是多次改变棋盘的方位来捕捉图像。 从世界坐标系到相机坐标系 旋转平移矩阵 相机坐标系到理想图像坐标系 相似三角形 理想图像坐标系到实际图像坐标系 Radial Distortion (径向畸变) 光线经过透镜的边缘时，其弯曲程度比在透镜的中心为大 distortion的情况在透镜越小时越明显 可以通过泰勒级数展开式来校正（k1,k2,k3） Tangential Distortion (切向畸变) 成像仪被贴上摄像机的时候，误差使得影像平面和透镜不完全平行，从而产生切向畸变 如果一个矩形被投影到成像仪上时，可能会变成一个梯形 使用 (p1,p2)来校正 从实际图像坐标系到像素坐标系 平移，并且适应分辨率 新视角合成 Novel View Synthesis 新视角合成任务(Novel view synthesis)指的是给定源图像(src image)和源姿态(src pose),以及目标姿态(Target pose)，渲染生成目标姿态对应的图片 (Target image) 源姿态 从相机坐标系转化到世界坐标系的变换矩阵 从机器学习的角度理解：从一些&lt;图片，相机矩阵&gt;构成的训练集中模型，测试时给一个训练集中没有的相机矩阵，模型能预测出对应的图片 SfM(Structure from Motion) 是一种三维重建的方法，用于从motion中实现3D重建 从时间系列的2D图像中推测出3D信息 最优化 (Optimization) 泛指定量决策问题，主要关心如何对有限资源进行有效分配和控制，并达到某种意义上的最优 TBR (tile-based rendering) GPU的Tile-Based架构 所谓Tile，就是将几何数据转换成小矩形区域的过程。光栅化和片段处理在每Tile的过程中进行。Tile-Based Rendering的目的是在最大限度地减少fragment shading期间GPU 需要的外部内存访问量,从而来节省内存带宽。TBR将屏幕分成小块，并在将每个小图块写入内存之前对每个小图块进行片段着色。为了实现这一点，GPU 必须预先知道哪些几何体属于这个tile.因此，TBR将每个渲染通道拆分为两个处理通道： 第一遍执行所有与几何相关的处理，并生成该tile专属的Primitive list，指示哪些图元在tile内。 第二遍逐tile进行光栅化并且进行Fragment shading，并在完成后将其写回内存。 方便了部分算法的实现 TBR启用了一些算法，否则这些算法的计算成本太高或带宽使用过高。 tile足够小，于是可以在内存中本地存储足够多的sample，以实现MSAA。因此，硬件可以在tile写回内存期间将多个样本resolve，而无需单独的resolve pass。 传统的Defer-Rendering将使用多渲染目标 (MRT) 渲染来实现延迟照明，将每个像素的多个中间值写回主内存，然后在第二遍中重新读取它们。而在TBR中片段着色器以编程方式访问由先前片段存储在帧缓冲区中的值可以对Defer-Rendering进行优化。 Point Cloud A point cloud is a discrete set of data points in space. (三维图像) ray marching 对于某些效果使用参数化描述，难以使用三角面片描述，使用ray marching能够解决这些问题 ray marching按照摄像机方向(Ray)逐步前进(Marching)进行采样，是以迭代方式进行采样的 距离场 按距离物体表面最小距离进行迭代的步进 如果出现某些射线在步进一次并没有达到表面时，可以以此时距离物体的距离场再次按照原方向进行步进。如果某条线在步进多次后一直逐渐远离，也就是说明这根射线永远无法与物体相交，如果一根射线在步进多次后距离场的值越来越小，如果设值为0.01，那么就可以确定这个点的位置就是物体表面。 SDF有向距离场 描述空间中任意一个点到达物体最近的距离 gradient descent optimization 梯度下降优化算法 gradient 沿梯度的负方向的函数值下降最快的方向 eta 学习率 x←x−eta⋅df(x)dxx \\gets x - eta \\cdot \\frac {df(x)} {dx} x←x−eta⋅dxdf(x)​ 让 xxx减去etaetaeta乘以函数的导数 多元函数的梯度下降 rotation quaternion 四元数 Euler rotation 缺点： 这种方法是要按照一个固定的坐标轴的顺序旋转的，因此不同的顺序会造成不同的结果 欧拉旋转有父子层级，当中间层级的坐标轴旋转超过一定的范围时，导致中层和外层坐标轴重合，产生万向死锁(Gimbal Lock) Gimbal Lock会导致Euler Rotation无法实现球面平滑插值 quaternion 四元数 q=w+x⋅i+y⋅j+z⋅kq = w + x \\cdot i + y \\cdot j + z \\cdot k q=w+x⋅i+y⋅j+z⋅k 其中： i2=j2=k2=−1i^2 = j^2 = k^2 = -1 i2=j2=k2=−1 ij=−ji=kij = -ji = k ij=−ji=k jk=−kj=ijk = -kj = i jk=−kj=i ki=−ik=jki = -ik = j ki=−ik=j 三维空间中的旋转可以被认为是一个函数 ϕ\\phiϕ，从 R3\\mathbb{R}^3R3到自身的映射。函数 ϕ\\phiϕ 要想表示一个旋转，必须在旋转过程中保持向量长度(lengths)、向量夹角(angles)和handedness不变。(handedness和左右手坐标系有关，例如左手坐标系中向量旋转后，仍要符合左手坐标系规则) 长度保持不变要满足： ∥ϕ(P)∥=∥P∥\\left \\|\\phi(\\mathbf{P}) \\right \\| = \\left \\|\\mathbf{P} \\right\\| ∥ϕ(P)∥=∥P∥ 角度不变要满足： ϕ(P1)⋅ϕ(P2)=P1⋅P2\\phi(\\mathbf{P_1})\\cdot \\phi(\\mathbf{P_2}) = \\mathbf{P_1}\\cdot \\mathbf{P_2} \\qquad ϕ(P1​)⋅ϕ(P2​)=P1​⋅P2​ 最后，handedness保持不变要满足： ϕ(P1)×ϕ(P2)=ϕ(P1×P2)\\phi(\\mathbf{P_1})\\times \\phi(\\mathbf{P_2})=\\phi(\\mathbf{P_1}\\times\\mathbf{P_2}) \\qquad ϕ(P1​)×ϕ(P2​)=ϕ(P1​×P2​) (未完待续) 可以看3B1B来理解 两个四元数相乘需要16个乘加运算，然而两个3x3矩阵相乘需要27个乘加运算，因此在某些情况下（比如要对同一个对象施加多个旋转变换时），用四元数表示旋转，提高运算效率 分布变换 Warm-up 学习率预热 在预热的小学习率下，模型可以慢慢趋于稳定，等模型相对稳定后再选择预先设置的学习率进行训练，使得模型收敛速度变得更快，模型效果更佳 guard band 图中粉色的区域是 6500x4900 的屏幕空间，外圈黄色部分是XY轴上+16K~-16K的 guard band。下面的两个绿色三角形，会在三角形准备阶段被剔除掉。最常见的情况是类似蓝色三角形的情况，和屏幕区域相交，但是没有超出 guard-band 区域外，会走正常的 tile 处理流程，不会发生裁剪。红色的三角形，即和屏幕空间相交，又有超出 guard-band区域外的部分，会发生裁剪。注意右边的红色三角形，裁剪时划分成了两个小三角形。 由于显卡的帧缓冲是有限的，为了能够支持更大的世界，实际显卡的帧缓冲是支持比 viewport 的帧缓冲大小大得多的的，这个叫做guard band。但是他仍然是有限的，显卡能够处理的三角形也是必须在有限的空间里的（但是三角形的个数可以轻松上亿甚至十几亿），一半 60 帧的引擎同屏渲染几亿三角形应该不在话下。 所以实际 CPU 传给 GPU 进行光栅化的三角形空间位置也不能超出视口太多然后还要渲染的，这样的结果是显卡自己处理不了这种三角形，因为他无法访问这么大范围的数据。 所以是两阶段裁剪算法：CPU 必须保证所有传送的三角形都在 Guard band 里面。GPU 自己再裁一遍。 thread block thread: 一个CUDA的并行程序会被以许多个thread来执行。 block: 数个thread会被群组成一个block，同一个block中的thread可以同步，也可以通过shared memory进行通信。 ablation studies 狭义上的消融实验 在机器学习领域，尤其是复杂的深度神经网络中，&quot;消融研究 &quot;被用来描述切除网络某些部分的过程，以便更好地了解网络的行为。 可以看出，消融实验的目的在于移除系统中的特定的部分，来控制变量式的研究这个部分对于系统整体的影响。如果去除这一部分后系统的性能没有太大损失，那么说明这一部分对于整个系统而言并不具有太大的重要性；如果去除之后系统性能明显的下降，则说明这一部分的设计是必不可少的。当然，如果出现了第三种情况，也就是去除之后模型的性能不降反升，那么建议找一下bug或者修改设计。 广义上的消融实验 我们知道，消融实验的本质上就是控制变量研究单个变量的作用。针对那些无法去除的变量，比如超参数的选择，这时候总不能说让我们把超参数直接去掉来研究它的影响，因此在这种情况下应该应该选择控制系统的其他方面不变，来测试一组超参数来研究这个参数对于系统的影响。因此，超参数调参常用的grid search和random search本质上也是消融实验，它们探究了在只改变一个参数的情况下系统性能的变化从而展示参数对于系统的影响。 gradient flow 梯度流 优化算法中的梯度流与微分方程 参考资料： 协方差矩阵的几何解释","categories":[{"name":"cv","slug":"cv","permalink":"http://example.com/categories/cv/"},{"name":"cg","slug":"cg","permalink":"http://example.com/categories/cg/"}],"tags":[{"name":"3dgs","slug":"3dgs","permalink":"http://example.com/tags/3dgs/"}],"author":"tugumineko"},{"title":"TA百人计划笔记","slug":"TA百人计划笔记","date":"2024-10-22T11:14:45.000Z","updated":"2024-10-22T11:37:25.206Z","comments":true,"path":"2024/10/22/TA百人计划笔记/","permalink":"http://example.com/2024/10/22/TA%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92%E7%AC%94%E8%AE%B0/","excerpt":"","text":"图形 1.2 向量叉积理解 Unity中使用CG语言时，矩阵的存储遵循CG语言的规则是行优先填充的，但Unity提供了一种特殊的矩阵类型——Matrix4x4便于变换矩阵的定义，只有这种Matrix4x4是列优先填充的。 其实就先想象世界空间和视觉空间是重合的，再将视觉空间作为参照物，让世界空间相对于视觉空间通过缩放旋转平移变换还原到世界空间原本所在的位置，而前面缩放旋转平移变换所得矩阵即世界空间变换到视觉空间的矩阵","categories":[{"name":"CG","slug":"CG","permalink":"http://example.com/categories/CG/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F/"}],"author":"tugumineko"},{"title":"智能软硬件蓝牙系统ArdiFan","slug":"ArdiFan","date":"2024-09-06T15:11:47.000Z","updated":"2024-09-06T15:34:31.741Z","comments":true,"path":"2024/09/06/ArdiFan/","permalink":"http://example.com/2024/09/06/ArdiFan/","excerpt":"","text":"根据华东师范大学《创客实践》课程期末考查方案相关要求，ArdiFan是基于Arduino Nano 3开发板的智能软硬件系统，旨在实现风扇的智能控制，本项目为本人作业上传。 项目简介 ArdiFan是基于Arduino Nano 3开发板的智能软硬件系统，旨在实现风扇的智能控制。 ArdiFan名称Ardi取自Arduino、Remote、Detection、Intelligent的缩写，并且简要概括了该智能软硬件系统的核心功能。Fan取自项目类型，即电动风扇。 本项目包含三个组成部分：ArdiFan为主体硬件，ArdiFan.ino为arduino上运行的系统程序， AndroidClient是蓝牙控制Android平台的app工程源文件。 本项目包含超声波、按钮与蓝牙三种控制方式：当超声波检测到距离小于40cm时，自动启动风扇；距离大于40cm并持续3秒后，风扇自动关闭；按钮控制需要在超声波检测距离小于40cm的情况下方可操作。此外，蓝牙模块可通过手机APP远程控制风扇的开闭，进一步提升使用便捷性。本系统采用直流电机和继电器进行简单、低成本的风扇操作，且具备节能、远程控制等优势，适用于公共交通和车载服务等场景。 项目背景 随着科学技术的日益发展，智能家居成为了一种趋势，从而对传统家电进行智能升级成为了一个热门话题。ArdiFan应运而生，它通过现代通信蓝牙技术为用户提供了便捷的风扇控制方式。 主要功能 1.超声波自动控制：当超声波传感器检测到距离小于40cm时，风扇自动启动；距离大于40cm且持续3秒时，风扇自动关闭。 2.按钮手动控制：当超声波检测到距离小于40cm时，用户可以通过按钮对风扇进行手动控制。 3.蓝牙远程控制：通过蓝牙模块与手机APP连接，用户在任何距离下都能远程控制风扇的开关。 应用场景 下面将以车载服务中的智能风扇控制系统为例，介绍本系统进行的简单、低成本的风扇操作，且具备节能、远程控制等优势，适用于公共交通和车载服务等场景。 在车载服务场景中，乘客的舒适度直接影响服务体验。尤其在炎热的夏季，车内的温度管理成为了提高乘客满意度的关键因素之一。传统的车内风扇控制多依赖于驾驶员手动操作或乘客的口头请求，这在实际应用中可能无法及时响应乘客的需求，尤其是在乘客密集或驾驶员注意力集中于道路情况时。 ArdiFan智能风扇控制系统针对的正是上述问题。通过在车内安装基于Arduino Nano 3开发板的ArdiFan系统，配合超声波传感器、蓝牙模块和相关控制逻辑，能够实现以下功能： 1.自动调节风扇开关：当超声波传感器检测到车内特定区域（如乘客座位区）有乘客存在（距离小于40cm）时，自动启动风扇，当乘客离开该区域且无新乘客进入超过3秒后，风扇自动关闭。这使得车内温度管理更加智能化和自动化，即时响应乘客的舒适度需求。 2.手动控制机制：在需要手动调节风扇开关的情况下，乘客或驾驶员可以直接通过安装于车内方便触达的按钮进行操作，或通过预先配对的蓝牙设备（如智能手机APP）远程控制风扇，满足特定需求。 3.智能节能：通过自动控制风扇的开闭，ArdiFan能够根据实时需求调整风扇运行，避免无效的电能消耗，实现节能减排的同时保障乘客舒适。 在公共交通工具（如公交车、出租车）和车载服务（如网约车）场景中，ArdiFan的部署能极大提升乘车体验，尤其在炎热或拥挤的条件下，自动和智能化的风扇控制能为乘客提供即时的凉爽环境，增加乘客满意度，对提升服务品质和竞争力具有积极的推动作用。同时，节能特性也符合现代环保理念，有助于减少能源浪费，推动绿色出行。 通过在车载服务场景中引入ArdiFan这样的智能风扇控制系统，体现了智能科学技术在提升传统服务领域用户体验中的巨大潜力和应用价值。 技术原理 项目基于Arduino Nano 3开发板，利用超声波传感器HC-SR04进行距离检测，通过继电器模块控制风扇电源开关。蓝牙通信部分采用HC-06模块，实现与Android客户端的数据交换。 Android客户端的技术原理则主要围绕蓝牙通信、动态权限请求、数据流的读写操作、多线程管理以及界面用户交互(UI)更新几个关键点展开。 代码部分将会在实现方法与步骤说明 实现方法与步骤 一、硬件部分 使用器材： Arduino Nano 3 --1 Bluetooth Wireless HC-06 --1 Distance sensor HC-SR04 --1 R3000C DC motor --1 Button switch --1 1 Channel 5v Relay Module --1 AAA Battery Holders --1 Breadboard half-size --2 AAA Battery --2 导线若干 根据电路图连接，如图所示： 实物连接如下： 二、软件部分 下面我将对代码进行分析说明： Arduino部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;SoftwareSerial.h&gt;const int TrigPin = 2;const int EchoPin = 3;const int FAN_PIN = 4;const int BUTTON_PIN = 5;unsigned long fanOffBeginTime = 0;unsigned long lastDebounceTime = 0; // 上一次防抖时间unsigned long lastButtonPressTime = 0; // 上次按钮按下的时间const unsigned long debounceDelay = 50; // 防抖延迟常量bool controlByBT = true; // 蓝牙总控制// 按钮操作标志bool button2ON = false; bool button2OFF = false; SoftwareSerial BTSerial(10, 11); // 创建软件串口void setup() &#123; pinMode(TrigPin, OUTPUT); pinMode(EchoPin, INPUT); pinMode(FAN_PIN, OUTPUT); pinMode(BUTTON_PIN, INPUT_PULLUP); // 启用内部上拉电阻 Serial.begin(9600); BTSerial.begin(9600);&#125;void loop() &#123; static bool fanStatus = false; static int lastButtonStatus = HIGH; // 默认状态是 HIGH，因为启用了内部上拉 int distance = getAvgDistance(); unsigned long currentMillis = millis(); static unsigned long previousMillis = 0; const long interval = 1000; // 设置时间间隔为100毫秒 // 按钮模块 int currentButtonStatus = digitalRead(BUTTON_PIN); if (currentButtonStatus != lastButtonStatus &amp;&amp; millis() - lastDebounceTime &gt; debounceDelay) &#123; lastDebounceTime = millis(); lastButtonStatus = currentButtonStatus; if (currentButtonStatus == LOW) &#123; // 按钮从 HIGH 变为 LOW (fanStatus ? button2OFF : button2ON) = true; lastButtonPressTime = millis(); // 记录按钮按下时间 &#125; &#125; // 蓝牙板块 if(BTSerial.available())&#123; String state = BTSerial.readString(); if(state == &quot;on&quot;)&#123; controlByBT = true; // 如果接收到&quot;on&quot;，则 controlByBT 设置为 true &#125; else if(state == &quot;off&quot;)&#123; controlByBT = false; // 如果接收到&quot;off&quot;，则 controlByBT 设置为 false，关闭风扇 fanStatus = false; button2ON = false; button2OFF = false; &#125; &#125; // 距离控制风扇逻辑 if (controlByBT) &#123; if (distance &lt; 40) &#123; if(button2OFF)&#123; fanStatus = false; &#125; if(button2ON)&#123; fanStatus = true; button2ON = false; button2OFF = false; &#125; if(!button2ON &amp;&amp; !button2OFF)&#123; fanStatus = true; &#125; fanOffBeginTime = millis(); &#125; if (millis() - fanOffBeginTime &gt; 3000) &#123; fanStatus = false; button2ON = false; button2OFF = false; &#125; &#125; digitalWrite(FAN_PIN, fanStatus ? HIGH : LOW); // 控制风扇 //蓝牙串口输出 if (currentMillis - previousMillis &gt;= interval) &#123; previousMillis = currentMillis; BTSerial.print(distance); BTSerial.print(&quot; &quot;); BTSerial.println(fanStatus ? &quot;on&quot; : &quot;off&quot;); &#125;&#125;// 防抖 多次测量求中位数int getAvgDistance() &#123; int readings[10]; for (int i = 0; i &lt; 10; i++) &#123; digitalWrite(TrigPin, LOW); delayMicroseconds(5); digitalWrite(TrigPin, HIGH); delayMicroseconds(10); digitalWrite(TrigPin, LOW); readings[i] = pulseIn(EchoPin, HIGH) / 58.0; delay(10); &#125; qsort(readings, 10, sizeof(int), cmp); return readings[5]; // 返回中位数&#125;int cmp(const void *a, const void *b) &#123; return *(int*)a - *(int*)b;&#125; 概括地说，这段代码包含以下四个关键部分的实现：超声波距离感测、按钮控制、蓝牙通信控制，以及防抖处理。 超声波距离感测：超声波传感器HC-SR04用于测量对象到传感器的距离。当触发脚（TrigPin）接收到高电平脉冲信号时，HC-SR04会发射一系列超声波脉冲。这些脉冲遇到障碍物后会反射回来，被回声脚（EchoPin）接收。通过计算超声波被发射和接收的时间差，可以根据声波在空气中的传播速度计算出距离。这部分代码首先将超声波信号发射出去，然后测量接收到回声的时间，从而计算出距离。 按钮控制：按钮控制部分通过监听按钮引脚的电平变化来控制风扇开关状态。由于物理按钮在状态变化时会存在接触抖动，因此需要进行防抖处理，以避免误判。这里当检测到按钮状态改变，并且距离上 一次状态变化超过一定的防抖延时（debounceDelay），才认为是有效的按钮操作。 蓝牙通信控制：通过SoftWareSerial库创建的软件串口BTSerial实现与蓝牙模块HC-06的通信。系统通过读取蓝牙模块传来的字符串命令（“on&quot;或&quot;off”），来控制风扇的开启和关闭。 防抖处理：采用多次测量并排序取中位数的方法，可以有效减少偶发错误读数的影响，提高测量的准确性。 基于这些输入，系统实现了一个既能自动响应环境变化，又能接受外部指令或手动控制的智能控制逻辑。 Android Studio部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265package com.example.heart;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import androidx.cardview.widget.CardView;import androidx.core.app.ActivityCompat;import androidx.core.content.ContextCompat;import android.Manifest;import android.bluetooth.BluetoothAdapter;import android.bluetooth.BluetoothDevice;import android.bluetooth.BluetoothSocket;import android.content.Intent;import android.content.IntentFilter;import android.content.pm.PackageManager;import android.os.Build;import android.os.Bundle;import android.widget.LinearLayout;import android.widget.TextView;import android.widget.Toast;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.util.UUID;public class MainActivity extends AppCompatActivity &#123; LinearLayout ll_start,ll_stop; // 获取到蓝牙适配器 private BluetoothAdapter mBluetoothAdapter; // UUID，蓝牙建立链接需要的 private final UUID MY_UUID = UUID .fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;); // 选中发送数据的蓝牙设备，全局变量，否则连接在方法执行完就结束了 private BluetoothDevice selectDevice; // 获取到选中设备的客户端串口，全局变量，否则连接在方法执行完就结束了 private BluetoothSocket clientSocket; // 获取到向设备写的输出流，全局变量，否则连接在方法执行完就结束了 public static InputStream is; public static OutputStream os; private String receivedData=&quot;&quot;; private Thread thread; private volatile boolean running = true; // 线程运行控制标志 private TextView tv_1,tv_2; private static final int PERMISSION_REQUEST_CODE = 100; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ll_start = findViewById(R.id.ll_start); ll_stop = findViewById(R.id.ll_stop); tv_1 = findViewById(R.id.textView1); tv_2 = findViewById(R.id.textView2); ll_start.setOnClickListener(view -&gt; &#123; Toast.makeText(this, &quot;开始连接&quot;, Toast.LENGTH_SHORT).show(); init蓝牙(); &#125;); ll_stop.setOnClickListener(view -&gt; &#123; running = false; // 安全地停止线程 &#125;); // 检查并申请权限 if (!hasRequiredPermissions()) &#123; requestRequiredPermissions(); &#125; findViewById(R.id.open).setOnClickListener(v -&gt; &#123; if (os == null) &#123; Toast.makeText(this, &quot;请先连接&quot;, Toast.LENGTH_SHORT).show(); return; &#125; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; os.write(&quot;on&quot;.getBytes()); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;).start(); Toast.makeText(this, &quot;发送成功&quot;, Toast.LENGTH_SHORT).show(); &#125;); findViewById(R.id.close).setOnClickListener(v -&gt; &#123; if (os == null) &#123; Toast.makeText(this, &quot;请先连接&quot;, Toast.LENGTH_SHORT).show(); return; &#125; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; os.write(&quot;off&quot;.getBytes()); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;).start(); Toast.makeText(this, &quot;发送成功&quot;, Toast.LENGTH_SHORT).show(); &#125;); &#125; private boolean hasRequiredPermissions() &#123; return ContextCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH) == PackageManager.PERMISSION_GRANTED &amp;&amp; ContextCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH_CONNECT) == PackageManager.PERMISSION_GRANTED &amp;&amp; ContextCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH_SCAN) == PackageManager.PERMISSION_GRANTED &amp;&amp; ContextCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH_ADMIN) == PackageManager.PERMISSION_GRANTED &amp;&amp; ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED &amp;&amp; ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED; &#125; private void requestRequiredPermissions() &#123; ActivityCompat.requestPermissions(this, new String[] &#123; Manifest.permission.BLUETOOTH, Manifest.permission.BLUETOOTH_CONNECT, Manifest.permission.BLUETOOTH_SCAN, Manifest.permission.BLUETOOTH_ADMIN, Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION &#125;, PERMISSION_REQUEST_CODE); &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == PERMISSION_REQUEST_CODE) &#123; boolean allPermissionsGranted = true; for (int result : grantResults) &#123; if (result != PackageManager.PERMISSION_GRANTED) &#123; allPermissionsGranted = false; break; &#125; &#125; if (allPermissionsGranted) &#123; // 所有权限都已授予，执行需要权限的操作 &#125; else &#123; // 权限被拒绝，处理拒绝情况 &#125; &#125; &#125; private void init蓝牙() &#123; // 获取到蓝牙默认的适配器 mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); // 对其进行分割，获取到这个设备的地址 String address = &quot;98:D3:61:F9:4F:B8&quot;; // 判断当前是否还是正在搜索周边设备，如果是则暂停搜索 if (ActivityCompat.checkSelfPermission(MainActivity.this, android.Manifest.permission.BLUETOOTH_SCAN) != PackageManager.PERMISSION_GRANTED) &#123; //判断是否正在搜索 &#125; if (mBluetoothAdapter.isDiscovering()) &#123; mBluetoothAdapter.cancelDiscovery(); &#125; // 如果选择设备为空则代表还没有选择设备 if (selectDevice == null) &#123; //通过地址获取到该设备 selectDevice = mBluetoothAdapter.getRemoteDevice(address); &#125; // 这里需要try catch一下，以防异常抛出 try &#123; // 判断客户端接口是否为空 if (clientSocket == null) &#123; clientSocket = selectDevice .createRfcommSocketToServiceRecord(MY_UUID); // 向服务端发送连接 clientSocket.connect(); // 获取到输出流，向外写数据 os = clientSocket.getOutputStream(); // 获取到输入流，用于接收数据 is = clientSocket.getInputStream(); &#125; // 吐司一下，告诉用户成功 if (os != null)&#123; Toast.makeText(MainActivity.this, &quot;连接成功&quot;, Toast.LENGTH_SHORT).show(); running = true; // 安全地开始线程 thread = new GetData(); thread.start(); &#125;else &#123; Toast.makeText(MainActivity.this, &quot;建立连接失败&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); // 如果发生异常则告诉用户发送失败 Toast.makeText(MainActivity.this, &quot;连接失败&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; class GetData extends Thread &#123; @Override public void run() &#123; while (running) &#123; try &#123; byte[] buffer = new byte[1024]; int bytesRead; StringBuilder stringBuilder = new StringBuilder(); while ((bytesRead = is.read(buffer)) != -1) &#123; receivedData = new String(buffer, 0, bytesRead); stringBuilder.append(receivedData); //System.out.println(receivedData); if (!running)break; if(receivedData!=null)&#123; if (receivedData.contains(&quot;\\n&quot;)) receivedData = receivedData.split(&quot;\\n&quot;)[0]; if (receivedData.contains(&quot;on&quot;)||receivedData.contains(&quot;of&quot;))&#123; String[] a = receivedData.trim().split(&quot; &quot;); for (int i = 0; i &lt; a.length; i++) &#123; if (a[i].contains(&quot;on&quot;)||a[i].contains(&quot;of&quot;))&#123; tv_2.setText(&quot;运行状态: &quot;+a[1]); &#125;else &#123; if (!a[i].isEmpty())&#123; tv_1.setText(&quot;检测距离: &quot;+a[0]+&quot; cm&quot;); &#125; &#125; &#125; System.out.println(&quot;data:&quot;+receivedData); &#125; &#125; &#125; &#125; catch (IOException e) &#123; // e.printStackTrace(); if (!running) &#123; // 如果线程是因为调用 stopRunning 而中断的，则退出循环 break; &#125; &#125; catch (Exception e) &#123; //e.printStackTrace(); &#125; &#125; &#125; &#125; public static String getCurrentTimeString() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; // 获取当前日期和时间 LocalDateTime now = null; now = LocalDateTime.now(); // 定义日期时间格式 DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;); // 将当前日期时间格式化为字符串 return now.format(formatter); &#125;else &#123; return &quot;2023-12-09 16:06:34&quot;; &#125; &#125; 这段代码实现了通过蓝牙与Arduino设备建立连接并进行交互。 首先初始化应用界面，包括设置按钮监听器，用于开始和结束与设备的连接。 2. 为了在Android 6.0及以上版本上正常运作，还要请求用户授权蓝牙和位置访问权限。得到权限后，应用通过蓝牙适配器查找并连接到指定的Arduino设备，使用一个预定义的UUID建立一个安全的RFComm（串行端口服务）连接。 3. 连接成功后，应用可以获取输出流和输入流，以向设备发送指令（比如“开”或“关”指令）并读取设备返回的数据。发送和接收数据的功能在一个叫做GetData的线程中实现，以避免主线程阻塞。 4. 之后用户可以通过点击界面上的按钮发送特定的指令到Arduino设备，应用将根据从Arduino设备接收到的数据更新界面上的显示内容。 运行结果如下： 距离检测和风扇状态显示： Android客户端的最上方两行分别显示当前超声波检测到的距离（单位：cm）和风扇的运行状态（on或off）。 风扇控制： 在客户端的中间区域，提供两个按钮，分别用于手动控制风扇的开闭状态。 蓝牙连接管理： 客户端的最下方两行用于蓝牙功能，其中一个按钮用于连接蓝牙模块，另一个按钮用于断开连接。 关键技术 多模式控制机制：ArdiFan系统集成了超声波感应、物理按钮操作和蓝牙远程控制三种控制模式，为用户提供了多样化的操作选择。这种多模式的设计使得ArdiFan能够在不同情境下灵活使用，例如自动感应开关功能适用于无手触控的环境，而蓝牙控制则便于用户在远距离进行操作。 智能节能策略：通过集成的超声波传感器自动检测用户的存在与否，ArdiFan能在用户靠近时自动开启风扇，在用户离开一定时间后自动关闭风扇，从而实现节能减排的目的。这种自动化控制策略有效减少了能源浪费。 跨平台远程控制应用：ArdiFan项目包含了一个Android客户端，使得用户可以通过智能手机远程控制风扇。这种跨平台的应用开发为Arduino项目提供了更广阔的使用场景，增加了用户交互的便捷性。 低成本实现高价值功能：整个ArdiFan系统的实现基于成本相对低廉的Arduino板和传感元件，但却实现了市面上高端智能风扇才具备的功能，展现了利用开源硬件和软件平台进行智能家居项目开发的巨大潜力。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"C","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"Arduino","slug":"Arduino","permalink":"http://example.com/tags/Arduino/"}],"author":"tugumineko"},{"title":"cpp多线程使用方法","slug":"cpp-thread","date":"2024-08-18T11:25:55.000Z","updated":"2024-08-18T13:01:49.450Z","comments":true,"path":"2024/08/18/cpp-thread/","permalink":"http://example.com/2024/08/18/cpp-thread/","excerpt":"","text":"C++11的std::thread 开门见山，cpp多线程使用方法就是使用C++11的thread进行多线程编程。 std::thread常用成员函数 构造&amp;析构函数 函数 类别 作用 thread() 默认构造函数 创建一个线程 thread(thread&amp;&amp; x) 移动构造函数 构造一个与x相同的对象，会破环x对象 ~thread() 析构函数 析构对象 常用成员函数 函数 作用 void join() 等待线程结束并清理资源(会阻塞) bool joinable() 返回线程是否可以执行join函数 void detach() 将线程与调用其的线程分离，彼此独立执行(此函数必须在线程创建时立即调用，且调用此函数会使其不能被join) std::thread::id_get_id 获取线程id thread&amp; operator=(thread &amp;&amp;rhs) 移动构造函数(如果对象是joinable的，那么会调用std::terminate) 注意事项 线程是在thread对象被定义的时候开始执行的，而不是在调用join函数时才执行的，调用join函数只是阻塞等待线程结束并回收资源 分离的线程（执行过detach的线程）会在调用它的线程结束或自己结束时释放资源 线程会在函数运行后自动释放，不推荐利用其他方法强制结束线程，可能会因资源未释放而导致内存泄露。 没有执行join或detach的线程在程序结束时会引发异常 std::atomic和std::mutex 作用：多个线程需要操作同一个变量时，防止产生竞争与冲突 std::mutex std::mutex是C++中最基本的互斥量，一个线程将mutex锁住时，其他的线程就不能操作mutex，直到这个线程将mutex解锁。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;int n = 0;mutex mtx;void count10000() &#123; for (int i = 1; i &lt;= 10000; i++) &#123; mtx.lock(); n++; mtx.unlock(); &#125;&#125;int main() &#123; thread th[100]; for (thread &amp;x : th) x = thread(count10000); for (thread &amp;x : th) x.join(); cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; mutex的常用成员函数 函数 作用 void lock() 将mutex上锁。如果mutex已经被其他线程上锁,那么mutex已经被同一个线程锁住，那么会产生死锁。 void unlock() 解锁mutex,释放其所有权。如果有线程因为调用lock()不能上锁而被阻塞，则调用此函数会将mutex的主动权随机交给其中一个线程;如果mutex不是被此线程上锁，那么会引发未定义的异常。 bool try_lock() 尝试将mutex上锁。如果mutex未被上锁，则将其上锁并返回true;如果mutex已被锁则返回false. std::atomic 由于每个thread都要循环地加锁、解锁，我们使用std::atomic来提高效率。 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;atomic&gt;using namespace std;//atomic&lt;int&gt; n = 0;原子变量不能使用拷贝构造atomic&lt;int&gt; n;void count10000() &#123; for (int i = 1; i &lt;= 10000; i++) &#123; n++; &#125;&#125;int main() &#123; thread th[100]; for (thread &amp;x : th) x = thread(count10000); for (thread &amp;x : th) x.join(); cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; 原子操作 是最小的且不可并行化的操作。 这就意味着即使是多线程，也要像同步进行一样同步操作atomic对象，从而省去了mutex上锁、解锁的时间消耗。 std::async std::future std::promise std::this_thread","categories":[{"name":"cpp","slug":"cpp","permalink":"http://example.com/categories/cpp/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"author":"tugumineko"},{"title":"GAMES101作业7 路径追踪(Path Tracing) 问题与思路详解全解","slug":"GAMES101-Assignment7","date":"2024-08-17T09:25:57.000Z","updated":"2024-11-14T04:10:30.605Z","comments":true,"path":"2024/08/17/GAMES101-Assignment7/","permalink":"http://example.com/2024/08/17/GAMES101-Assignment7/","excerpt":"","text":"前言 本次作业的内容是对上一次作业中的BVH遍历、射线三角形求交Möller-Trumbore算法进行迁移，以及在此基础上实现完整的 Path Tracing 算法。 请注意： 本次作业基于dalao的GAMES101作业框架，在Windows系统上实现。 函数迁移 Bounds3::IntersectP in Bounds3.hpp 本次作业中 cornell box 模型的墙壁和箱子某些三角形是平行于坐标平面的，会出现包围盒厚度为0的情况，因此求交要包含t_enter = t_exit 的情况。 12345678910111213141516171819202122232425262728293031323334353637383940// in Bounds3.hppinline bool Bounds3::IntersectP(const Ray&amp; ray, const Vector3f&amp; invDir, const std::array&lt;int, 3&gt;&amp; dirIsNeg) const&#123; // invDir: ray direction(x,y,z), invDir=(1.0/x,1.0/y,1.0/z), use this because Multiply is faster that Division // dirIsNeg: ray direction(x,y,z), dirIsNeg=[int(x&gt;0),int(y&gt;0),int(z&gt;0)], use this to simplify your logic // TODO test if ray bound intersects float min_x = (pMin.x - ray.origin.x) * invDir[0]; float max_x = (pMax.x - ray.origin.x) * invDir[0]; float min_y = (pMin.y - ray.origin.y) * invDir[1]; float max_y = (pMax.y - ray.origin.y) * invDir[1]; float min_z = (pMin.z - ray.origin.z) * invDir[2]; float max_z = (pMax.z - ray.origin.z) * invDir[2]; if (dirIsNeg[0]) &#123; std::swap(min_x, max_x); &#125; if (dirIsNeg[1]) &#123; std::swap(min_y, max_y); &#125; if (dirIsNeg[2]) &#123; std::swap(min_z, max_z); &#125; float t_enter = std::max(min_x, std::max(min_y, min_z)); float t_exit = std::min(max_x, std::min(max_y, max_z)); //包围盒厚度为0时，t_enter = t_exit if (t_enter &lt;= t_exit &amp;&amp; t_exit &gt;= 0) &#123; return true; &#125; else return false;&#125; BVHAccel::getIntersection in BVH.cpp 1234567891011121314151617181920// in BVH.cppIntersection BVHAccel::getIntersection(BVHBuildNode* node, const Ray&amp; ray) const&#123; // TODO Traverse the BVH to find intersection std::array&lt;int, 3Ui64&gt; dirIsNeg = &#123; static_cast&lt;int&gt;(ray.direction.x &lt; 0),static_cast&lt;int&gt;(ray.direction.y &lt; 0),static_cast&lt;int&gt;(ray.direction.z &lt; 0) &#125;;; if (node-&gt;bounds.IntersectP(ray, ray.direction_inv, dirIsNeg) == false) &#123; return Intersection&#123;&#125;; &#125; if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123; return node-&gt;object-&gt;getIntersection(ray); &#125; Intersection hit1 = getIntersection(node-&gt;left, ray); Intersection hit2 = getIntersection(node-&gt;right, ray); return hit1.distance &lt; hit2.distance ? hit1 : hit2;&#125; Triangle::getIntersection in Triangle.hpp 123456789101112131415161718192021222324252627282930313233343536373839404142inline Intersection Triangle::getIntersection(Ray ray)&#123; if (dotProduct(ray.direction, normal) &gt; 0) &#123; return Intersection&#123;&#125;; &#125; Vector3f s = ray.origin - v0; Vector3f s1 = crossProduct(ray.direction, e2); Vector3f s2 = crossProduct(s, e1); float de = dotProduct(s1, e1); if (fabs(denominator) &lt; EPSILON) &#123; return Intersection&#123;&#125;; &#125; float coefficient = 1.0f / denominator; float t = coefficient * dotProduct(s2, e2); float b1 = coefficient * dotProduct(s1, s); float b2 = coefficient * dotProduct(s2, ray.direction); float b0 = 1.0f - b1 - b2; if (t &gt;= 0.0f &amp;&amp; b0 &gt;= 0.0f &amp;&amp; b0 &lt;= 1.0f &amp;&amp; b1 &gt;= 0.0f &amp;&amp; b1 &lt;= 1.0f &amp;&amp; b2 &gt;= 0.0f &amp;&amp; b2 &lt;= 1.0f ) &#123; Intersection inter; inter.distance = t; inter.normal = normal; inter.coords = ray(t); inter.happened = true; inter.m = m; inter.obj = this; return inter; &#125; else return Intersection&#123;&#125;;&#125; Path Tracing 渲染方程 Render Equation: Lo(p,ω0) = Le(p,ω0) + ∫Ω+Li(p,ωi)fr(p,wi,w0)(n⋅ωi)dwi\\Large _{Lo\\left( p,\\omega _0 \\right) \\ =\\ L_e\\left( p,\\omega _0 \\right) \\ +\\ \\int\\limits_{\\varOmega +}^{}{L_i\\left( p,\\omega _i \\right) f_r\\left( p,w_i,w_0 \\right) \\left( n\\cdot \\omega _i \\right) dw_i}} Lo(p,ω0​) = Le​(p,ω0​) + Ω+∫​Li​(p,ωi​)fr​(p,wi​,w0​)(n⋅ωi​)dwi​​ 其中第一项表示物体本身的发出的光照强度，第二项的积分所包括的内容就是反射函数 Reflection Equation,即 Lo(p,ω0) = ∫Ω+Li(p,ωi)fr(p,wi,w0)cos⁡θidwi\\Large_{Lo\\left( p,\\omega _0 \\right) \\,\\,=\\,\\,\\int\\limits_{\\varOmega +}^{}{L_i\\left( p,\\omega _i \\right) f_r\\left( p,w_i,w_0 \\right) \\cos \\theta _idw_i}} Lo(p,ω0​)=Ω+∫​Li​(p,ωi​)fr​(p,wi​,w0​)cosθi​dwi​​ Lo(p,ω0) =∫ALi(p,ωi)fr(p,wi,w0)cos⁡θicos⁡θi′∥x′−x∥2dA(从光源处采样)\\Large _{Lo\\left( p,\\omega _0 \\right) \\,\\, =\\int\\limits_A^{}{L_i\\left( p,\\omega _i \\right) f_r\\left( p,w_i,w_0 \\right) \\frac{\\cos \\theta _i\\cos \\theta _{i}^{\\prime}}{\\lVert x^{\\prime}-x \\rVert ^2}dA\\left( \\text{从光源处采样} \\right)}} Lo(p,ω0​)=A∫​Li​(p,ωi​)fr​(p,wi​,w0​)∥x′−x∥2cosθi​cosθi′​​dA(从光源处采样)​ 其中第一项是入射方向的Radiance，代表从单位立体角入射到单位面积上的光照强度。第二项就是双向反射分布函数BRDF(Bidirectional Reflectance Distribution Function) (只与材质有关 BRDF=MaterialBRDF = MaterialBRDF=Material ) ，他表示以下比值： fr(ωi→ωr)=dLr(ωr)dEi(ωi)=dLr(ωr)Li(ωi)cos⁡θidωi[1sr]f_r\\left( \\omega _i\\rightarrow \\omega _r \\right) =\\frac{dL_r\\left( \\omega _r \\right)}{dE_i\\left( \\omega _i \\right)}=\\frac{dL_r\\left( \\omega _r \\right)}{L_i\\left( \\omega _i \\right) \\cos \\theta _id\\omega _i}\\left[ \\frac{1}{sr} \\right] fr​(ωi​→ωr​)=dEi​(ωi​)dLr​(ωr​)​=Li​(ωi​)cosθi​dωi​dLr​(ωr​)​[sr1​] 蒙特卡洛积分 Monte Carlo Intergration: ∫f(x)dx=∫f(x)p(x)p(x)dx=E(f(x))p(x)=1N∑i=1Nf(xi)p(xi)(大数定律) \\begin{aligned} \\int{f\\left( x \\right) dx=\\int{\\frac{f\\left( x \\right)}{p\\left( x \\right)}p\\left( x \\right) dx}} =\\frac{E\\left( f\\left( x \\right) \\right)}{p\\left( x \\right)} =\\frac{1}{N}\\sum_{i=1}^N{\\frac{f\\left( x_i \\right)}{p\\left( x_i \\right)}\\left( \\text{大数定律} \\right)}\\text{ } \\end{aligned} ∫f(x)dx=∫p(x)f(x)​p(x)dx=p(x)E(f(x))​=N1​i=1∑N​p(xi​)f(xi​)​(大数定律) ​ 采样越多，方差越小 在这里的路径追踪中，我们根据渲染方程着色、利用蒙特卡洛估计离散化、 俄罗斯轮盘赌控制深度、 重复单次采样来降低方差和减少计算量、 从光源处采样来提高效率。 简要地说，就是根据光路可逆原理，从视线(viewpoint)发出一条光线到物体，再①从光源处采样，再追踪这个方向到物体的光线，如果没有遮挡就计算直接光照；②根据材质生成一条任意的wi，有物体相交就是间接光照，递归计算即可，无相交物体或到达光源时停止。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// in Scene.cppVector3f Scene::castRay(const Ray&amp; ray, int depth) const&#123; // TO DO Implement Path Tracing Algorithm here //从视线发出光线 Intersection inter = intersect(ray); //没有相交则不需要着色 if(!inter.happened) &#123; return Vector3f&#123; 0.0f, 0.0f, 0.0f &#125;; &#125; //直接返回光源 if (inter.m-&gt;hasEmission()) &#123; if (depth == 0) &#123; return inter.m-&gt;getEmission(); &#125; else return Vector3f&#123; 0.0f, 0.0f, 0.0f &#125;; &#125; Vector3f view_dir = ray.direction; Vector3f normal = inter.normal.normalized(); Vector3f position = inter.coords; //直接光照和间接光照 Vector3f L_dir = &#123; 0.0f,0.0f,0.0f &#125;, L_indir = &#123;0.0f, 0.0f, 0.0f&#125;; //1. 直接光照 Intersection inter_light; float pdf_light; //从光源处采样 sampleLight(inter_light, pdf_light); Vector3f normal_light = normalize(inter_light.normal);// NN Vector3f position_light = inter_light.coords;// x Vector3f light_dir = (position - position_light).normalized();// ws float distanceToLight = (position-position_light).norm(); float distanceToLight2 = dotProduct(position - position_light, position - position_light);// |x - x&#x27;|^2 Ray lightToObj(position_light, light_dir);// Ray(ori,dir) Intersection inter_lightToObj = intersect(lightToObj); float distanceToObj = inter_lightToObj.distance; //利用深度判断是否相交 //不能用Intersection.happened, 因为一定会和物体相交 if(inter_lightToObj.happened &amp;&amp; distanceToObj - distanceToLight &gt; -EPSILON) &#123; Vector3f f_r = inter.m-&gt;eval(view_dir, -light_dir, normal); float cos_theta = dotProduct(-light_dir, normal);// 物体夹角 float cos_theta_l = dotProduct(light_dir, normal_light); //光源夹角 L_dir = inter_light.emit*f_r * cos_theta * cos_theta_l / (pdf_light * distanceToLight2); &#125; //2. 间接光照 float ksi = get_random_float(); if(ksi &lt; RussianRoulette) &#123; //根据材质随机采样一个wi方向 Vector3f obj_dir = inter.m-&gt;sample(view_dir, normal); Ray ObjToScene(position, obj_dir); Intersection inter_ObjToScene = intersect(ObjToScene); if (inter_ObjToScene.happened &amp;&amp; !inter_ObjToScene.m-&gt;hasEmission()) &#123; Vector3f f_r = inter.m-&gt;eval(view_dir, obj_dir, normal); float cos_theta = dotProduct(obj_dir, normal); float pdf_hemi = inter.m-&gt;pdf(view_dir, obj_dir, normal); if (pdf_hemi &gt; EPSILON) &#123;//减少白色噪点 L_indir = f_r * castRay(ObjToScene, depth + 1) * cos_theta / (pdf_hemi * RussianRoulette); &#125; &#125; &#125; return L_dir + L_indir;&#125; 多线程 在这里运用C++11中的thread可以轻松地分像素进行并行渲染。 12345678910111213141516171819202122232425262728293031323334353637383940// change the spp value to change sample ammountint spp = 256; // default:16std::cout &lt;&lt; &quot;SPP: &quot; &lt;&lt; spp &lt;&lt; &quot;\\n&quot;;const int thread_cnt = 8;int finished_thread = 0;int finished_width = 0;std::mutex mtx;printf(&quot;%d %d\\n&quot;, scene.height, scene.width);auto multiThreadCastRay = [&amp;](uint32_t y_min, uint32_t y_max)&#123; printf(&quot;start %d %d\\n&quot;, y_min, y_max); for (uint32_t j = y_min; j &lt;= y_max; ++j) &#123; for (uint32_t i = 0; i &lt; scene.width; ++i) &#123; // generate primary ray direction float x = (2 * (i + 0.5) / (float)scene.width - 1) * imageAspectRatio * scale; float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale; Vector3f dir = normalize(Vector3f(-x, y, 1)); for (int k = 0; k &lt; spp; k++) &#123; framebuffer[scene.width * j + i] += scene.castRay(Ray(eye_pos, dir), 0) / spp; &#125; &#125; //printf(&quot;%d\\n&quot;, j); //UpdateProgress(j / (float)scene.height); mtx.lock(); UpdateProgress(++finished_width * 1.0 / scene.width); mtx.unlock(); &#125; printf(&quot;ok %d %d\\n&quot;, y_min, y_max);&#125;;int block = scene.height / thread_cnt + (scene.height % thread_cnt != 0);std::thread th[thread_cnt];for (int i = 0; i &lt; thread_cnt; i++) &#123; th[i] = std::thread(multiThreadCastRay, i * block, std::min((i + 1) * block - 1, scene.height));&#125;for (int i = 0; i &lt; thread_cnt; i++) th[i].join();UpdateProgress(1.0); 加速及优化 将Debug更换为Release Debug 是调试版本，包含调试信息，不优化代码，便于程序员调试； Release 是发布版本，不包含调试信息，对代码进行优化，便于用户使用。 在图形学中，常常需要进行大量的计算和像素的处理。更换为Release可以大幅提高编译效率，进行更加顺利的测试。 get_random_float() in global.hpp global.hpp下的get_random_float()随机数生成函数存在问题，它会导致在重复调用该函数时，返回同一个值。 123456789// in global.hppstatic std::random_device dev;static std::mt19937 rng(dev());static std::uniform_real_distribution&lt;float&gt; dist(0.f, 1.f); // distribution in range [1, 6]inline float get_random_float()&#123; return dist(rng);&#125; 白色噪点 原因应该是pdf接近于0时，除以它计算得到的颜色会偏向极限值，体现在图上也就是白色 要解决这个问题，对于pdf接近于0的情况直接将它的radience算作0就行： Microfacet微平面理论 这部分内容可以参考LearnOpenGL BRDF = Material fr=kdflambert+ksfcook−torrance\\large f_r=k_df_{lambert}+k_sf_{cook-torrance} fr​=kd​flambert​+ks​fcook−torrance​ 其中： kdkdkd是入射光线中被折射部分的能量占比，ksksks是被反射部分的能量占比，即菲涅尔项。根据能量守恒定律，kd+ks=1kd+ks=1kd+ks=1. flambertf_{lambert}flambert​是Lambertian漫反射（理想散射-郎伯散射）BRDF部分，fcook−torrancef_{cook-torrance}fcook−torrance​是镜面部分BRDF部分。 Lambertian漫反射 假设物体不吸收能量，由能量守恒得到irradiance入射和出射一定是一样的（Li=LoL_{i}=L_{o}Li​=Lo​）,因此得到fr=1πf_r=\\frac{1}{\\pi}fr​=π1​;考虑到物体吸收能量的损失后，有： flambert=ρπ\\large f_{lambert}=\\frac{\\rho}{\\pi} flambert​=πρ​ 其中ρ{\\rho}ρ为反射率或rgb光谱 Cook-Torrance BRDF f(l,v)=D(h)F(v,h)G(l,v,h)4(n⋅l)(n⋅v)\\large f\\left( l,v \\right) =\\frac{D\\left( h \\right) F\\left( v,h \\right) G\\left( l,v,h \\right)}{4\\left( n\\cdot l \\right) \\left( n\\cdot v \\right)} f(l,v)=4(n⋅l)(n⋅v)D(h)F(v,h)G(l,v,h)​ 其中: 光照方向L,观察方向V, 微观法线/中间向量H,宏观向量N D(h):法线分布函数(Normal Distribution Function),描述微面元法线分布的概率，即正确朝向的法线的浓度。即具有正确朝向，能够将来自l的光反射到v的表面点的相对于表面面积的浓度。 F(v,h):菲涅尔方程(Fresnel Equation),描述不同的表面角下表面所发射的光线所占的比率。 G(l,v,h):几何函数(Geometry Function),描述微平面自成阴影的属性，即m=h的未被遮蔽的表面点的百分比。 4(n*l)(n*v):校正因子(Correctionfactor),作为微观几何的局部空间和整个宏观表面的局部空间之间变换的微平面量的校正。 一般我们用宏观表面的半矢量h来表示微观表面法线m，因为仅m = h的表面点的朝向才会将光线l反射到视线v的方向，其他朝向的表面点对BRDF没有贡献（正负相互抵消）。 微表面模型需要用到的参数： VVV:光线的反射方向(单位向量) III:光线的入射方向的反方向(单位向量) m=hm=hm=h:VVV和III的中间向量(单位向量) NNN:为宏观平面法线(单位向量) α{\\alpha}α:为粗糙度∈[0,1] D(h):法线分布函数(Normal Distribution Function) 各项同性NDF GGX(Trowbridge-Reitz)分布 GGXT发光的尾部较长，且具备形状不变性。 α=Roughness2\\alpha =Roughness^2 α=Roughness2 DGGX(m)=α2π((n⋅m)2(α2−1)+1)2D_{GGX}\\left( \\mathbf{m} \\right) =\\frac{\\alpha ^2}{\\pi \\left( \\left( \\mathbf{n}\\cdot \\mathbf{m} \\right) ^2\\left( \\alpha ^2-1 \\right) +1 \\right) ^2} DGGX​(m)=π((n⋅m)2(α2−1)+1)2α2​ 123456789101112Vector3f D_GGXT(Vector3f N,Vector3f H,float rough)&#123; float a = rough * rough; float a2 = a * a; float NdotH = std::max(dotProduct(N, H), 0.0f); float NdotH2 = NdotH * NdotH; float denom = (NdotH2 * (a2 - 1.0f) + 1.0f); denom = denom * denom; return a2 * MY_INV_PI * std::max(denom,0.0000001f);&#125; 各项异性NDF 创建各向异性NDF的常用方法是基于现有各向同性NDF进行推导。而推导所使用的方法是通用的，可以应用于任何形状不变的各向同性NDF，这便是GGX等形状不变的NDF能更加普及的另一个原因。 Anisotropic GGX分布 DGGXaniso(m)=1παxαy1((t⋅m)αx2+(b⋅m)αy2+(n⋅m)2)2D_{GGXaniso}\\left( \\mathbf{m} \\right) =\\frac{1}{\\pi \\alpha _x\\alpha _y}\\frac{1}{\\left( \\frac{\\left( \\mathbf{t}\\cdot \\mathbf{m} \\right)}{\\alpha _{x}^{2}}+\\frac{\\left( \\mathbf{b}\\cdot \\mathbf{m} \\right)}{\\alpha _{y}^{2}}+\\left( \\mathbf{n}\\cdot \\mathbf{m} \\right) ^2 \\right) ^2} DGGXaniso​(m)=παx​αy​1​(αx2​(t⋅m)​+αy2​(b⋅m)​+(n⋅m)2)21​ 需要注意的是，将法线贴图与各向异性BRDF组合时，重要的是要确保法线贴图扰动（perturbs）切线和副切线矢量以及法线。 F(v,h):菲涅尔方程(Fresnel Equation) vvv是出射向量，h是中间向量 Schlick Fresnel近似 FSchlick(v,h)=F0+(1−F0)(1−(v⋅h))5F_{Schlick}\\left( \\mathbf{v,h} \\right) =F_0+\\left( 1-F_0 \\right) \\left( 1-\\left( v\\cdot h \\right) \\right) ^5 FSchlick​(v,h)=F0​+(1−F0​)(1−(v⋅h))5 12345float F_Schlick(Vector3f V, Vector3f H,Vector3f F0)&#123; float cos_theta = std::max(dotProduct(V, H), 0.0f); return F0 + (1.0f - F0) * std::pow((1 - cos_theta), 5);&#125; G(l,v,h):几何函数(Geometry Function) 通常，除了近掠射角或非常粗糙的表面，几何函数对BRDF的形状影响相对较小，但对于BRDF保持能量守恒而言，几何函数至关重要。 在部分游戏引擎和文献中，几何函数G(l,v,h)和分母中的校正因子4（n·l）（n·v）会合并为可见性项（The Visibility Term），Vis项，简称V项。其也经常作为几何函数的代指： 几何函数与法线分布函数作为Microfacet Specular BRDF中的重要两项，两者之间具有紧密的联系 V(v,l)=G(l,v,h)4(n⋅l)(n⋅v)\\large V\\left( \\mathbf{v,l} \\right) =\\frac{G\\left( \\mathbf{l,v,h} \\right)}{4\\left( \\mathbf{n}\\cdot \\mathbf{l} \\right) \\left( \\mathbf{n}\\cdot \\mathbf{v} \\right)} V(v,l)=4(n⋅l)(n⋅v)G(l,v,h)​ 几何函数具有两种主要形式：G1和G2，其中： G1为微平面在单个方向（光照方向L或观察方向V）上可见比例，一般代表遮蔽函数（masking function）或阴影函数（shadowing function） G2为微平面在光照方向L和观察方向V两个方向上可见比例，一般代表联合遮蔽阴影函数（joint masking-shadowing function） 在实践中，G2由G1推导而来 默认情况下，microfacet BRDF中使用的几何函数代指G2 G2(l,v)4∣n⋅l∣∣n⋅v∣≈0.5lerp(2∣n⋅l∣∣n⋅v∣,∣n⋅l∣+∣n⋅v∣,α)\\frac{G_2\\left( \\mathbf{l,v} \\right)}{4\\left| \\mathbf{n}\\cdot \\left. \\mathbf{l} \\right|\\left| \\left. \\mathbf{n}\\cdot \\mathbf{v} \\right| \\right. \\right.}\\approx \\frac{0.5}{lerp\\left( 2\\left| \\left. \\mathbf{n}\\cdot \\mathbf{l} \\right|\\left| \\right. \\left. \\mathbf{n}\\cdot \\mathbf{v} \\right|,\\left| \\left. \\mathbf{n}\\cdot \\mathbf{l} \\right|+\\left| \\left. \\mathbf{n}\\cdot \\mathbf{v} \\right|,\\alpha \\right. \\right. \\right. \\right)} 4∣n⋅l∣∣n⋅v∣G2​(l,v)​≈lerp(2∣n⋅l∣∣n⋅v∣,∣n⋅l∣+∣n⋅v∣,α)0.5​ 123456789101112//G_SchlicksmithGGX_Visibilityfloat Visibility(Vector3f V,Vector3f L,Vector3f N, float rough)&#123; float NdotV = std::max(dotProduct(N, V), 0.0f); float NdotL = std::max(dotProduct(N, L), 0.0f); float f = rough + 1.0; float k = f * f * 0.125; float ggxV = 1.0 / (NdotV * (1.0 - k) + k); float ggxL = 1.0 / (NdotL * (1.0 - k) + k); return ggxV * ggxL * 0.25;&#125; 计算误差导致的交点偏离问题 在Intersection getIntersection(Ray ray)函数中修改圆的相交判定，因为圆的相交判定精度不够。 若不修改，程序在运行中会报错，因为当 t0 = 0 时，有可能会造成除0错误。 1234567891011121314151617181920212223// in sphere.hppIntersection getIntersection(Ray ray) &#123; Intersection result; result.happened = false; Vector3f L = ray.origin - center; float a = dotProduct(ray.direction, ray.direction); float b = 2 * dotProduct(ray.direction, L); float c = dotProduct(L, L) - radius2; float t0, t1; if (!solveQuadratic(a, b, c, t0, t1)) return result; if (t0 &lt; 0) t0 = t1; if (t0 &lt; 0) return result; if (t0 &gt; 0.5) &#123;//精度不够 result.happened = true; result.coords = Vector3f(ray.origin + ray.direction * t0); result.normal = normalize(Vector3f(result.coords - center)); result.m = this-&gt;m; result.obj = this; result.distance = t0; &#125; return result;&#125; 总结： 这个作业还是非常有趣的，让我步入了PBR的大门。但是还有完美镜面反射没有完成，看起来和菲涅尔项、重要性采样有关系，以及伽马校正等视觉效果可以实现，这个以后再说吧。 参考资料： GAMES101作业7-路径追踪实现过程&amp;代码框架超全解读 图形学入门笔记3:Path Tracing-Games101作业7 Games101 作业7 绕坑引路 (Windows) 【GAMES101】作业7 常见问题避坑","categories":[{"name":"CG","slug":"CG","permalink":"http://example.com/categories/CG/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"渲染","slug":"渲染","permalink":"http://example.com/tags/%E6%B8%B2%E6%9F%93/"}],"author":"tugumineko"},{"title":"图片的格式与种类","slug":"picture-format","date":"2024-06-30T04:40:40.000Z","updated":"2024-06-30T08:17:04.136Z","comments":true,"path":"2024/06/30/picture-format/","permalink":"http://example.com/2024/06/30/picture-format/","excerpt":"","text":"种类 像素图 也叫位图，是用像素点阵列拼合的图像。 通过捕捉得到的图像（如拍摄、截图）都是像素图。 像素图在放大一定程度后都会出现模糊。 常见的像素图格式包括：JPEG、PSD、PNG、TIFF 矢量图 是使用点线面构成的图像。 矢量图往往是使用矢量软件绘制得到的。 点线面都是数学化的，因此放大后不会模糊。 常见的矢量图格式包括：AI、EPS、SVG 格式 JPEG(JPG) Joint Photographic Experts Group 用途：相机拍摄照片、网络图片等。经常被用作图片处理的最终输出格式。 优势：用途广泛，受到几乎所有平台和系统的支持。支持应用不同级别的压缩。压缩后的文件尺寸较小，适合携带和发送。 劣势：有损压缩（24位输入RGB）。不支持图层。不支持透明度。 JPEG可以在色调及颜色平滑变化的照片或是写实绘画(painting)上达到它的最佳效果。 在这种情况下，它通常比完全无损方法做得更好，仍然可以产生非常好看的影像 （事实上它会比其他一般的方法像是GIF产生更高的影像，因为GIF对于线条绘画(drawing)和图标的图形是无损，但针对全彩影像则需要极困难的量化） 根据数据率失真理论(Rate distortion theory),中等质量的照片只有1/6的存储空间，但是几乎没有明显的细节损失或是看得到的人为效果。 PNG Portable Network Graphics PNG is Not GIF 用途：在网络上最常用，对显示器有优化（相对于印刷来说）。 优势：支持比GIF更多的颜色。无损压缩。支持透明度 劣势：尺寸比JPEG更大。 存储类型： PNG 8：256种颜色，黑白，节省空间。 PNG 24：RGB PNG 32：RGBA Alpha通道(α/Alpha Channel)是指一张图片的透明和半透明度。 一个使用32个比特存储的位图，红绿蓝及Alpha通道各以8个比特表示。在这种情况下，就不光可以表示透明还是不透明，Alpha通道还可以表示256级的半透明度。 如果保存文本，线条或类似的边缘清晰，有大块相同颜色区域的图像，PNG格式的压缩效果就要比JPEG好很多，并且不会出现JPEG那样的高对比度区域的图像失真。 由于JPEG是有损压缩，会产生迭代失真，在重复压缩和解码的过程中会不断丢失信息使图像质量下降。 由于PNG是无损的，保存将要编辑的图像来说更合适。 补充特性说明： 支持256色调色板技术以产生小体积文件。 最高支持24位真彩色（普遍认为人眼对色彩的分辨能力大致是一千万色，因此有RGB生成的图像均称为真彩色）图像以及8位灰度图像。 支持Alpha通道的透明/半透明特性。 支持图像亮度的Gamma校准信息。 支持存储附加文本信息，以保留图像名称、作者、著作权、创作时间、注释等信息。 支持无损压缩。 渐近显示和流式读写，适合在网络传输中快速显示预览效果后再展示全貌。 使用CRC(循环冗余校验)防止文件出错。 最新的PNG标准允许在一个文件内存储多幅图像。 GIF Graphics Interchange Format 用途：网络图片，尤其是动图。 优势：加载迅速，支持动画，无损压缩，尺寸较小，支持透明度。 劣势：最大仅支持256色，不支持CMYK 它实际上是一种压缩文档，采用LZW压缩算法进行编码(字典HASH)。有效地减少了图像文件在网络传输的时间。 EPS Encapsulated PostScript 用途：用于保存矢量图，如插画、Logo和图标。 优势：支持任何尺寸的图像。有大量软件支持查看。可以轻松地被转换为像素图。 劣势：用于编辑的软件有限，打印机支持性交叉。有些EPS文件内部是像素图，只是被伪装成了矢量图。 EPS是矢量图通用文件，大多数矢量编辑软件都支持EPS。EPS格式文件也可以包含像素图。 SVG Scalable Vector Graphics 用途：用于网络矢量图，以及导入3D软件。 优势：支持矢量内容，也支持文本和像素图，可以添加动画（通过外部代码交互）。放大缩小不会模糊。尺寸较小。可直接作为代码放在HTML里。可以被搜索引擎检索。 劣势：支持的颜色深度有限。不适合用作印刷。 SVG基于XML格式，适合将矢量图用于网络发布。同时，SVG也非常适合用于导出2D路径到3D软件中。 PDF Portable Document Format 用途：存储文档，用于打印。 优势：可以同时存储像素图、矢量图和文本。很多软件可以输出PDF，支持多页。 劣势：限制用于Windows和Mac OS，很难编辑。 PDF格式是封装文档用于印刷的通用标准之一。 BMP BMP取自位图Bitmap的缩写，也称为DIB（与设备无关的位图） 用途：，是一种独立于显示器的位图数字图像文件格式。常见于微软视窗和OS/2操作系统. 优势：无压缩，大多数系统都支持。 劣势：相对来说文件尺寸大，不支持CMYK。","categories":[],"tags":[{"name":"数字图像处理","slug":"数字图像处理","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"author":"tugumineko"},{"title":"STL语法","slug":"STL","date":"2024-06-10T14:37:44.000Z","updated":"2024-06-10T15:03:51.642Z","comments":true,"path":"2024/06/10/STL/","permalink":"http://example.com/2024/06/10/STL/","excerpt":"","text":"vector 可以用下标[]直接访问 初始化大小后为非动态数组 12vector&lt;int&gt; v(n, 1);// v[0] 到 v[n - 1]所有的元素初始值均为1 //注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了） 方法函数 方法 时间复杂度 v.front() O(1） v.back() O(1) v.pop_back() O(1) v.push_back(ele) O(1) v.size() O(1) v.empty() O(1) v.clear() O(N) 排序：sort(v.begin(),v.end()) stack 方法函数 方法 时间复杂度 s.top() O(1） s.pop() O(1) s.push(ele) O(1) s.empty() O(1) s.size() O(1) 栈遍历 123456stack&lt;int&gt; st;for (int i = 0; i &lt; 10; ++i) st.push(i);while (!st.empty()) &#123; int tp = st.top(); // 栈顶元素 st.pop();&#125; queue 方法函数 方法 时间复杂度 q.front() O(1） q.back() O(1) q.pop() O(1) q.push(ele) O(1) v.size() O(1) v.empty() O(1) deque 没用 priority_queue 没有empty() 方法函数 方法 时间复杂度 pq.top() O(1） pq.push(ele) O(logN) pq.pop() O(logN) v.size() O(1) v.empty() O(1) 12priority_queue&lt;int&gt; pq; //默认大根堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq; //小根堆 自定义排序将greater&lt;int&gt;换成cmp即可 对pair类型先对first排序，再对second排序","categories":[{"name":"cpp","slug":"cpp","permalink":"http://example.com/categories/cpp/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"}],"author":"tugumineko"},{"title":"状态压缩dp","slug":"状态压缩dp","date":"2024-06-05T14:31:09.000Z","updated":"2024-06-05T14:37:01.758Z","comments":true,"path":"2024/06/05/状态压缩dp/","permalink":"http://example.com/2024/06/05/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/","excerpt":"","text":"以下为gpt4o的解答： 灌溉机器人 好的，我来帮你解析一下这段代码中的四重循环。 这段代码的目的是在网格中放置大炮，要求大炮不能放置在两个相邻的格子里（包括对角线相邻）。代码使用了压缩状态动态规划（DP）的方法来解决这个问题。 核心部分解析 数据结构和前置处理 mp[105]: 用来存储每一行格子的状态，若某格子为障碍（‘H’），则对应位置为1。 state[105]: 用来存储所有合法的状态（即相邻位置没有放置大炮的状态）。 sum[105]: 每个状态下大炮的数量。 dp[105][65][65]: 动态规划数组，dp[r][j][i]表示第r行状态为state[i]且第(r-1)行状态为state[j]时的最大大炮数量。 函数功能 ok(int x): 检查状态x是否合法，即相邻位置没有放置大炮。 getsum(int x): 计算状态x中大炮的数量。 findstate(int n): 预处理，求出所有合法的状态。 主逻辑 12345678910111213141516171819202122232425262728293031323334void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; char ch; cin &gt;&gt; ch; if (ch == &#x27;H&#x27;) mp[i] |= (1 &lt;&lt; (j - 1)); &#125; &#125; findstate(m); for (int i = 1; i &lt;= cnt; i++) &#123; if (!(state[i] &amp; mp[1])) dp[1][1][i] = sum[i]; &#125; for (int r = 2; r &lt;= n; r++) &#123; for (int i = 1; i &lt;= cnt; i++) &#123; // 枚举第r行的状态 if (state[i] &amp; mp[r]) continue; // 如果第r行状态与障碍冲突，跳过 for (int j = 1; j &lt;= cnt; j++) &#123; // 枚举第(r-1)行状态 if (state[i] &amp; state[j]) continue; // 如果第r行和第(r-1)行状态冲突，跳过 for (int k = 1; k &lt;= cnt; k++) &#123; // 枚举第(r-2)行状态 if (state[i] &amp; state[k]) continue; // 如果第r行和第(r-2)行状态冲突，跳过 dp[r][j][i] = max(dp[r][j][i], dp[r-1][k][j] + sum[i]); &#125; &#125; &#125; &#125; int ans = 0; for (int i = 1; i &lt;= cnt; i++) &#123; for (int j = 1; j &lt;= cnt; j++) &#123; ans = max(ans, dp[n][i][j]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125; 四重循环解析 第一重循环 (for (int r = 2; r &lt;= n; r++)): 遍历每一行，从第二行开始，因为第一行已经初始化过。 第二重循环 (for (int i = 1; i &lt;= cnt; i++)): 遍历所有可能的状态state[i]，作为第r行的状态。 第三重循环 (for (int j = 1; j &lt;= cnt; j++)): 遍历所有可能的状态state[j]，作为第r-1行的状态。 第四重循环 (for (int k = 1; k &lt;= cnt; k++)): 遍历所有可能的状态state[k]，作为第r-2行的状态。 检查state[i]和state[k]是否冲突，如果不冲突，更新dp[r][j][i]。 注意事项 每行状态与当前行的障碍状态mp[r]进行匹配，确保不放置在障碍位置。 确保每行状态与前两行状态不冲突，即不在相邻的行中有相邻的放置。 dp[r][j][i] = max(dp[r][j][i], dp[r-1][k][j] + sum[i]); 这行代码是动态规划的核心转移方程，用于更新当前状态的最大大炮数量。具体来说，这个转移方程的意义如下： dp部分 解释 dp[r][j][i]：表示第 r 行的状态为 state[i]，第 r-1 行的状态为 state[j] 时，放置大炮的最大数量。 dp[r-1][k][j]：表示第 r-1 行的状态为 state[j]，第 r-2 行的状态为 state[k] 时，放置大炮的最大数量。 sum[i]：表示状态 state[i] 中大炮的数量。 工作原理 这个转移方程的作用是确保在更新当前行状态的最大大炮数量时，考虑所有可能的前两行状态，并选择最大值。 更具体的解释： 当前行状态 state[i] 的选择： 考虑第 r 行的状态 state[i]，并检查它是否与当前行的障碍位置 (mp[r]) 冲突。 前一行状态 state[j] 的选择： 考虑第 r-1 行的状态 state[j]，并检查它是否与当前行状态 state[i] 冲突。 再前一行状态 state[k] 的选择： 考虑第 r-2 行的状态 state[k]，并检查它是否与当前行状态 state[i] 冲突。 更新 dp[r][j][i]： 如果 state[i]、state[j] 和 state[k] 互不冲突，那么 dp[r][j][i] 就等于前一状态 dp[r-1][k][j] 加上当前行状态的炮数 sum[i]。 用 max 函数来确保选择的是最大值。 例子 假设有以下参数： state[i] 表示的第 r 行状态放置了3个大炮。 dp[r-1][k][j] 表示的第 r-1 行和第 r-2 行状态组合能够放置的最大大炮数为5。 那么，对于当前的组合，如果它们没有冲突，dp[r][j][i] 将更新为 5 + 3 = 8。 总的来说，这个动态规划转移方程的目的就是在不违反大炮放置规则的前提下，遍历所有可能的状态组合，找到当前行及其前两行的放置方案中能够放置大炮的最大数量。 小明的积木 这段代码实现了一个使用状态压缩动态规划（DP）的算法，通常用于解决组合优化问题。具体来说，这里的代码解决了一个变种的背包问题。我们将逐步解析代码中涉及的位运算部分。 数据结构和变量 12345const int N = 20;int s[N]; // 存储每个物品的某个属性值（例如，价值或其他属性）int w[N]; // 存储每个物品的重量int dp[1&lt;&lt;N]; // 动态规划数组，大小为 2^N 输入和初始化 123456void solve() &#123; int W, n; cin &gt;&gt; W &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; s[i] &gt;&gt; w[i]; &#125; W 是背包的容量。 n 是物品的数量。 s[i] 是第 i 个物品的属性值。 w[i] 是第 i 个物品的重量。 状态压缩和位运算 状态压缩的核心在于使用一个整数的二进制表示来表示一个子集。例如，对于 n 个物品，使用一个 n 位的二进制数 i 来表示物品的选择状态： i 的第 j 位为 1 表示选择了第 j 个物品。 i 的第 j 位为 0 表示没有选择第 j 个物品。 123456789for (int i = 0; i &lt; (1 &lt;&lt; n); i++) &#123; int ss = 0; int ww = 0; for (int j = 1; j &lt;= n; j++) &#123; if (i &amp; (1 &lt;&lt; (j - 1))) &#123; ww += w[j]; ss = max(s[j], ss); &#125; &#125; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) 枚举所有可能的物品子集，共有 2^n 个子集。 if (i &amp; (1 &lt;&lt; (j - 1))) 检查子集 i 是否包含物品 j。(1 &lt;&lt; (j - 1)) 生成一个只有第 j-1 位为 1 的数，i &amp; (1 &lt;&lt; (j - 1)) 检查 i 的第 j-1 位是否为 1。 动态规划转移方程 123456789 if (ww &lt;= W) &#123; dp[i] = ss; &#125; else &#123; dp[i] = 0x3f3f3f3f; for (int j = i; j; j = (j - 1) &amp; i) &#123; dp[i] = min(dp[i], dp[j] + dp[j ^ i]); &#125; &#125;&#125; if (ww &lt;= W) 检查当前子集的总重量 ww 是否不超过背包容量 W，如果是，则 dp[i] 设为当前子集中最大属性值 ss。 else 表明当前子集超重，此时需要通过子集划分来计算最优解。 for (int j = i; j; j = (j - 1) &amp; i) 遍历当前子集 i 的所有子集 j。这种遍历方式利用了 (j - 1) &amp; i 的特性，能高效地生成 i 的所有子集： (j - 1) &amp; i 生成 i 的下一个子集。 dp[i] = min(dp[i], dp[j] + dp[j ^ i]) 更新 dp[i]，其中 dp[j] + dp[j ^ i] 表示将子集 i 拆分为 j 和 i-j 两个子集的总和。 输出结果 1cout &lt;&lt; dp[(1 &lt;&lt; n) - 1]; dp[(1 &lt;&lt; n) - 1] 表示所有物品都被考虑的情况下的最优解。","categories":[{"name":"cpp","slug":"cpp","permalink":"http://example.com/categories/cpp/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}],"author":"tugumineko"},{"title":"用户态内存分配器","slug":"user-malloc","date":"2024-05-28T12:36:26.000Z","updated":"2024-05-30T14:05:49.041Z","comments":true,"path":"2024/05/28/user-malloc/","permalink":"http://example.com/2024/05/28/user-malloc/","excerpt":"","text":"内存的分配和释放在堆(Heap)上完成 void * ptr = malloc (size) free(ptr) Stack分配是连续的，因为不需要管理。 Heap是按照size大小分配的，不是连续的。 1234567int* a1 = malloc (1000 *sizeof(int));int* a2 = malloc (100 *sizeof(int));int b[1000];int b2[100];*(int *)((uint64_t)&amp;b2 - sizeof(int)) = b1[999];//true malloc 分配完要记得释放，防止内存泄露 具体实现： malloc : 选择可以放进去的块标记为allocated，返回低地址 free ：将allocted标记去除，并连接未分配的其他空间，释放相邻的byte效率更高 8Byte对齐最后有三位空闲0（是八的倍数），最后一位用来标记allocated，不会占用任何空间 类似地，有为了节省红黑树节点内存空间（字节对齐）的操作： 12345678910struct RBTreeNode&#123; //结构体内不使用会浪费内存字节对齐的bool color RBTreeNode* prev; RBTreeNode* left; RBTreeNode* right; int64 value;&#125;;//32bytesbool color = p-&gt;prev &amp; 0x1;RBTreeNode* pre = p-&gt;prev &amp; 0xFFFFFFFE 这里预留4B来记录size，free时allocated消去，size不变 块分配示例1： int* a = malloc (sizeof(int)); *a = 0xabcd;//(0x0000abcd) size = 8 = 0x1;//分配的实际块大小8byte，注意字节对齐 0xd 0xc 0xb 0xa 0000 0000 0000 0000 1101 1100 1011 1010 0000 0000 0000 0000 0000 0000 0000 1001 //size: 0x1 //allocated : 1 4B / 8B = 50% 块分配示例1： char* str = malloc(6); str = &quot;hello\\0&quot; size = 4B + 4B + 2B + 6B = 16B = 0x10; 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 '\\0' 'o' 'l' 'l' 'e' 'h' 0000 0000 0000 0000 0000 0000 0001 0001 这样的话，Heap借助size的偏移就形成了一个单向链表 123456789void* p = malloc(s);uint64_t header_addr = (uint64_t)p - 4;uint32_t header_value = *((uint32_t*)header_addr);//取后32位uint32_t block_size = header_value &amp; 0xFFFFFFFE;int allocated = header_value &amp; 0x1;uint64_t next_header_addr = header_addr + block_size; malloc 和 free 实现： 1234567891011121314151617181920212223242526272829303132333435363738void malloc(uint32_t size) &#123; uint64_t p = head_start_address; while (1) &#123; uint32_t p_header_value = *((uint32_t*)p); uint32_t p_block_size = header_value &amp; 0xFFFFFFFE; uint32_t p_allocated = header_value &amp; 0x1; if(p_allocated == 0 &amp;&amp; p_block_size - sizeof(uint32_t) &gt;= size) &#123; //split uint32_t request_block_size = size + sizeof(uint32_t); if(request_block_size &amp; 0x7 != 0)&#123; //data alignment request_block_size = request_block_size &amp; 0xFFFFFFF8 + 0x8; &#125; p = request_block_size | 0x1;//size &amp;&amp; allocated uint64_t q = p + request_block_size;//next_header_addr q = p_block_size - request_block_size; return(void*)(p + sizeof(uint32_t));//go to payload &#125; else &#123; //go to next_head_address p = p + p_block_size; &#125; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435void free(void* p) &#123; uint64_t payload_addr = (uint64_t)p; uint64_t header_addr = p-4; uint32_t allocated = header_addr &amp; 0x1; if(allocated == 0)&#123; printf(&quot;free twice&quot;); return; &#125; uint32_t block_size = header_addr &amp; 0xFFFFFFFE; uint64_t q = header_addr + block_size; uint32_t q_allocated = get_allocation(q); uint32_t q_block_size = get_block_size(q); if(q_allocated == 1)&#123; set_free(q); return; &#125; else&#123; //merge q &amp;&amp; p block_size = block_size + q_block_size; header_addr = block_size | 0x0; p = header_addr + sizeof(uint32_t); &#125; &#125; 这只是一个单向链表，在free时无法和前面合并，利用空间不完全。 为了解决这个问题：要在block加一个footer的结构，和header一样，包含了size和allocated 隐式空闲链表 implicit free list 基于地址实现的implicit list实现如下（不完全实现）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390//// Created by 29400 on 2024/5/29.//#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;void heap_init();uint64_t mem_alloc(uint32_t size);void mem_free(uint64_t vaddr);void syscall_brk(uint64_t) &#123;&#125;uint64_t heap_start_vaddr;uint64_t heap_end_vaddr;#define HEAP_MAX_SIZE (4096 * 8)uint8_t heap[HEAP_MAX_SIZE];typedef struct &#123;&#125;block_t;/** Round up to the next mutiple of n. * if (x== k * n) * return x. * else, x = k * n + m and m &lt; n * return x = (k + 1) * n. */static uint64_t round_up(uint64_t x, uint64_t n) &#123; return n * ((x + n - 1) / n);&#125;// applicantable for both header &amp;&amp; footerstatic uint32_t get_blocksize(uint64_t vaddr) &#123; if(vaddr==0) &#123; // NULL can be considered as size 0 return 0; &#125; assert(heap_start_vaddr &lt;= vaddr &amp;&amp; vaddr &lt;= heap_end_vaddr - 4); assert((vaddr &amp; 0x3) == 0x0); // 4 bytes alignment uint32_t value = *(uint32_t*)&amp;heap[vaddr]; return value &amp; 0xFFFFFFF8;&#125;// applicantable for both header &amp;&amp; footerstatic uint32_t get_allocated(uint64_t vaddr) &#123; if(vaddr==0) &#123; // NULL can be considered as allocated return 1; &#125; assert(heap_start_vaddr &lt;= vaddr &amp;&amp; vaddr &lt;= heap_end_vaddr); assert((vaddr &amp; 0x3) == 0x0); // 4 bytes alignment uint32_t value = *(uint32_t*)&amp;heap[vaddr]; return value &amp; 0x1;&#125;static void set_blocksize(uint64_t header_vaddr, uint32_t blocksize) &#123; if(header_vaddr==0) &#123; return; &#125; assert(heap_start_vaddr &lt;= header_vaddr &amp;&amp; header_vaddr &lt;= heap_end_vaddr); assert((header_vaddr &amp; 0x3) == 0x0); // 4 bytes alignment assert((blocksize &amp; 0x7) == 0x0); // 8 bytes alignment *(uint32_t*)&amp;heap[header_vaddr] &amp;= 0x00000007; *(uint32_t*)&amp;heap[header_vaddr] |= blocksize;&#125;static void set_allocated(uint64_t header_vaddr, uint32_t allocated) &#123; if(header_vaddr==0) &#123; return; &#125; assert(heap_start_vaddr &lt;= header_vaddr &amp;&amp; header_vaddr &lt;= heap_end_vaddr); assert((header_vaddr &amp; 0x3) == 0x0); // 4 bytes alignment *(uint32_t*)&amp;heap[header_vaddr] &amp;= 0x00000007; *(uint32_t*)&amp;heap[header_vaddr] |= (allocated &amp; 0x1);&#125;/** * @param vaddr can be : * 1. starting address of the block (8 * n + 4) * 2. starting address of the payload (8 * m) */static uint64_t get_payload_addr(uint64_t vaddr) &#123; return round_up(vaddr,8);&#125;/** * @param vaddr can be : * 1. starting address of the block (8 * n + 4) * 2. starting address of the payload (8 * m) */static uint64_t get_header_addr(uint64_t vaddr) &#123; uint64_t payload_vaddr = get_payload_addr(vaddr); // NULL block does not have header return payload_vaddr == 0 ? 0 : payload_vaddr - 4;&#125;/** * @param vaddr can be : * 1. starting address of the block (8 * n + 4) * 2. starting address of the payload (8 * m) */static uint64_t get_footer_addr(uint64_t vaddr) &#123; uint64_t next_header = get_header_addr(vaddr); // last block does not have footer return next_header == 0 ? 0 : next_header - 4;&#125;static int is_lastblock(uint64_t vaddr) &#123; assert(heap_start_vaddr &lt;= vaddr &amp;&amp; vaddr &lt;= heap_end_vaddr); assert((vaddr &amp; 0x3) == 0x0); // 4 bytes alignment uint64_t header_vaddr = get_header_addr(vaddr); uint64_t block_size = get_blocksize(heap_end_vaddr); if(header_vaddr + block_size == heap_end_vaddr + 1 + 4) &#123; return 1; &#125; return 0;&#125;/** * @param vaddr can be : * 1. starting address of the block (8 * n + 4) * 2. starting address of the payload (8 * m) */static uint64_t get_nextheader (uint64_t vaddr) &#123; if(vaddr==0||is_lastblock(vaddr)) &#123; return 0; &#125; uint64_t header_vaddr = get_header_addr(vaddr); uint32_t block_size = get_blocksize(header_vaddr); uint64_t next_header_vaddr = header_vaddr + block_size; assert(0 &lt;= next_header_vaddr &amp;&amp; next_header_vaddr &lt;= heap_end_vaddr); return next_header_vaddr;&#125;/** * @param vaddr can be : * 1. starting address of the block (8 * n + 4) * 2. starting address of the payload (8 * m) */static uint64_t get_prevheader (uint64_t vaddr) &#123; if(vaddr == 0) &#123; return 0; &#125; uint64_t header_vaddr = get_header_addr(vaddr); if(header_vaddr==heap_start_vaddr) &#123; return 0; &#125; //assert(header_vaddr &gt;= 20);//.// uint32_t prev_footer_vaddr = header_vaddr - 4; uint32_t block_size = get_blocksize(prev_footer_vaddr); uint32_t prev_header_vaddr = header_vaddr - block_size; assert(0 &lt;= prev_header_vaddr &amp;&amp; prev_header_vaddr &lt;= heap_end_vaddr - 12); return prev_header_vaddr;&#125;/** rules : * 1. block[0] ==&gt; A/F. * 2. block[last] ==&gt; A/F. * 3. block[i] == A ==&gt; block[i-1] == A/F &amp;&amp; block[i+1] == A/F. * 4. block[i] == F ==&gt; block[i-1] == A &amp;&amp; block[i+1] == A. * * these 4 rules ensure that * adjancent free blocks are always merged together * henceforth external fragmentation are minimized. */int heap_check() &#123; return 0;&#125;void heap_init() &#123; // heap_start_vaddr is the starting address of the first block // the payload of the first block is 8B aligned ([8]) // so the header address of the first block is [8] - 4 = [4] heap_start_vaddr = 4; set_blocksize(heap_start_vaddr,4096 - 8); set_allocated(heap_start_vaddr,0); // the last block is without footer heap_end_vaddr = 4096 - 1;&#125;/** * @param block_vaddr the virtual address of header * @param requested_blocksize the whole size of block * @return the virtual address of allocated payload, when no enough free block for current heap, return 0 */static uint64_t try_alloc(uint64_t block_vaddr, uint32_t requested_blocksize) &#123; uint64_t b = block_vaddr; uint32_t b_blocksize = get_blocksize(b); uint32_t b_allocated = get_allocated(b); if(b_allocated == 0 &amp;&amp; b_blocksize &gt;= requested_blocksize) &#123; //allocated this block if(b_blocksize &gt; requested_blocksize) &#123; //split the block &#x27;b&#x27; set_allocated(b, 1); set_blocksize(b, requested_blocksize); //set the left splited block /** * in the extreme situation, next block size == 8 * which makes the whole next block to be : * [0x0000&#x27;0008, 0x0000&#x27;0008] */ uint64_t next_header_vaddr = b + requested_blocksize; set_allocated(next_header_vaddr, 0); set_blocksize(next_header_vaddr, b_blocksize - requested_blocksize); return get_payload_addr(b); &#125; else &#123; set_blocksize(b, requested_blocksize); set_allocated(b, 1); return get_payload_addr(b); &#125; &#125; return 0;&#125;/** * @param size requested payload size * @return the virtual address of payload */uint64_t mem_alloc(uint32_t size)&#123; assert(0 &lt; size &amp;&amp; size &lt; 4096 - 8); uint64_t payload_vaddr = 0; uint32_t requested_blocksize = round_up(size,8) + 8; uint64_t last_block = 0; uint64_t b = heap_start_vaddr; while(b &lt;= heap_end_vaddr) &#123; payload_vaddr = try_alloc(b,requested_blocksize); if(payload_vaddr != 0) &#123; return payload_vaddr; &#125; else &#123; // go to next block if(is_lastblock(b)) &#123; last_block = b; &#125; b = get_nextheader(b); &#125; &#125; // when no enough free block for current heap // request a new free physical &amp; virtual page from OS if(heap_end_vaddr + 1 + 4096 &lt;= HEAP_MAX_SIZE) &#123; // we can allocated page for the request uint64_t old_heap_end = heap_end_vaddr; // brk system call syscall_brk(heap_end_vaddr + 1); heap_end_vaddr += 4096; uint32_t last_allocated = get_allocated(last_block); uint32_t last_blocksize = get_blocksize(last_block); if(get_allocated(last_block)==1) &#123; // add footer for the last block // set_allocated(old_heap_end) set_allocated(old_heap_end, 1); set_blocksize(old_heap_end, last_blocksize); set_allocated(heap_end_vaddr + 4, 0); set_blocksize(heap_end_vaddr + 4, 4096); last_block = old_heap_end + 4; &#125; else &#123; set_allocated(last_block,last_blocksize + 4096); &#125; // try to allocated payload_vaddr = try_alloc(last_block,requested_blocksize); if(payload_vaddr != 0) &#123; return payload_vaddr; &#125; &#125; // &lt;==&gt; return NULL; return 0;&#125;void mem_free(uint64_t payload_vaddr) &#123; assert(heap_start_vaddr &lt;= payload_vaddr &amp;&amp; payload_vaddr &lt;= heap_end_vaddr); assert((payload_vaddr &amp; 0x7) == 0x0); uint64_t req = get_header_addr(payload_vaddr); uint64_t req_footer = get_footer_addr(req);//.0.// uint32_t req_allocated = get_allocated(req); uint32_t req_blocksize = get_blocksize(req); assert(req_allocated==1); // block starting address of next &amp;&amp; prev uint64_t next = get_nextheader(req);// last . 0 uint64_t next_footer = get_footer_addr(next); uint64_t prev = get_prevheader(req);// first . 0 uint32_t next_allocated = get_allocated(next);// last . 1 uint32_t prev_allocated = get_allocated(prev);// first . 1 uint32_t next_blocksize = get_blocksize(next);// last . 0 uint32_t prev_blocksize = get_blocksize(prev);// first . 0 if(next_allocated == 1 &amp;&amp; prev_allocated == 1) &#123; set_allocated(req,0); set_allocated(req_footer,0); &#125; else if(next_allocated == 0 &amp;&amp; prev_allocated == 1) &#123; set_allocated(req, 0); set_blocksize(req, req_blocksize + next_blocksize); set_allocated(next_footer,0); set_blocksize(next_footer,req_blocksize + next_blocksize); &#125; else if(next_allocated == 1 &amp;&amp; prev_allocated ==0) &#123; set_allocated(prev, 0 ); set_blocksize(prev, req_blocksize + prev_blocksize); set_allocated(req_footer, 0); set_blocksize(req_footer,req_blocksize + prev_blocksize); &#125; else &#123; set_allocated(prev, 0 ); set_blocksize(prev, req_blocksize + prev_blocksize + next_blocksize); set_allocated(next_footer, 0); set_blocksize(next_footer, req_blocksize + prev_blocksize + next_blocksize); &#125;&#125; 显式空闲链表 explicit free list 可以做到Tsearch(Explicit)≤12Tsearch(Implicit)T{search}(Explicit)\\le\\frac12T{search}(Implicit)Tsearch(Explicit)≤21​Tsearch(Implicit)，（交错分布，糖水不等式）","categories":[{"name":"C","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://example.com/tags/OS/"}],"author":"tugumineko"},{"title":"扩散模型 - Diffusion Model","slug":"diffusion-model","date":"2024-05-26T06:10:13.000Z","updated":"2024-05-30T14:07:24.052Z","comments":true,"path":"2024/05/26/diffusion-model/","permalink":"http://example.com/2024/05/26/diffusion-model/","excerpt":"","text":"引入 Diffusion Model是如何运作的 就像把石头雕刻成雕塑，DiffusionModel是将一张充满噪声（noise）的图片不断Denoise最后生成图片的过程 Denoise模组内部实际做的事情 在遇到一个图片的Denoise过程的时候，先计算出噪声的严重程度，然后推断出需要消去的噪声（这个在训练模型的时候的step）,最后一步步生成图片 类似于一种自我监督的训练方式 * 先加噪声训练，然后遇到一个有噪声的图片，用这个模型就可以去噪 * 要使文字可以影响生成的图片，只要在每次训练的时候记录即可 Stable Diffusion 文字生成的一个个向量，通过消去GenerationModel产生的一个矩阵，生成一个“一个中间产物”（图片的压缩版本），即产生最后的Decoder，还原成原来的图片。例如：Stable Diffusion、DALL-E series、Imagen Encode越来越大（好的文字的Encoder），图片的生成结果越好（对文字的理解更好） 增大DiffusionModel对生成图像的效果是有限的 Frechet Inception Distance（FID） 一种判断图像生成效果的参数：假设真正的图像和生成的图像满足高斯分布，计算它们之间的Frechet Distance. Smaller is better 缺点：需要大量的样本（sample） 注解：各个图片（一张图片是一个高维度向量），任取一个维度来统计分析，发现经常是高斯分布 Contrastive Language-Image Pre-Training(CLIP) 一个对比文字和图像匹配度的模型 Encoder和Decoder Encoder不需要文字当作输入，而是向量形式就可以训练 中间产物为[Latent Representation](？隐表示) 先Encoder为Latent Representation再训练模型 生成图像使先一步步给Latent Representation Denoise，最后丢给Decoder就可以生图了。 Encoder是文字到压缩图片，Decoder是压缩图片到高清图片 Diffusion Model背后的数学原理 VAE vs. Diffusion Model Training x0:sample clean image 均匀分布 Uniform ⁡ ( { 1 , … , T } ) ：Uniform({1,…,T}) 表示 t 可以取自集合{1,2,…,T} 中的任何一个值 e:sample noise 加权求和:t越大，噪声加的越凶狠,最终得到Noisy image 将sample e和计算出来的Noise predictor作差 实际上是给予一个权值直接添加noise，得到noise，训练和生成都是一样的 Sampling xT : sample a noise 循环生成z（sample a noise）","categories":[],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"author":"tugumineko"},{"title":"正则表达式","slug":"正则表达式","date":"2024-05-25T07:25:49.000Z","updated":"2024-05-27T04:37:23.673Z","comments":true,"path":"2024/05/25/正则表达式/","permalink":"http://example.com/2024/05/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"定位 ^ :匹配行首或正则表达式搜索的字符串的开头 $ :匹配行尾或正则表达式搜索的字符串的末尾 元字符 . :匹配除新行以外的任意单个字符 | :表示备选项，即“或” \\ :表示下一个是文字字符，而非特殊字符 字符类 […] :匹配某一字符集中的任意字符。在字符集中可使用短划线分隔第一个字符和最后一个字符 [^…] :匹配某一字符集以外的任意字符 内容合规性政策中的正则表达式区分大小写 [:alnum:] :匹配字母或数字：a-z|A-Z|0-9 [:alpha:] :匹配字母：a-z|A-Z [:digit:] :匹配数字：0-9 [:graph:] :仅匹配可见字符，即空格、控制符等以外的所有字符 [:punct:] :匹配标点字符和符号：! &quot; # $ % &amp; ’ ( ) * + , \\ -. / : ; &lt; = &gt; ? @ [ ] ^ _ ` { | } [:print:] :匹配可见字符和空格 [:space:] :匹配任意空白字符，包括空格、制表符和换行符 [:word:] :匹配任意字词字符，即任意字母、数字和下划线：a-z|A-Z|0-9|_ 在正则表达式中使用此字符类时，必须将其以另外一组方括号括起 缩略字符类 \\w :和[:word:]作用相同 \\W :和[^[:word:]]作用相同 \\s :和[:space:]作用相同 \\S :和[^[:space:]]作用相同 \\d :和[:digit:]作用相同 \\D :和[^[:digit:]]作用相同 分组 (…) 将表达式的不同部分归入不同的分组。利用分组，您可以为某个分组分配一个编号，也可以在某个分组的前后匹配字符类。 数量 {n} ：准确匹配前一个表达式nnn次 {n,m} :匹配前一个表达式最少nnn次，最多mmm次 ? :表示前一个字符或表达式可以匹配0次或1次（成为可选项） * :匹配上一个元素0次或多次 + :匹配上一个元素一次 好了，你已经掌握了所有正则表达式的基本操作了。快来做一些简单的练习吧！","categories":[],"tags":[{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"}],"author":"tugumineko"},{"title":"vim-syntax","slug":"vim-syntax","date":"2024-05-23T11:44:41.000Z","updated":"2024-05-28T12:39:50.676Z","comments":true,"path":"2024/05/23/vim-syntax/","permalink":"http://example.com/2024/05/23/vim-syntax/","excerpt":"","text":"VIMTUTOR Lesson 1 SUMMARY The cursor is moved using either the arrow keys or the hjkl keys. h (left) j (down) k (up) l (right) To start Vim from the shell prompt type: vim FILENAME &lt;ENTER&gt; To exit Vim type: &lt;ESC&gt; :q! &lt;ENTER&gt; to trash all changes. OR type: &lt;ESC&gt; :wq &lt;ENTER&gt; to save the changes. To delete the character at the cursor type: x To insert or append text type: i type inserted text &lt;ESC&gt; insert before the cursor A type appended text &lt;ESC&gt; append after the line NOTE: Pressing &lt;ESC&gt; will place you in Normal mode or will cancel an unwanted and partially completed command. Lesson 2 SUMMARY To delete from the cursor up to the next word type: dw To delete from the cursor to the end of a line type: d$ To delete a whole line type: dd To repeat a motion prepend it with a number: 2w The format for a change command is: operator [number] motion where: operator - is what to do, such as d for delete [number] - is an optional count to repeat the motion motion - moves over the text to operate on, such as w (word), $ (to the end of line), etc. To move to the start of the line use a zero: 0 To undo previous actions, type: u (lowercase u) To undo all the changes on a line, type: U (capital U) To undo the undo’s, type: CTRL-R Lesson 3 SUMMARY To put back text that has just been deleted, type p . This puts the deleted text AFTER the cursor (if a line was deleted it will go on the line below the cursor). To replace the character under the cursor, type r and then the character you want to have there. The change operator allows you to change from the cursor to where the motion takes you. eg. Type ce to change from the cursor to the end of the word, c$ to change to the end of a line. The format for change is: c [number] motion Lesson 4 SUMMARY CTRL-G displays your location in the file and the file status. G moves to the end of the file. number G moves to that line number. gg moves to the first line. Typing / followed by a phrase searches FORWARD for the phrase. Typing ? followed by a phrase searches BACKWARD for the phrase. After a search type n to find the next occurrence in the same direction or N to search in the opposite direction. CTRL-O takes you back to older positions, CTRL-I to newer positions. Typing % while the cursor is on a (,),[,],{, or } goes to its match. To substitute new for the first old in a line type :s/old/new To substitute new for all 'old’s on a line type :s/old/new/g To substitute phrases between two line #'s type :#,#s/old/new/g To substitute all occurrences in the file type :%s/old/new/g To ask for confirmation each time add ‘c’ :%s/old/new/gc Lesson 5 SUMMARY :!command executes an external command. Some useful examples are: (MS-DOS) (Unix) :!dir :!ls - shows a directory listing. :!del FILENAME :!rm FILENAME - removes file FILENAME. :w FILENAME writes the current Vim file to disk with name FILENAME. v motion :w FILENAME saves the Visually selected lines in file FILENAME. :r FILENAME retrieves disk file FILENAME and puts it below the cursor position. :r !dir reads the output of the dir command and puts it below the cursor position. Lesson 6 SUMMARY Type o to open a line BELOW the cursor and start Insert mode. Type O to open a line ABOVE the cursor. Type a to insert text AFTER the cursor. Type A to insert text after the end of the line. The e command moves to the end of a word. The y operator yanks (copies) text, p puts (pastes) it. Typing a capital R enters Replace mode until &lt;ESC&gt; is pressed. Typing “:set xxx” sets the option “xxx”. Some options are: ‘ic’ ‘ignorecase’ ignore upper/lower case when searching ‘is’ ‘incsearch’ show partial matches for a search phrase ‘hls’ ‘hlsearch’ highlight all matching phrases You can either use the long or the short option name. Prepend “no” to switch an option off: :set noic Lesson 7 SUMMARY Type :help or press &lt;F1&gt; or &lt;Help&gt; to open a help window. Type :help cmd to find help on cmd . Type CTRL-W CTRL-W to jump to another window Type :q to close the help window Create a vimrc startup script to keep your preferred settings. When typing a : command, press CTRL-D to see possible completions. Press &lt;TAB&gt; to use one completion. VIMRC &quot; Comments in Vimscript start with a `&quot;`. &quot; If you open this file in Vim, it’ll be syntax highlighted for you. &quot; Vim is based on Vi. Setting `nocompatible` switches from the default &quot; Vi-compatibility mode and enables useful Vim functionality. This &quot; configuration option turns out not to be necessary for the file named &quot; ‘~/.vimrc’, because Vim automatically enters nocompatible mode if that file &quot; is present. But we’re including it here just in case this config file is &quot; loaded some other way (e.g. saved as `foo`, and then Vim started with &quot; `vim -u foo`). set nocompatible &quot; Turn on syntax highlighting. syntax on &quot; Disable the default Vim startup message. set shortmess+=I &quot; Show line numbers. set number &quot; This enables relative line numbering mode. With both number and &quot; relativenumber enabled, the current line shows the true line number, while &quot; all other lines (above and below) are numbered relative to the current line. &quot; This is useful because you can tell, at a glance, what count is needed to &quot; jump up or down to a particular line, by {count}k to go up or {count}j to go &quot; down. set relativenumber &quot; Always show the status line at the bottom, even if you only have one window open. set laststatus=2 &quot; The backspace key has slightly unintuitive behavior by default. For example, &quot; by default, you can’t backspace before the insertion point set with ‘i’. &quot; This configuration makes backspace behave more reasonably, in that you can &quot; backspace over anything. set backspace=indent,eol,start &quot; By default, Vim doesn’t let you hide a buffer (i.e. have a buffer that isn’t &quot; shown in any window) that has unsaved changes. This is to prevent you from &quot; &quot; forgetting about unsaved changes and then quitting e.g. via :qa!. We find &quot; hidden buffers helpful enough to disable this protection. See :help hidden &quot; for more information on this. set hidden &quot; This setting makes search case-insensitive when all characters in the string &quot; being searched are lowercase. However, the search becomes case-sensitive if &quot; it contains any capital letters. This makes searching more convenient. set ignorecase set smartcase &quot; Enable searching as you type, rather than waiting till you press enter. set incsearch &quot; Unbind some useless/annoying default key bindings. nmap Q &lt;Nop&gt; &quot; ‘Q’ in normal mode enters Ex\\ mode. You almost never want this. &quot; Disable audible bell because it’s annoying. set noerrorbells visualbell t_vb= &quot; Enable mouse support. You should avoid relying on this too much, but it can &quot; sometimes be convenient. set mouse+=a &quot; Try to prevent bad habits like using the arrow keys for movement. This is &quot; not the only possible bad habit. For example, holding down the h/j/k/l keys &quot; for movement, rather than using more efficient movement commands, is also a &quot; bad habit. The former is enforceable through a .vimrc, while we don’t know &quot; how to prevent the latter. &quot; Do this in normal mode… nnoremap &lt;Left&gt; :echoe &quot;Use h&quot;&lt;CR&gt; nnoremap &lt;Right&gt; :echoe &quot;Use l&quot;&lt;CR&gt; nnoremap &lt;Up&gt; :echoe &quot;Use k&quot;&lt;CR&gt; nnoremap &lt;Down&gt; :echoe &quot;Use j&quot;&lt;CR&gt; &quot; …and in insert mode inoremap &lt;Left&gt; &lt;ESC&gt;:echoe &quot;Use h&quot;&lt;CR&gt; inoremap &lt;Right&gt; &lt;ESC&gt;:echoe &quot;Use l&quot;&lt;CR&gt; inoremap &lt;Up&gt; &lt;ESC&gt;:echoe &quot;Use k&quot;&lt;CR&gt; inoremap &lt;Down&gt; &lt;ESC&gt;:echoe &quot;Use j&quot;&lt;CR&gt; Vim进阶 搜索和替换 :s(替换命令) %s/foo/bar/g - 在整个文件中将foo全局替换成bar %s/\\[.*\\](\\(.*\\))/\\1/g - 将有命名的MarkdownMarkdownMarkdown链接替换成简单URLsURLsURLs 多窗口 用:sp/:vsp来分割窗口 同一个缓存可以在多个窗口中显示 用&lt;c-w&gt;+(hjkl)切换窗口 宏 q&#123;字符&#125;来开始在寄存器&#123;字符&#125;中录制宏 q停止录制 @&#123;字符&#125;重放宏 宏的执行错误会停止 &#123;计数&#125;@&#123;字符&#125;执行一个宏{计数}次 宏可以递归 首先用q&#123;字符&#125;q清除宏 录制该宏，用@&#123;字符&#125;来递归调用该宏（在录制完成之前不会有任何操作）","categories":[{"name":"vim","slug":"vim","permalink":"http://example.com/categories/vim/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"},{"name":"文本编辑器","slug":"文本编辑器","permalink":"http://example.com/tags/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"}],"author":"tugumineko"},{"title":"生活在树上","slug":"生活在树上","date":"2024-05-19T04:43:48.000Z","updated":"2024-05-28T15:32:43.032Z","comments":true,"path":"2024/05/19/生活在树上/","permalink":"http://example.com/2024/05/19/%E7%94%9F%E6%B4%BB%E5%9C%A8%E6%A0%91%E4%B8%8A/","excerpt":"","text":"二叉搜索树 Treap树 每个结点有2个值 键值：value 优先级：priority value要满足BST的基本性质，priority用于满足堆的性质，用来实现二叉树的平衡 Treap通过随机化的priority属性,以及维护堆性质的过程，[打乱]了结点的插入顺序。从而让二叉搜索树达到了理想的复杂度，避免了退化成链的问题 利用Treap可以实现一个名次树而且比红黑树好写很多，在算法竞赛中很常用 结点结构 1234567891011121314151617struct Node &#123; Node *ch[2];// ch[0]左树的指针，ch[1]右树的指针 int val, rank; int rep_cnt;// val出现的次数 int siz;// 结点树的大小 Node(int val) : val(val), rep_cnt(1), siz(1) &#123; ch[0] = ch[1] = nullptr; rank = rand(); &#125; void upd_siz() &#123; siz = rep_cnt; if (ch[0] != nullptr) siz += ch[0]-&gt;siz; if (ch[1] != nullptr) siz += ch[1]-&gt;siz; &#125;&#125;; 旋转 旋转操作的含义： 在不影响搜索树的性质的前提下，把和旋转方向相反的子树变成根结点。 将新的根结点的子树变为旧根结点的子树 这里使用一个temp存新的根结点，并且最后要更改引用 123456789enum rot_type &#123; LF = 1, RT = 0 &#125;;void _rotate(Node *&amp;cur, rot_type dir) &#123; Node *tmp = cur-&gt;ch[dir];// 把和旋转方向相反的子结点变成根结点 cur-&gt;ch[dir] = tmp-&gt;ch[!dir];// 将新的根结点的子树变为旧根结点的子树 tmp-&gt;ch[!dir] = cur;// 新子树放到与旋转相同方向的根结点，从而完成旋转操作 cur-&gt;upd_siz(), tmp-&gt;upd_siz(); cur = tmp;&#125; 插入 插的过程中通过旋转来维护树堆中堆的性质,旋转完成后要更新结点大小 1234567891011121314151617181920212223void _insert(Node *&amp;cur, int val) &#123; if (cur == nullptr) &#123; cur = new Node(val); return; &#125; else if (val == cur-&gt;val) &#123; cur-&gt;rep_cnt++; cur-&gt;siz++; &#125; else if (val &lt; cur-&gt;val) &#123; _insert(cur-&gt;ch[0], val); if (cur-&gt;ch[0]-&gt;rank &lt; cur-&gt;rank) &#123; // 利用rank维护小根堆性质 _rotate(cur, RT);// 要把左结点转上来，需要右旋 &#125; cur-&gt;upd_siz(); &#125; else &#123; _insert(cur-&gt;ch[1], val); if (cur-&gt;ch[1]-&gt;rank &lt; cur-&gt;rank) &#123; _rotate(cur, LF); &#125; cur-&gt;upd_siz(); &#125;&#125; 删除 注意更新结点大小，思路和插入差不多 123456789101112131415161718192021222324252627282930313233343536373839void _del(Node *&amp;cur, int val) &#123; // 每次递归都要重新更新size if (val &gt; cur-&gt;val) &#123; _del(cur-&gt;ch[1], val); cur-&gt;upd_siz(); &#125; else if (val &lt; cur-&gt;val) &#123; _del(cur-&gt;ch[0], val); cur-&gt;upd_siz(); &#125; else &#123; if (cur-&gt;rep_cnt &gt; 1) &#123; cur-&gt;rep_cnt--, cur-&gt;siz--; return; &#125; uint8_t state = 0; state |= (cur-&gt;ch[0] != nullptr); state |= ((cur-&gt;ch[1] != nullptr) &lt;&lt; 1); Node *tmp = cur; switch (state) &#123; case 0: delete cur; cur = nullptr; break; case 1: cur = tmp-&gt;ch[0]; delete tmp; break; case 2: cur = tmp-&gt;ch[1]; delete tmp; break; case 3: rot_type dir = cur-&gt;ch[0]-&gt;rank &lt; cur-&gt;ch[1]-&gt;rank ? RT : LF;// 把优先级更小的儿子转上去 _rotate(cur, dir); _del(cur-&gt;ch[!dir], val);// 旋转完成后删除旧节点(位于根节点的旋转方向的子节点) cur-&gt;upd_siz(); break; &#125; &#125;&#125; 根据值查询排名 查询以 cur 为根节点的子树中，val 这个值的大小的排名（该子树中小于 val 的节点的个数 + 1） 1234567891011121314151617181920int _query_rank(Node* cur, int val) &#123; int less_siz = cur-&gt;ch[0] == nullptr ? 0 : cur-&gt;ch[0]-&gt;siz; // 在BST中，左儿子比父节点小 if (cur-&gt;val == val) return less_siz + 1; else if (cur-&gt;val &gt; val) &#123; if (cur-&gt;ch[0] != nullptr) return _query_rank(cur-&gt;ch[0], val); else return 1; // 没有比它小的了 &#125; else &#123; if (cur-&gt;ch[1] != nullptr) // 如果要查的值比这个节点大，那这个节点的左子树以及这个节点自身肯定都比要查的值小 // 所以要加上这两个值，再加上往右边找的结果 // （以右子树为根的子树中，val 这个值的大小的排名） return less_siz + cur-&gt;cnt + _query_rank(cur-&gt;ch[1], val); else return cur-&gt;siz + 1; // 没有右子树 &#125;&#125; 根据排名查询值 直接递归，和BST搜索的写法差不多 排名&lt;=左子树的大小，则搜索左子树 排名&gt;=左子树的大小 + 根结点的重复次数，则搜索右子树 123456789int _query_val(Node *cur, int rank) &#123; int less_siz = cur-&gt;ch[0] == nullptr ? 0 : cur-&gt;ch[0]-&gt;siz; if (rank &lt;= less_siz) return _query_val(cur-&gt;ch[0], rank); else if (rank &lt;= less_siz + cur-&gt;rep_cnt) return cur-&gt;val; else return _query_val(cur-&gt;ch[1], rank - less_siz - cur-&gt;rep_cnt);&#125; 查询第一个比 val 小的节点 全局变量，q_prev_tmp 是只有在 val 比当前节点值大的时候才会被更改的，所以返回这个变量就是返回 val 最后一次比当前节点的值大，之后就是更小了 12345678910111213141516int _query_prev(Node *cur, int val) &#123; if (val &lt;= cur-&gt;val) &#123; // 往左子树找 if (cur-&gt;ch[0] != nullptr) return _query_prev(cur-&gt;ch[0], val); &#125; else &#123; // 只有能进到这个 else 里，才会更新 q_prev_tmp 的值 q_prev_tmp = cur-&gt;val; // 因为要确定最大的，所以要到右子树继续找 if (cur-&gt;ch[1] != nullptr) _query_prev(cur-&gt;ch[1], val); // 接下来的递归可能不会更改 q_prev_tmp // 了，那就直接返回最后一次进到 这个 else 中的 // cur-&gt;val return q_prev_tmp; &#125; return -1;&#125; 查询第一个比 val 大的节点 12345678910int _query_nex(Node *cur, int val) &#123; if (val &gt;= cur-&gt;val) &#123; if (cur-&gt;ch[1] != nullptr) return _query_nex(cur-&gt;ch[1], val); &#125; else &#123; q_nex_tmp = cur-&gt;val; if (cur-&gt;ch[0] != nullptr) _query_nex(cur-&gt;ch[0], val); return q_nex_tmp; &#125; return -1;&#125; Splay树 理论 通常在任意数据结构的生命期内，不仅执行不同操作的概率往往极不均衡，而且各操作之间具有极强的关联性，并在整体上多呈现出极强的规律性。其中最为典型的，就是所谓的“数据局部性”，即： (1) 刚刚被访问过的元素，极有可能在不久之后再次被访问到 (2) 将被访问的下一元素，极有可能就处于不久之前被访问过的某个元素附近 就BST而言，数据局部性具体表现为： (1) 刚刚被访问过的节点，极有可能在不久的之后访问到 (2) 将被访问的下一节点，极有可能就处于不久之前被访问过的节点的附近 因此，只需将刚被访问过的节点，及时地”转移“至树根（附近），即可加速后续的操作。Splay树应运而生 对比Splay和Treap: (1) Splay树允许把任意节点旋转到根 (2) 需要分裂和合并时，Splay树的操作非常简便 结构与操作 每一次查询后都要splay 123456789101112131415161718192021222324252627282930313233343536373839404142int root; // 根节点int ch[N][2], fa[N]; // 子节点/父节点int val[N]; // 权值int size[N]; // 子树大小int cnt[N]; // 重复次数int tot; // 节点个数struct Splay &#123; // 维护子树大小 void maintain(int x); // 查找这个节点是父亲的左子树还是右子树 bool get(int x); // 销毁这个节点 void clear(int x); // 旋转 void rotate(int x); // 伸展操作 void splay(int x); // 插入v void insert(int v); // 查询值为v的数排名 int find_rank(int v); // 查询排名为r的数 int find_val(int r); // 查询根节点的前驱 int pre(); // 查询根节点的后继 int next(); // 删除一个值为val的数 void del(int v);&#125; tree; 基本操作 123456789101112void Splay::maintain(int x) &#123; size[x] = size[ch[x][0]] + size[ch[x][1]] + cnt[x];&#125;bool Splay::get(int x) &#123; // 左儿子返回0.右儿子返回1 return x == ch[fa[x]][1];&#125;void Splay::clear(int x) &#123; ch[x][0]=ch[x][1]=fa[x]=val[x]=size[x]=cnt[x]=0;&#125; 旋转 1234567891011121314151617181920// 节点x上升一位void Splay::rotate(int x) &#123; // 右儿子的父亲左移，左儿子的父亲右移 // 设父亲为y，祖父为z int dir = get(x); int y = fa[x], z = fa[y]; // 先杀皇帝再让太子继位，然后再供奉祖宗牌匾 ch[y][dir] = ch[x][!dir]; if (ch[y][!dir]) fa[ch[x][!dir]] = y; ch[x][!dir] = y; fa[y] = x; fa[x] = z; if (z) ch[z][y == ch[z][1]] = x; // 先维护儿子，再维护父亲 maintain(y); maintain(x); &#125; 伸展 12345678void Splay::splay(int x) &#123; // 设父亲为y,祖父为z // 若儿子种类相同，则先转祖父，再转父亲 // 若儿子种类不同，则先转父亲，再转祖父 for (int i = fa[x]; i = fa[x], i; rotate(x)) if (fa[f]) get(x) == get(i) ? rotate(i) : rotate(x); root = x;&#125; 插入 依然是三种情况： 空树nullptr 重复的值，直接cnt++然后伸展 没有，则按照BST插入后伸展 这里数组的下标用tot标记，即元素的插入顺序 123456789101112131415161718192021222324252627282930313233void Splay::insert(int v) &#123; if (!root) &#123; val[++tot] = val; cnt[tot] = size[tot] = 1; root = tot; return; &#125; else &#123; int cur = root, i = 0; while (1) &#123; if (val[cur] == v) &#123; cnt[cur]++; maintain(cur); maintain(i); splay(cur); return; &#125; i = cur; cur = ch[cur][val[cur] &lt; v]; if (cur == 0) &#123; tot++; val[tot] = v; cnt[tot]++; fa[tot] = i; ch[x][val[x] &lt; v] = tot; maintain(tot); maintain(x); splay(tot); return; &#125; &#125; &#125;&#125; 查询值为v的数的排名 经典回顾： 如果 x 比当前节点的权值小，向其左子树查找。 如果 x 比当前节点的权值大，将答案加上左子树（size）和当前节点（cnt）的大小，向其右子树查找。 如果 x 与当前节点的权值相同，将答案加 1 并返回。 最后要进行splay 1234567891011121314151617int Splay::find_rank(int v) &#123; int ans = 0, cur = root; while (1) &#123; if (v &lt; val[cur]) cur = ch[cur][0]; else &#123; ans += size[ch[cur][0]]; if(!cur)return ans+1; if (v == val[cur]) &#123; splay(cur); return ans + 1; &#125; ans += cnt[cur]; cur = ch[cur][1]; &#125; &#125;&#125; 查询排名为r的数 经典回顾： 如果左子树非空且剩余排名 r 不大于左子树的大小 size，那么向左子树查找。 否则将 r 减去左子树的和根的大小。如果此时 r 的值小于等于 0，则返回根节点的权值，否则继续向右子树查找。 123456789101112131415int Splay::find_val(int r) &#123; int cur = root; while (1) &#123; if (ch[cur][0] != 0 &amp;&amp; r &lt;= size[ch[cur][0]]) cur = ch[cur][0]; else &#123; r -= cnt[cur] + size[ch[cur][0]]; if (r &lt;= 0) &#123; splay(cur); return val[cur]; &#125; cur = ch[cur][1]; &#125; &#125;&#125; 查询前驱 前驱定义为小于 x 的最大的数，那么查询前驱可以转化为：将 x 插入（此时 x 已经在根的位置了），前驱即为 x 的左子树中最右边的节点，最后将 x 删除即可。 这里插入和删除操作请自行添加 1234567891011int Splay::pre()&#123; int cur = ch[root][0]; if( cur == 0 ) return cur; while( ch[cur][1] ) cur = ch[cur][1]; splay(cur); return cur;&#125; 查询后继 这里插入和删除操作请自行添加 1234567891011int Splay::next()&#123; int cur = ch[root][1]; if( cur == 0 ) return cur; while( ch[cur][0] ) cur = ch[cur][0]; splay(cur); return cur;&#125; 合并 对于合并两棵树，其中一棵树的值都小于另一棵树的值。 我们可以找到较小一棵树的最大值 x ，将其旋转到根节点。 再把较大一棵树作为 x 的右子树插入。 删除 首先将 x 转移到根节点 若 x 值不只一个，直接cnt[x]– 否则将它的左右子树合并 1234567891011121314151617181920212223242526272829303132333435363738394041424344void Splay::del(int v)&#123; find_rank(v);//splay if(cnt[root]&gt;1)&#123; cnt[root]--; maintain(root); return; &#125; if((ch[root][0]==0)&amp;&amp;(ch[root][1]==0))&#123; clear(root); root = 0; return; &#125; if(ch[root][0]==0)&#123; int cur = root; root = ch[root][1]; fa[root]=0; clear(cur); return; &#125; if(ch[root][1]==0)&#123; int cur = root; root = ch[root][0]; fa[root]= 0; clear(cur); return; &#125; int cur = root; int x = pre();//splay //merge fa[ch[cur][1]] = x; ch[x][1] = ch[cur][1]; clear(cur); maintain(root); return;&#125; 序列操作 按照序列建成的Splay有以下性质: Splay的中序遍历相当于原序列从左到右的遍历 Splay上的一个节点代表序列的一个元素；Splay上的一颗子树，代表原序列的一段区间 利用Splay操作，可以快速提取出代表某个区间的Splay的子树 具体操作： Splay 的一颗子树代表原序列的一段区间。现在想找到序列区间 [L, R] 代表的子树，只需要将代表 aL−1a_{L - 1}aL−1​ 的节点 Splay 到根，再将代表 aR+1a_{R + 1}aR+1​的节点 splay 到根的右儿子即可。根据「Splay 的中序遍历相当于原序列从左到右的遍历」，对应 aR+1a_{R + 1}aR+1​ 的节点的左子树中序遍历为序列 a[L, R]，故其为区间 [L, R] 代表的子树。 一般会建立左右两个哨兵节点 0 和 n + 1，放在数列的最开头和最结尾，防止 L - 1 或 R + 1 超出数列范围。 123456789101112131415void Splay::splay(int x, int goal = 0) &#123; // 如果目标点 goal 为 0 说明旋转到根节点 if (goal == 0) root = x; // 设父亲为y,祖父为z // 若儿子种类相同，则先转祖父，再转父亲 // 若儿子种类不同，则先转父亲，再转祖父 while (fa[x] != goal) &#123; int i = fa[x], g = fa[i]; if (g != goal) &#123; get(i) == get(x) ? rotate(i) : rotate(x); &#125; rotate(x); &#125;&#125; 区间翻转 一个暴力做法是每次将根节点的左右儿子交换，然后递归左右子树做同样的操作，这样复杂度为 O(n)，不可承受。 可以考虑使用懒标记，先给根打上「翻转标记」并交换其左右儿子。当递归到一个带懒标记的点时，将懒标记下传即可 12345678910111213141516171819void Splay::tagrev(int v)&#123; swap(ch[v][0],ch[v][1]); lazy[v] ^= 1;&#125;void Splay::pushdown(int v)&#123; if(lazy[v])&#123; tagrev(ch[v][0]); tagrev(ch[v][1]); lazy[v] = 0; &#125;&#125;void Splay::reverse(int l, int r)&#123; int L = find_val(l-1), R = find_val(r+1); splay(L), splay(R, L); int temp = ch[ch[L][1]][0]; tagrev(temp);&#125; 将Splay用于需要区间翻转的区间维护 对于区间反转这种操作，由于原数列的顺序已经给定，所以不能按照权值排序，所以选择按照的点的编号建立BST 鸽了(我写不出来 多叉搜索树 B树","categories":[{"name":"cpp","slug":"cpp","permalink":"http://example.com/categories/cpp/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"tugumineko"},{"title":"C++之旅(A Tour of C++)读书笔记","slug":"the-tour-of-cpp","date":"2024-05-08T14:55:22.000Z","updated":"2024-05-14T14:43:18.094Z","comments":true,"path":"2024/05/08/the-tour-of-cpp/","permalink":"http://example.com/2024/05/08/the-tour-of-cpp/","excerpt":"","text":"基础 程序 ISO C++标准中定义了两种实体： 核心语言特性.i.e.内置类型(char,int).循环(for,while) 标准库组件.i.e.容器(vector,map).输入输出操作(&lt;&lt;,getline) C++是一种静态语言。这意味着，每一个实体(对象、值、名称和表达式等)被使用的那一刻，编译器必须知道其准确的类型。 1int main()&#123;&#125; //最小的cpp程序 123456//import std; 是cpp20的特性#include&lt;iostream&gt; //标准库组件int main()&#123; std::cout&lt;&lt;&quot;Hello, World!\\n&quot;; //标准库命名空间std::&#125; Hello, World! 函数 123double sqrt(double d); //函数声明的时候可以包含参数的名称double s = sqrt(2); //检测参数类型在必要的时候会发生隐式类型转换char&amp; String::operator[](int index); //函数的类型是char&amp; String::(int),函数可以是类成员 类型、变量和运算 unsigned一般用于位运算 数字可以是浮点数或者整数： 浮点字面量含有小数点或者指数符号 0b二进制整数 //0b0101010 0x十六进制整数 //0x3f3f3f3f 0八进制整数 //0334 使用单引号(’)作位数字分隔符 0x3.243F’6A88’85A3’08D3 初始化: = 的形式是C语言传统的形式，会发生隐式类型转换 {} 更通用，而且可以省略’=’,不会发生隐式类型转换 常量被声明时必须被初始化，用户自定义类型可以在定义时被隐式初始化 如果变量的类型可以从初始化符号中推导出来，就无需显式指定类型 使用 auto 常用在泛型编程中，以避免书写冗长的类型名称及重复代码 1234567double d1 = 2.3;double d2 &#123;2.3&#125;;double d3 = &#123;2.3&#125;;complex&lt;double&gt; z = 1;complex&lt;double&gt; z2 &#123;d1,d2&#125;;complex&lt;double&gt; z3 = &#123;d1,d2&#125;;vector&lt;int&gt; v &#123;1, 2, 3, 4, 5, 6&#125;; 12auto y = 3.14;auto z &#123;sqrt(y)&#125;; 作用域和生命周期 声明语句把一个名字引入作用域： 局部作用域：在函数/匿名函数中定义的名字叫做局部名字(包括函数参数的名字)，以语句块({})结尾. 类作用域：不在函数、匿名函数或 enum class 中但在类的内部. 命名空间作用域：不是局部名字和类名字且在命名空间的内部. 生命周期： 对象必须先被构造（初始化）才能被使用，并且在退出作用域时被销毁。 命名空间对象在程序结束时被销毁。 对象成员的销毁时间点取决于所属对象的销毁时间点。 一个用new创建的对象则可以持续生存，直到用delete将其销毁。 常量 const 用来说明接口，可以用指针或者引用的方式传入参数而不用担心被改变 编译器负责强制执行 const 承诺 const声明的值可以在运行时计算 constexpr 声明常量，在只读内存中，提高性能 constexpr 的值必须由编译器运算 const double s1 = sum(v); //可行:允许在运行时运算 constexpr double s2 = sum(v); 123456789double sum1(const double&amp;);double sum2(const vector&lt;double&gt;&amp;);vector&lt;double&gt; v &#123;1.2, 3.4, 5.6&#125;;const double s1 = sum1(1.0); //可行constexpr double s2 = sum1(1.0); //不行constexpr double s3 = sum2(v); //不行&#125; 若要使函数在常量表达式(上文代码)中使用，这个函数必须被定义为 constexpr 或 consteval constexpr 函数 在输入非常量参数时，输出的不是常量表达式 在输入常量参数时，输出的才是常量表达式 consteval 函数可以让输入变量只能为常量表达式,即可以省略输入的常量表达式语法，还可以使输出为常量表达式。 12345constexpr double squre(double x)&#123;return x*x;&#125;constexpr double max1 = 1.4*squre(17) //可行，17为常量constexpr double max2 = 1.4*squre(var) //错误，var不是变量，所以返回值不是常量表达式const double max3 = 1.4*squre(var) //可行 1234consteval double square2(double x)&#123;return x*x;&#125;constexpr double max1 = 1.4*square2(17); //可行const double max2 = 1.4*square2(var); //错误，函数输入只能是常量表达式 总结 这里讨论的有三个部分，函数的返回值类型（函数的声明），函数的输入参数类型，数据类型,均有两种写法，注意分辨 函数的输入参数类型 (数据类型 变量名):可以是变量，也可以是常量表达式 (const 数据类型&amp; 变量名):函数不会修改他它的参数 数据类型 const:说明接口，意为“只读” cosntexpr:声明常量，赋值给他的只能是常量表达式 函数的返回值类型 constexpr:不指定输入类型，输入和输出的不变性一致 consteval:输入和输出均为常量表达式 注意const只具有接口性质，不是实际上的常量 函数的声明为常量(constexpr,consteval)可以实现C++的纯函数，即数学意义上的函数，不会有副作用，不能修改函数的输入参数 指针、数组和引用 123456T a[n]; //数组T* p; //指针T&amp; r; //引用char* p = &amp;v[3]; //p指向数组v的第四个元素char x = *p; //*p代表p指向的对象(*解引用) 注意*在定义时是定义指针,在指针前使用是解引用 空指针 空指针用nullptr表达，整数用0或NULL表达，在检验时是兼容的 不能引用空指针 映射到硬件 赋值: p和q同时指向y的地址 1234int y = 3;int* p = &amp;x;int* q = &amp;y;p = q; 地址r1,r2不同，但是使不同的地址具有相同的值 12345int x = 2;int y = 3;int&amp; r1 = x;int&amp; r2 = y;r1 = r2; 这里直接用引用的方法操作地址，没有使用指针 初始化:没有未经初始化的引用 使用 = 来初始化一个引用，注意这不是赋值 int&amp; r = x; //r指代x 补充在函数中引用的两种方法 void sort(vector&lt;double&gt;&amp;v) 若只想减少复制参数的开销，则： double sum(const vector&lt;double&gt;&amp;) 这样就不能改变函数传入的参数 用户自定义类型 内置类型：用基本类型、const操作符和声明操作符构造出来的类型 用户自定义类型：利用C++的抽象机制从其他类型构造出来的类型，包括类和枚举类型 结构 struct 1234567891011121314151617181920212223242526struct Vector &#123; double* elem; int sz; &#125;; void vector_init(Vector&amp; v, int s)&#123; v.elem = new double[s]; v.sz = s; &#125;double read_and_sum(int s) //从cin中读入s个整数，然后返回它们的和；假定s为正&#123; Vector v; vector_init(v,s); for(int i=0;i!=s;i++)&#123; std::cin&gt;&gt;v.elem[i]; &#125; double sum = 0; for(int i=0;i!=s;i++)&#123; sum += v.elem[i]; &#125; return sum;&#125; 访问结构体的成员有两种方式 用 . 表示通过名字或者引用访问 用 -&gt; 表示通过指针访问 12345void f(Vector v, Vector&amp; rv, Vector* pv)&#123; int i1 = v.sz; //通过名字访问 int i2 = rv.sz; //通过引用访问 int i3 = pv-&gt;sz; //通过指针访问 &#125; 类 class 把类型的接口（所有代码都可使用的部分）与其实现（可访问外部不可访问的数据）分离开来的语言机制被称为类 123456789class Vector &#123;public: Vector(int s) :elem&#123; new double[s] &#125;, sz&#123; s &#125; &#123;&#125; //构造函数 double&amp; operator[](int i) &#123; return elem[i]; &#125; int size() &#123; return sz; &#125;private: double* elem; int sz;&#125;; 构造函数在初始化类对象时一定会被调用 错误处理暂时没有涉及 思考通过new获取的double数组如何归还？ struct和class没有本质区别，struct是默认public的 枚举 enum class 枚举类型用于表示少量整数数值的集合 通过符号名称替代整数 后面的class表示这个枚举类型是强类型，并且具备独立作用域 不能混用不同类的枚举值 无法隐式地混用枚举类型与整数类型的值 默认情况下，一个enum class定义仅定义赋值操作符、初始化函数及比较操作符，也可以自定义其他操作符 123456789101112131415enum class Color &#123; red, blue, green &#125;;enum class Traffic_light &#123; green, yellow, red &#125;;Color col = Color::red;Traffic_light light = Traffic_light::red;Traffic_light* operator++(Traffic_light&amp; t) &#123; using enum Traffic_light; switch (t) &#123; case green:return t = yellow; case red:return t = green; case green:return t = red; &#125;&#125; Color x = redColor y = traffic_light::red int i = Color::redColor c = 2 Color z = Color::redauto z = Color::red Color x = Color{5}Color y {6} enum 普通enum中的枚举值进入与enum自身同级的作用域 可以被隐式转换为整数数值 用枚举表示一组命名的常量为枚举定义操作来简化并保证安全优先使用enum class以避免很多麻烦 12enum Color &#123;red, green, blue&#125;;int col = red; //col &#123;0&#125; 联合 union 实际占用空间就是它最大成员所占的空间，可以用来节约空间 同一时刻，union中只能保存一个成员的值 12345678910111213141516171819enum class Type &#123; ptr, num &#125;;union Value &#123; Node* p; int i;&#125;;struct Entry &#123; string name; Type t; Value v;&#125;;void f(Entry* pe)&#123; if (pe-&gt;t == Type::num) cout &lt;&lt; pe-&gt;v.i; //...&#125; 避免使用“裸”union;将其与类型字段一起封装在一个类中 使用标准库类型variant可以消除大多数需要直接使用unionvariant更简单，安全 1234567891011struct Entry &#123; string name; variant&lt;Node*,int&gt; v;&#125;;void f(Entry* pe)&#123; if (holds_alternative&lt;int&gt;(pe-&gt;v)) cout &lt;&lt; get&lt;int&gt;(pe-&gt;v); //...&#125; 模块化 一个C++程序包含许多独立开发的部分，例如函数、用户自定义类型、类层次、 模板为了让这些独立开发的部分在其他地方使用（类似于函数的声明），我们使用模块化的方法 区分声明(用作接口)和定义(用作实现) 分离编译 头文件 在C++中，接口文件后缀名为.h,里面应该包括函数的声明 实现接口函数的文件后缀名为.cpp,为了帮助编译器保持一致性，同样应该包含提供接口的.h文件 要使用这个头文件的函数，就需要在头文件中包含&quot;xxx.h&quot; 使用#include及头文件实现模块化是一种传统方法，它具有明显的缺点。 编译时间：不同的文件每一次include不同的头文件编译器都要处理一次 依赖顺序：先include的头文件的定义与宏可能会影响后一个的代码的含义 不协调：可能会出现类似下面的问题 我们有意无意地在两个源文件中定义了同一个实体的时候 不同源文件引用头文件的顺序不一致的时候 传染性：一个文件(1)包含的头文件(2)会包含其他这个文件(1)不需要的头文件，以此类推会导致代码膨胀且冗余 避免在头文件中定义非内联函数不要在头文件中使用 using 指令 模块 写法1：将class export并表示成声明的形式，就和.h写法差不多 12345678910111213141516171819202122232425export module Vector;export class Vector &#123; public: Vector(int s); double&amp; operator[](int i); int size(); private: double* elem; int sz;&#125;;Vector::Vector(int s) : elem&#123;new double[s]&#125;, sz&#123;s&#125; &#123;&#125;double&amp; Vector::operator[](int i) &#123; return elem[i]; &#125;int Vector::size() &#123; return sz; &#125;export bool operator==(const Vector&amp; v1, const Vector&amp; v2) &#123; if (v1.sieze() != v2.size()) return false; for (int i = 0; i &lt; v1.size(); i++) if (v1.elem[i] != v2.elem[i]) return false; return true;&#125; 写法2：函数export的就是可见的，没有export的就是不可见的(类似java) module Vector接口形式，后缀名为.cppm import Vector使用Vector export module Vector定义Vector 模块在维护性与编译时间方面的改进非常显著 命名空间 用 namespace 命名空间名 {} 用 :: 访问 表达某些声明是属于一个整体的 表明它们的名字不会与其他命名空间中的名字冲突 真正的main()（不是自己定义的命名空间里的） 用 using 声明将命名空间中的名字放进作用域,可以降低可读性 1234567void my_code(vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y) &#123; using std::swap; // 将标准库的swap放进作用域 //... swap(x, y); // std::swap() other::swap(x, y); // 某个其他的swap() //...&#125; 使用标准库命名空间中所有名称的访问权 using namespace std; 用以上方式使用命名空间指令不会影响使用模块的用户，影响仅限于模块内部 函数参数与返回值 函数之间传递信息有三种路径： 参数 全局变量 类对象中的共享状态 在函数的信息传递中，我们应考量： 对象是被复制的还是共享的？ 这个共享对象是否可被修改？ 这个对象是否被移动，从而留下了一个空对象？ 参数传递 默认情况复制(传值)/直接指向引用(传引用)/直接只读const&amp; 拥有默认值的函数参数可以达到和重载函数一样的效果 123void print(int value, int base = 10);print(x,8);print(x);//默认十进制 1234567void print(int value, int base)&#123; //...&#125;void print(int value)&#123; print(int value, 10);&#125; 返回值 返回值的默认行为是复制 返回引用的情况只应当出现在返回的内容不属于函数局部的时候(注意数组) 局部变量在函数返回的时候消失，因此我们不应当返回它的引用或者指针 对于较大的对象构造移动方法来极大地减少复制开销 编译器会优化复制行为，叫做省略复制优化 使用指针返回大对象的代码性能不会比使用引用返回的函数好，不要使用这样的代码 1234567891011Matrix* add(const Matrix&amp; x, const Matrix&amp; y) &#123; Matrix* p = new Matrix; //.... return p;&#125;Matrix m1, m2;//...Matrix* m3 = add(m1, m2); // 只复制指针//...delete m3; // 很容易忘记 返回类型推导 使用 auto 关键字 auto mul(int i, double d) &#123; return i*d; &#125; 返回类型后置 有的时候，我们需要先看到参数，然后决定返回值的类型。 这包括但不限于返回类型推导这种情形，这个问题与命名空间、匿名函数、概念都有一定的联系 使用 auto 关键字，表示返回值会在后面提到 auto mul(int i, double d) -&gt; double &#123; return i*d; &#125; 使用这种记法能够更有效地实现代码对齐 auto next_elem -&gt; Elem*; auto exit(int) -&gt; void; auto sqrt(double) -&gt; double; 不要过度使用返回类型推断 结构化绑定 把类对象成员赋予局部变量名称的机制 使用 {s, i} 构造 使用 [n, v] 读取(“解包”) 123456789101112131415struct Entry &#123; string name; int value;&#125;;Entry read_entry(istream&amp; is) // 简单地读函数&#123; string s; int i; is &gt;&gt; s &gt;&gt; i; return &#123;s, i&#125;;&#125;auto [n, v] = read_entry(cin);cout&lt;&lt;n&lt;&lt;&#x27; &#x27;&lt;&lt;v&lt;&lt;&#x27;\\n&#x27;; 对完全没有私有数据的类使用结构化绑定时，绑定行为是明显的：提供的名称数量必须与数据成员的数量相等，每一个绑定名称对应一个成员变量 12345678910map&lt;string, int&gt; m;//...for (const auto [key, value] : m) &#123; cout &lt;&lt; key &lt; &#x27; &#x27; &lt;&lt; value &lt;&lt; &#x27;\\n&#x27;;&#125;auto incr(map&lt;string, int&gt;&amp; m) -&gt; void &#123; for (auto&amp; [key, value]) value++;&#125; 结构化绑定也可以用于处理需要通过成员函数访问对象数据的类（?） complex&lt;double&gt; z = &#123;1,2&#125;; auto [re,im] = z+2; 不要过度使用结构化绑定","categories":[{"name":"cpp","slug":"cpp","permalink":"http://example.com/categories/cpp/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"}],"author":"tugumineko"},{"title":"python图像处理","slug":"python图像处理","date":"2024-05-06T08:31:57.000Z","updated":"2024-06-30T14:09:35.521Z","comments":true,"path":"2024/05/06/python图像处理/","permalink":"http://example.com/2024/05/06/python%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/","excerpt":"","text":"python图像处理 详见文档Pillow:Python-Imaging-Library这里使用的是Image模块 图像属性 format属性 string or None 标识了图像格式，如果图像不是从文件读取它的值就是None mode属性 string 注：如果一个图片的颜色格式为srgb，则说明这张图片存储的颜色值是encoder gamma之后的颜色值 sRGB标准： 人眼对亮度的感知不是线性的， 其对较暗区域的变化更加敏感，参见 Computer Color is Broken 基于人眼该特点，sRGB标准要求图像（各通道为8bits,最多存储256个亮度值）使用encoder gamma,把更多的空间用来存储更多暗部区域，来最大化地利用表示亮度的数据位或带宽。 size属性 (width,height) 图像的尺寸，按照像素数计算 palette属性 palette or None 颜色调色板表格，只对模式为&quot;P&quot;的图像返回Image Palette info属性 dictionary 存储图像相关数据的字典 12345678from PIL import Imageim = Image.open(&quot;personal/1.png&quot;)print(im.format)print(im.mode)print(im.size)print(im.palette)print(im.info)im.show() PNG RGBA (1920, 1200) None &#123;'srgb': 0, 'gamma': 0.45455, 'dpi': (119.9896, 119.9896)&#125; 构建图像 Image.open(fp,mode) 123from PIL import Image im = Image.open(&quot;personal/21.jpg&quot;,&quot;r&quot;)im.show() 需要知道的是在win的环境下im.show的方式为win自带的图像显示应用。打开并确认给定的图像文件。这个是一个懒操作；该函数只会读文件头，而真实的图像数据直到试图处理该数据才会从文件读取（调用load()方法将强行加载图像数据）。如果变量mode被设置，那必须是“r”。用户可以使用一个字符串（表示文件名称的字符串）或者文件对象作为变量file的值。文件对象必须实现read()，seek()和tell()方法，并且以二进制模式打开。 Image.new(mode,size,color=0) 123from PIL import Image,ImageColorim = Image.new(&#x27;RGB&#x27;,(200,200),color=&quot;red&quot;)im.show() Image.fromarray(obj,mode=None) obj-数组接口对象 mode-不自动判断 123456from PIL import Imageimport numpy as nparr = (np.eye(300)*255) # 二维数组im = Image.fromarray(arr) # 转换为图像im.show() 12345678910111213141516from PIL import Imageimport numpy as npimage = Image.open(&quot;personal/21.jpg&quot;)image1 = image.resize((200,200)) # resizedata = image1.getdata() # 转换为数组序列print(list(data)) # 查看具体数据需要使用 list() 转换obj = []for t in data: obj.append([sum(t) / 3]) # 灰度方法：RGB三个分量的均值# 变成 200 * 200 的二维数组obj = np.array(obj).reshape((200,200))print(obj)im = Image.fromarray(obj)im.show() [[223. 222.66666667 222. ... 240.66666667 240.66666667 240.66666667] [222.66666667 222.66666667 221.66666667 ... 240.66666667 241. 240.66666667] [222.33333333 221.66666667 221.33333333 ... 240.66666667 240.66666667 240.33333333] ... [120.33333333 118.33333333 145.66666667 ... 216.66666667 189. 189.33333333] [119. 133.33333333 166. ... 205. 188. 190. ] [125.33333333 162.66666667 163. ... 196.33333333 188.33333333 190. ]] 输出如下： 图像处理 图像混合 透明度混合 Image.blend(im1,im2,alpha) im1:Image对象，透明度为(1-alpha) im2:Image对象，透明度为(alpha) alpha:透明度(0~1). 注意：im1和im2的大小必须一样，且模式为RGB 123456from PIL import Imageim1 = Image.open(&#x27;personal/10.jpg&#x27;).convert(mode=&#x27;RGB&#x27;)im2 = Image.new (&#x27;RGB&#x27;,im1.size,&#x27;blue&#x27;)im1.show()Image.blend(im1,im2,0.2).show() 效果如下图所示： 遮罩混合 Image.composite(im1,im2,mask) 均为Image对象，使用mask来混合im1和im2 这里三个Image对象的size和mode都必须相同 12345678910from PIL import Imageim1 = Image.open(&#x27;personal/7.jpg&#x27;)im2 = Image.open(&#x27;personal/14.jpg&#x27;)print(im1.mode)print(im2.mode)print(im1.size)print(im3.size)r, g, b = im2.split()Image.composite(im1,im2,b).show() RGB RGB (3840, 2160) (3840, 2160) 效果如下图所示： 图像缩放 按像素缩放 Image.eval(im,fun) 第一个为Image对象 第二个为一个方法（函数），该函数传入一个参数，即像素点。 该函数会对图片中每个像素点进行函数内的操作 1234567891011from PIL import Imageim = Image.open(&quot;personal/hira.png&quot;)# lambda 表达式Image.eval(im,lambda x:x*2).show()# func 表达式def func(x): return x*1.5Image.eval(im,func).show() 效果如下图所示：(1倍/1.5倍/2倍) 按尺寸缩放 Image.thumbnail() 不同于前面直接通过Image调用方法，而是使用Image的具体实例im调用thumbnail方法 这里缩放图像并不会对图像进行变形，即显示效果是一样的。 12345678910from PIL import Imageim1 = Image.open(&quot;personal/11.jpg&quot;)im2 = im1.copy()# 将复制后的图像进行缩放，传入一个元组im2.thumbnail((1024,1024))im2.show()print(&quot;im1的大小&quot;, im1.size)print(&quot;im2的大小&quot;, im2.size) im1的大小 (2156, 3291) im2的大小 (671, 1024) 图像的剪切与粘贴 图像粘贴 Image.paste(im,box,mask=None) Image的具体实例调用方法 im为Image对象，box为要粘贴的区域，mask为遮罩。 box参数有三种形式: (x1,y1):将im左上角对齐(x1,y1)点，其余部分粘贴，剩余部分抛弃 (x1,y1,x2,y2):将im粘贴至此区域 None:此时im必须与原图像大小一致 图像剪裁 Image.crop(box) 123456from PIL import Imageim1 = Image.open(&quot;personal/111.PNG&quot;) im2 = Image.open(&quot;personal/image_6.png&quot;)im1_crop = im1.crop((0, 0, 671, 1024))im2.paste(im1_crop,(200,0))im2.show() 效果如图所示： 其他 转换图像格式 将.png转换为.jpg,注意：不能将RGBA转化为.jpg 123456from PIL import Imageim = Image.open(&quot;personal/10.png&quot;,&quot;r&quot;)print(im)im.save(&quot;personal/10.jpg&quot;) # 将.png转化为.jpgim = Image.open(&quot;personal/10.jpg&quot;,&quot;r&quot;)print(im.format,im.size,im.mode) &lt;PIL.PngImagePlugin.PngImageFile image mode=RGB size=1920x1080 at 0x255C7FE22E0&gt; JPEG (1920, 1080) RGB","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"数字图像处理","slug":"数字图像处理","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"author":"tugumineko"},{"title":"冒泡排序曲线的推导","slug":"A-Rigorous-Derivation-of-the-Bubble-Sort-Curve","date":"2024-05-05T04:42:10.000Z","updated":"2024-05-05T11:42:08.289Z","comments":true,"path":"2024/05/05/A-Rigorous-Derivation-of-the-Bubble-Sort-Curve/","permalink":"http://example.com/2024/05/05/A-Rigorous-Derivation-of-the-Bubble-Sort-Curve/","excerpt":"","text":"冒泡排序 遍历一组数字以相邻交换的方式找到这一组数字的最值的排序方式 这里讨论的是从小到大的排序 冒泡排序曲线 给出定义 假设：在完全均匀且随机打乱一组数字的情况下进行冒泡排序，将数字的大小以柱的高度表示，在不同的时间下会生成不同的形状。假设这一形状可以用一个近似函数来表示，这个函数的曲线就是冒泡排序曲线。 建立模型 为方便表示：我们设置这张图片的长和宽均为单位1，给定变量时间t，当t=0时，为随机打乱的状态；当t=1时，为排序完成的状态 t=0 t=1 这样，就可以建立一个关于x和t的二元函数 f(x,t)={xx&gt;1−t???x≤1−tf(x, t)=\\left\\{\\begin{array}{ll}x &amp; x&gt;1-t \\\\???&amp; x \\leq 1-t\\end{array}\\right. f(x,t)={x???​x&gt;1−tx≤1−t​ 显然，图像分为两部分： 当x大于1-t的时候，函数值为其本身。 我们需要推导，当x小于1-t的时候的函数值。 所以第一部分的曲线呢？ 推导曲线 关键在于 因为冒泡排序每一次遍历只改变相邻元素，前n项元素在经过相同次数的遍历的情况下的形状是不变的，由于我们设置了单位宽–&gt;这一部分的曲线只随t的增长而横向拉伸 数据是完全均匀且随机打乱的，所以即使它们的数据不完全相同，它们形成的弧线也都是相同的–&gt;在数据量不同的情况下，取前n项元素在拉伸前有相同的形状 推导过程 我们在t的两个不同值处绘制函数，记为f(x,a)f(x, a)f(x,a)和f(x,b)f(x, b)f(x,b) 为了利用先前推导出的性质，我们将图像t较大的一方进行拉伸 由于函数是连续的，所以我们可以知道该点坐标为(1−a,1−a)(1-a,1-a)(1−a,1−a)–&gt;f(1−a,a)=1−af(1-a,a)=1-af(1−a,a)=1−a 令t从1到0呈线性变化，我们得到了推导式f(1−a,a)=1−af(1-a,a)=1-af(1−a,a)=1−a 代入到f(x⋅ba,b)f(x\\cdot \\frac{b}{a},b)f(x⋅ab​,b)中，在进行压缩，就得到了函数图像。 推导过程如下 在f(x⋅ba,b)=f(x,a),x≤1−a中，令x=1−a,则有：在f(x\\cdot \\frac{b}{a}, b)=f(x,a),x\\le1-a中， 令 x = 1-a,则有： 在f(x⋅ab​,b)=f(x,a),x≤1−a中，令x=1−a,则有： f((1−a)⋅ba,b)=f(1−a,a)=1−a.f((1-a)\\cdot \\frac{b}{a}, b)=f(1-a,a)=1-a. f((1−a)⋅ab​,b)=f(1−a,a)=1−a. 令x=(1−a)⋅ba,t=b，则有：a=tx+t令x=(1-a)\\cdot \\frac{b}{a},t=b，则有： a=\\frac{t}{x+t} 令x=(1−a)⋅ab​,t=b，则有：a=x+tt​ 所以f(x,t)={xx&gt;1−txx+tx≤1−t所以f(x, t)=\\left\\{\\begin{array}{ll}x &amp; x&gt;1-t \\\\\\frac{x}{x+t} &amp; x \\leq 1-t\\end{array}\\right. 所以f(x,t)={xx+tx​​x&gt;1−tx≤1−t​","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"tugumineko"},{"title":"PyTorch深度学习","slug":"PyTorch深度学习","date":"2024-05-04T16:38:25.000Z","updated":"2024-11-03T12:06:12.743Z","comments":true,"path":"2024/05/05/PyTorch深度学习/","permalink":"http://example.com/2024/05/05/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"PyTorch深度学习 神经网络 层层组成，多达几百层或者上千层的叫作深度神经网络。从海量的数据中进行处理和分析，提炼出物体的特征，建立模型，从而实现处理大量数据，解决复杂的任务。 架构：每个数据与不同权重相乘后加和，加上偏差后激活再将结果传入下一个神经网络。 构建一个神经网络需要下面五个步骤： 准备数据 定义模型 训练模型 评估预测 做出预测 那么我们怎么高效快速地完成上述五个步骤呢？ 卷积神经网络CNN(Convolution Neural Networks) 例：LeNet-5 PyTorch是一款流行的深度学习框架，有着丰富的工具包 利用PyTorch识别数字 准备数据：计算机将图片进行分割，将图片转化成数字信息 定义模型： 卷积层：把图像变为一系列数据范围为0~1的矩阵。 池化层：把一张很大的图像压缩，变成一张更小更容易计算的图像矩阵。 全连接层：把处理后的图像转化成一段数据。 训练模型： 将训练数据输入模型并计算损失并调整更新参数。重复进行多个周期后直到模型能够很好地识别数字。 损失函数：交叉熵损失(Cross Entropy Loss) 优化器：随机梯度下降(SGD) 评估模型+预测 卷积层(Convolutions):提取特征 池化层(Subsampling):将特征提取到最突出的元素 全连接层(Full connection):最后OUTPUT为一个十维向量，每一维代表一个数字类别的预测概率 PyTorch实操 验证/安装pytorch 12import torchprint(torch.__version__) # torch.__version__ 返回安装的 PyTorch 的版本号 2.3.0+cpu 准备数据 数据下载：将数据变为适合神经网络模型训练的格式 加载数据：经过预处理，使得数字都位于图像的中心位置，手写数据分类 12345678from torchvision.datasets import MNISTfrom torchvision.transforms import ToTensor# 定义保存或加载数据集的位置path = &#x27;~/.torch/datasets/mnist&#x27;# 下载并定义数据集train = MNIST(path, train=True, download=True, transform=ToTensor())test = MNIST(path, train=True, download=True, transform=ToTensor()) 处理图像数据 PIL图像：以像素数组的形式保存，每个像素点数字范围为0~1，这样就会有无限的精度 123456789101112131415from PIL import Imageimport torchvision.transforms as transforms# Load the image using PILimage_path = &#x27;./personal/1.png&#x27;image = Image.open(image_path)# Convert the image to a PyTorch tensortransform = transforms.ToTensor()tensor = transform(image)print(image)# Check the tensor shape to confirm conversiontensor.shape, tensor.dtype # (torch.Size([3, 1024, 1024]), torch.float32) &lt;PIL.PngImagePlugin.PngImageFile image mode=RGBA size=1920x1200 at 0x1B6D50F8F10&gt; (torch.Size([4, 1200, 1920]), torch.float32) 数据集划分: 将数据划分为更小的batch(子数据集),增加处理大量数据的效率 通过枚举的方式进行训练 1234# 定义如何枚举数据集from torch.utils.data import DataLoadertrain_dl = DataLoader(train, batch_size=64, shuffle=True)test_dl = DataLoader(test, batch_size=1024,shuffle=False) 定义模型 特征提取 卷积：将矩阵和一组权重相乘，生成一个新的二维数组 卷积核(kernel),对某个局部的加权求和，决定了权重矩阵 特征图(feature map),一个特征图对应一个图像的一个特征 不同的卷积核和同一个卷积组合，生成了不同的特征图，这些二维的特征图实际上实现了一个三维的卷积层。层数越高，可以识别的特征越高级 层与层之间会有若干个卷积核，上一层的每个特征图跟每个卷积核做卷积，都会产生下一层的一个特征图 输入的特征图也可以是多个，例如RGB 池化： 逐渐缩小表示空间的大小以提高计算效率 会单独对每个特征图进行运算 常用方法：最大池化 全连接层： 对前面卷积层提取的特征进行整合，以进行最终的分类决策 将前一层的所有神经元与当前层的每个神经元相连接，从而使网络能够理解并学习到图像更加复杂的特征 定义继承自Module父类的类CNN 建立方法__init__ 第一个卷积层使用Conv2d创建二维卷积层，接收n_channels个输入通道，输出32个特征图，使用3X3的卷积核进行卷积运算 使用kaiming_uniform_方法初始化权重(weight也称为参数)，并设置激活函数为relu (机器学习的关键是更新每次卷积的权重) 激活函数，做出是否要传递信息的决定门 第一个池化层将特征图分割成2X2大小的区域，并从每个区域中取最大值(最大池化) stride(2,2)是池化操作的步长 这意味着池化窗口每次移动两个像素，有效减少了特征图的维度 作用： 保留了最大特征的同时减少了尺寸 减少过拟合，减少泛化能力 第二层卷积层的作用是进一步提取池化层的特征，需要注意的是Conv2d的第一个参数由n_channels变成了32，这是因为这里的输入是第一层卷积层的输入 这意味着我们从32个3x3的卷积核中进行操作，并将从每个位置的3x3区域提取特征，并输出32个新的特征通道 第二层池化的作用： 通过减少特征图的空间尺寸，来降低后续网络层的计算负载 在一定程度上增强模型的抗噪声能力 通过这两层的连续操作，我们的CNN能够逐渐抽象图像内容，将原始输入转化为高级特征，从而对后续的分类或其他任务提供必要的信息 第一个全连接层将5x5x32个线索转化为100个有意义的概念 使用kaiming_uniform来初始化这个处理中心的连接权重 RELU激活函数引入了一种非线性的思考方式，让神经网络捕捉到更加复杂的模式和联系 第二个全连接层将提炼出的100个概念进一步简化为10个最终的决策，每一个决策都对应着一个手写数字的类别（0~9） 使用xavier_uniform_的方法来初始化每个连接的权重 使神经网络的网既不是太紧也不是太松–权重适中，柔韧性与强度兼得 如果权重过大–神经网络僵硬，难以捕捉细微的特征 如果权重过小–神经网络松散，容易错过重要的模式 xavier_uniform_通过初始化权重为一个均匀分布的值，帮助神经网络一开始时就保持了一种平衡状态 Softmax为激活函数，它将决策中心的输出转换为概率分布。使神经网络能够根据概率最高的类别来做出最终的预测 123456789101112131415161718192021222324252627from torch.nn import Moduleclass CNN(Module): # 定义模型属性 def __init__(self, n_channels): super().__init__() # 输入到卷积层 1 self.hidden1 = Conv2d(n_channels, 32, (3,3)) kaiming_uniform_(self.hidden1.weight, nonlinearity=&#x27;relu&#x27;) self.act1 = ReLU() # 池化层 1 self.pool1 = MaxPool2d((2,2), stride=(2,2)) # 卷积层 2 self.hidden2 = Conv2d(32, 32, (3, 3)) kaiming_uniform_(self.hidden2.weight, nonlinearity=&#x27;relu&#x27;) self.act2 = ReLU() # 池化层 2 self.pool2 = MaxPool2d((2,2), stride(2,2)) # 全连接层 1 self.hidden3 = Linear(5*5*32, 100) kaiming_uniform_(self.hidden3.weight, nonlinearity=&#x27;relu&#x27;) self.act3 = RELU() # 全连接层 2 self.hidden4 = Linear(100, 10) xavier_uniform_(self.hidden4.weight) self.act4 = Softmax(dim=1) 前向传播 定义 指数据在神经网络中的流动方向 输入层 -&gt; 隐藏层 -&gt; 输出层 在卷积神经网络中起到关键作用 目的 计算输出: 根据输入数据和网络结构计算神经网络的输出 损失函数评估: 使用输出数据与真实标签计算损失函数，以评估模型的性能 反向传播准备: 为反向传播阶段提供必要的中间信息，如每层的输入、权重和激活函数的导数等 反向传播 目的是计算损失函数关于网络参数的梯度，以便通过梯度下降等优化算法更新网络的权重，从而改进模型的性能 前向传播是路径上执行具体的数据处理，执行层与层之间的数据传递和参数计算 而模型架构则是定义了前向传播的路径和操作顺序 将数据进行输入进入第一层卷积层进行处理，然后通过激活函数后再进行进一步的池化操作 数据经过进一步的提取特征，减少体积操作。例如特征图体积从(32,15,15)变为(32,7,7) 数据扁平化(Flattening): 将多维的数据结构转化为一维向量形式，使其能够被神经网络处理 全连接层 self.hidden3(X) 将扁平化后的数据传入后，将输入向量与权重矩阵相乘，加上偏置，然后输出结果。 12345678910111213141516171819# 前向传播def forward(self, X): # 输入到隐层 1 X = self.hidden1(X) X = self.act1(X) X = self.pool1(X) # 隐层 2 X = self.hidden2(X) X = self.act2(X) X = self.pool2(X) # 扁平化 X = X.view(-1, 5*5*32) # 隐层 3 X = self.hidden3(X) X = self.act3(X) # 输出层 X = self.hidden4(X) X = self.act4(X) return X 损失函数 提供了一个预测结果和真实结果差距有多大的测量标准 优化器 根据损失函数提供的反馈来调整模型参数 决定了如何以最有效的方式更新参数以最小化损失函数 最小梯度下降 最基本 在处理复杂损失面的情况下可能陷入收敛慢或局部最优 Adam优化器 通过自适应学习率标准，常能更快地收敛到全局最优或者较优的解 下面使用交叉熵损失函数和随机梯度下降作为优化器 交叉熵损失函数 分类问题中常用的损失函数 衡量了预测概率分布和实际标签分布之间的差异 可以有效处理概率输出，并且在数学上可以解释为最大似然估计 随机梯度下降优化器 model.parameters() 表示优化器将更新所有模型的运行参数 学习率(learning rate)决定了每次参数更新的步长大小 动量(momentum)通过在更新方向上加速，帮助优化器在鞍点附近更快收敛，并减小震荡 训练周期 epoch 一个epoch指模型训练时一次完整的前向传播和反向传播的过程 多次遍历可以使模型更好地学习数据的特征 训练损失 Train Loss 模型在训练数据集上的平均损失值 训练损失越低，表示模型对训练数据的拟合度越好 训练准确率 Train Acc 衡量模型在训练数据集上预测正确的比例 测试准确率 Test Acc 衡量模型在测试数据集上预测正确的比例 可以很真实地反应模型对未知数据的泛化能力 minibatch 有利于模型的稳定训练，提高计算效率 每个minibatch包含输入数据(inputs)和对应的标签(targets) 123456789101112131415161718def train_model(train_dl, model): # 定义优化器 criterion = CrossEntropyLoss() optimizer = SGD(model.parameters(),lr=0.01,momentum=0.9) # 枚举 epochs for epoch in range(10): # 枚举 mini batches for i, (inputs, targets) in enumerate(train_dl): # 梯度清除 optimizer.zero_grad() # 计算模型输出 yhat = model(inputs) # 计算损失 loss = criterion(yhat,targets) # 贡献度分配 loss.backward() # 升级模型权重 optimizer.step() 评估模型 评估误差: 均方误差 (MSE, Mean Squared Error) 预测值与实际值之间的平均均方误差 均方根误差 (RMSE,Root Mean Squared Error) RMSE=MSERMSE = \\sqrt{MSE} RMSE=MSE​ 平均绝对误差 (MAE, Mean Absolute Error) 拟合优度 值越接近1，模型的解释能力越强 评估指标 对于分类模型而言，评估指标只要衡量模型的分类效果 混淆矩阵G (Confusion Matrix) 包括TP、TN、FP、FN TP (True Positive):被判定为正样本，实际上是正样本 -&gt; 真阳性 FN (False Negative):被判定为负样本，实际上是正样本 -&gt; 假阴性 FP (False Positive):被判定为正样本，实际上是负样本 -&gt; 假阳性 TN (True Negative):被判定为负样本，实际上是负样本 -&gt; 真阴性 ROC曲线 (Receiver Operating Characteristic Curve) 横轴表示的是 FPR ,即错误地预测为正例的概率 纵轴表示的是 TPR ,即正确地预测为正例的概率 FPR=FPFP+TNFPR = \\frac {FP} {FP+TN} FPR=FP+TNFP​ TPR=TPTP+FNTPR = \\frac {TP} {TP+FN} TPR=TP+FNTP​ AOC (Area Under the Curve) 衡量的是ROC曲线下的面积 AOC越大，表示当前的分类算法，就越有可能将正样本排在负样本前面，模型的分类性能越好 准确率 (Accuracy) Accuracy=TP+TNTP+TN+FP+FNAccuracy = \\frac {TP+TN}{TP+TN+FP+FN} Accuracy=TP+TN+FP+FNTP+TN​ 精确率 (Precision) 衡量模型预测为正类的样本中，实际为正类的比率 适用于假阳性比例较高的情况 Precision=TPTP+FPPrecision = \\frac {TP}{TP + FP} Precision=TP+FPTP​ 召回率 (Recall) 衡量模型预测为负类的样本中，实际为负类的比率 适用于假阴性比例较高的情况 Recall=TPTP+FNRecall = \\frac {TP}{TP+FN} Recall=TP+FNTP​ F1分数 一般公认的结合精确率和召回率的指标 F1Score=2⋅Precision⋅AccuracyPrecision+AccuracyF1 Score = \\frac {2\\cdot{Precision}\\cdot{Accuracy}} {Precision + Accuracy} F1Score=Precision+Accuracy2⋅Precision⋅Accuracy​","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"author":"tugumineko"},{"title":"markdown-syntax","slug":"markdown-syntax","date":"2024-04-29T10:35:23.000Z","updated":"2024-05-23T11:53:09.248Z","comments":true,"path":"2024/04/29/markdown-syntax/","permalink":"http://example.com/2024/04/29/markdown-syntax/","excerpt":"","text":"注： 点击run查看效果 Markdown 标题语法 #的数量代表了标题的级别 Heading level 1 Heading level 2 Heading level 3 Heading level 4 Heading level 5 Heading level 6 ==标识一级标题，–标识二级标题(两个及两个以上) Heading level 1 Heading level 2 段落，请使用空白行将一行或多行文本进行分割,但是间距是固定的。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. 换行，在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. &lt;br&gt;也可以换行 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. Markdown 强调语法 粗体，两个星号**或__ 斜体，一个星号*或_ -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. Markdown 引用语法 块引用，请在段落前添加一个 &gt; 符号。 块引用可以包含多个段落。为段落之间的空白行添加一个 &gt; 符号。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. 块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. Markdown 列表语法 有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。(列表只会按照12345的顺序进行) 同一序号的需使用换行符。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. 无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. 与引用块结合使用。也会达到缩进效果。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. 代码块 代码块通常采用四个空格或一个制表符缩进。当它们被放在列表中时，缩进八个空格或两个制表符。但是这样会造成多重缩进。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. -I'm you. So am I GOD?? -No, as Jesus said, *you are just not only a bitch, but also son of a bitch.* -😅Yes, you are right. Fuck the **Jesus**. -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. Markdown 围栏代码块 受保护的代码块(不缩进),根据Markdown处理器或编辑器的不同，您将在代码块之前和之后的行上使用三个反引号（(```）或三个波浪号（~~~）。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. 123-I&#x27;m you. So am I GOD??-No, as Jesus said, *you are just not only a bitch, but also son of a bitch.*-😅Yes, you are right. Fuck the **Jesus**. 图片 见markdown图片语法 Markdown 代码语法 要将单词或短语表示为代码，请将其包裹在反引号 (`) 中。 代码语法和代码块的显示是不一样的。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. Markdown 分隔线语法 在单独一行上使用三个或多个星号 (**)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。为了兼容性，请在分隔线的前后均添加__空白行__. -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. Markdown 链接语法 超链接Markdown语法代码：[超链接显示名](超链接地址 &quot;超链接title&quot;)(链接title可选)(链接地址要写完整) 这是一个链接 Hello World。 使用尖括号&lt;&gt;https://tugumineko.github.io/ 强调链接, 在链接语法前后增加星号。 要将链接表示为代码，请在方括号中添加反引号。 This is Hello World. This is Hello World. This is Hello World. 为了兼容性，在写链接时请尽量使用%20代替空格。 Markdown 图片语法 代码格式![图片alt](图片链接 &quot;图片title&quot;) 对应的HTML代码：&lt;img src=&quot;图片链接&quot; alt=&quot;图片alt&quot; title=&quot;图片title&quot;&gt; Markdown 转义字符语法 要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \\ 在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要使用这些符号，你必须要使用实体的形式，像是 &amp;lt; 和 &amp;amp;。 兼容html的常用语法 删除线，一个或两个波浪~~ 下划线，&lt;u&gt;&lt;/u&gt; 上标 ，&lt;sup&gt;&lt;/sup&gt; 下标，&lt;sub&gt;&lt;/sub&gt; 小号字体，&lt;small&gt;&lt;/small&gt; 大号字体，&lt;big&gt;&lt;/big&gt; 文本高亮，&lt;mark&gt;&lt;/mark&gt; violantis主题特有的标签插件 传送门 使用标签插件时,若要换行，请使用html语法&lt;br&gt;,出现:时要使用反斜杠\\","categories":[{"name":"markdown","slug":"markdown","permalink":"http://example.com/categories/markdown/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}],"author":"tugumineko"},{"title":"素晴らしき日々～不連続存在～","slug":"素晴らしき日々","date":"2023-12-23T03:36:27.000Z","updated":"2024-05-05T05:09:12.149Z","comments":true,"path":"2023/12/23/素晴らしき日々/","permalink":"http://example.com/2023/12/23/%E7%B4%A0%E6%99%B4%E3%82%89%E3%81%97%E3%81%8D%E6%97%A5%E3%80%85/","excerpt":"","text":"世界是没有意义的。婴儿哭着来到这个世界,又不可避免地注定死亡。人的奋斗，人的情感，人的财产，人的选择对于这一切毫无意义。因此，我们不知道死亡的意义，我们无比惧怕死亡，可是无论是化身救世主，还是试图走到世界的尽头与亡者相见，死亡终会到来，我们无法愿终。世界上没有救世主，人类没有意义，世界毫无意义。 世界是有界限的。因为万物皆生，一切有限，终将回归与此。水天一色，天空回转，不可到达终点。世上没有世界末日，我们也不可回归天空。当我们无限存在于世界，美好的每一天也终将索然无味。世界没有尽头，可无限最终回归界限。无论有没有终之空，世界都是有界限的。 我们竭力渴求天空的终点，不顾一切地追求死亡的真相，这是没有意义的，因为真相存在于世界之外。世界是有界限的，世界又没有意义。尽管如此，人脑比天空更宽广，比海洋更宽阔。母亲使间宫卓司生于皆木，皆木使水上由岐生于自我之上，羽咲使皆木战胜自我而重生。也许PTSD而生的多重人格会带来无尽的痛苦，可对于皆木来说，由岐的帮助，镜和司的回忆，与卓司的对峙，一切都是真实的。人的意义不会因为世界而改变，可人的意识可以改变世界，最终战胜一切，甚至回归天空。人的意识不仅存在于世界，也存在于清明梦，更重要的是，它存在于需要你的人的精神之中。痛苦的不仅是你自己，而是大家啊，是这个世界啊。万物轮回，向死而生，可精神永存。真相，确实存在于世界之外，可并非无法触及。 人啊，幸福地活下去吧！尽管世界没有意义，我们也要做好每一个选择，体会每一丝情感，守护我们的美好，度过美好的每一天，就让我们永存的意识，这不连续的存在，去探求存在于世界之外的真相吧。","categories":[],"tags":[{"name":"黄油","slug":"黄油","permalink":"http://example.com/tags/%E9%BB%84%E6%B2%B9/"}],"author":"tugumineko"}],"categories":[{"name":"3DV","slug":"3DV","permalink":"http://example.com/categories/3DV/"},{"name":"CV","slug":"CV","permalink":"http://example.com/categories/CV/"},{"name":"CG","slug":"CG","permalink":"http://example.com/categories/CG/"},{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"cuda","slug":"cuda","permalink":"http://example.com/categories/cuda/"},{"name":"cv","slug":"cv","permalink":"http://example.com/categories/cv/"},{"name":"cg","slug":"cg","permalink":"http://example.com/categories/cg/"},{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"C","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"cpp","slug":"cpp","permalink":"http://example.com/categories/cpp/"},{"name":"vim","slug":"vim","permalink":"http://example.com/categories/vim/"},{"name":"markdown","slug":"markdown","permalink":"http://example.com/categories/markdown/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"3dgs","slug":"3dgs","permalink":"http://example.com/tags/3dgs/"},{"name":"渲染","slug":"渲染","permalink":"http://example.com/tags/%E6%B8%B2%E6%9F%93/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"游戏","slug":"游戏","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F/"},{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"Arduino","slug":"Arduino","permalink":"http://example.com/tags/Arduino/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"数字图像处理","slug":"数字图像处理","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"},{"name":"OS","slug":"OS","permalink":"http://example.com/tags/OS/"},{"name":"文本编辑器","slug":"文本编辑器","permalink":"http://example.com/tags/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"黄油","slug":"黄油","permalink":"http://example.com/tags/%E9%BB%84%E6%B2%B9/"}]}