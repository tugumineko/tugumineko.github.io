{"meta":{"title":"tugumineko","subtitle":"鶫ねこ","description":"鶫ねこ","author":"tugumineko","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2024-05-05T13:23:31.903Z","updated":"2024-05-05T13:23:31.903Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2024-05-05T05:04:05.176Z","updated":"2024-05-05T05:04:05.176Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"做题家 互联网魔怔人"},{"title":"我的朋友们","date":"2024-05-05T13:22:53.684Z","updated":"2024-05-05T13:22:53.684Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有分类","date":"2024-05-05T05:02:45.737Z","updated":"2024-05-05T05:02:45.737Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2024-05-05T05:03:28.430Z","updated":"2024-05-05T05:03:28.430Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vim-syntax","slug":"vim-syntax","date":"2024-05-23T11:44:41.000Z","updated":"2024-05-24T13:54:25.138Z","comments":true,"path":"2024/05/23/vim-syntax/","permalink":"http://example.com/2024/05/23/vim-syntax/","excerpt":"","text":"VIMTUTOR Lesson 1 SUMMARY The cursor is moved using either the arrow keys or the hjkl keys. h (left) j (down) k (up) l (right) To start Vim from the shell prompt type: vim FILENAME &lt;ENTER&gt; To exit Vim type: &lt;ESC&gt; :q! &lt;ENTER&gt; to trash all changes. OR type: &lt;ESC&gt; :wq &lt;ENTER&gt; to save the changes. To delete the character at the cursor type: x To insert or append text type: i type inserted text &lt;ESC&gt; insert before the cursor A type appended text &lt;ESC&gt; append after the line NOTE: Pressing &lt;ESC&gt; will place you in Normal mode or will cancel an unwanted and partially completed command. Lesson 2 SUMMARY To delete from the cursor up to the next word type: dw To delete from the cursor to the end of a line type: d$ To delete a whole line type: dd To repeat a motion prepend it with a number: 2w The format for a change command is: operator [number] motion where: operator - is what to do, such as d for delete [number] - is an optional count to repeat the motion motion - moves over the text to operate on, such as w (word), $ (to the end of line), etc. To move to the start of the line use a zero: 0 To undo previous actions, type: u (lowercase u) To undo all the changes on a line, type: U (capital U) To undo the undo’s, type: CTRL-R Lesson 3 SUMMARY To put back text that has just been deleted, type p . This puts the deleted text AFTER the cursor (if a line was deleted it will go on the line below the cursor). To replace the character under the cursor, type r and then the character you want to have there. The change operator allows you to change from the cursor to where the motion takes you. eg. Type ce to change from the cursor to the end of the word, c$ to change to the end of a line. The format for change is: c [number] motion Lesson 4 SUMMARY CTRL-G displays your location in the file and the file status. G moves to the end of the file. number G moves to that line number. gg moves to the first line. Typing / followed by a phrase searches FORWARD for the phrase. Typing ? followed by a phrase searches BACKWARD for the phrase. After a search type n to find the next occurrence in the same direction or N to search in the opposite direction. CTRL-O takes you back to older positions, CTRL-I to newer positions. Typing % while the cursor is on a (,),[,],{, or } goes to its match. To substitute new for the first old in a line type :s/old/new To substitute new for all 'old’s on a line type :s/old/new/g To substitute phrases between two line #'s type :#,#s/old/new/g To substitute all occurrences in the file type :%s/old/new/g To ask for confirmation each time add ‘c’ :%s/old/new/gc Lesson 5 SUMMARY :!command executes an external command. Some useful examples are: (MS-DOS) (Unix) :!dir :!ls - shows a directory listing. :!del FILENAME :!rm FILENAME - removes file FILENAME. :w FILENAME writes the current Vim file to disk with name FILENAME. v motion :w FILENAME saves the Visually selected lines in file FILENAME. :r FILENAME retrieves disk file FILENAME and puts it below the cursor position. :r !dir reads the output of the dir command and puts it below the cursor position. Lesson 6 SUMMARY Type o to open a line BELOW the cursor and start Insert mode. Type O to open a line ABOVE the cursor. Type a to insert text AFTER the cursor. Type A to insert text after the end of the line. The e command moves to the end of a word. The y operator yanks (copies) text, p puts (pastes) it. Typing a capital R enters Replace mode until &lt;ESC&gt; is pressed. Typing “:set xxx” sets the option “xxx”. Some options are: ‘ic’ ‘ignorecase’ ignore upper/lower case when searching ‘is’ ‘incsearch’ show partial matches for a search phrase ‘hls’ ‘hlsearch’ highlight all matching phrases You can either use the long or the short option name. Prepend “no” to switch an option off: :set noic Lesson 7 SUMMARY Type :help or press &lt;F1&gt; or &lt;Help&gt; to open a help window. Type :help cmd to find help on cmd . Type CTRL-W CTRL-W to jump to another window Type :q to close the help window Create a vimrc startup script to keep your preferred settings. When typing a : command, press CTRL-D to see possible completions. Press &lt;TAB&gt; to use one completion. VIMRC &quot; Comments in Vimscript start with a `&quot;`. &quot; If you open this file in Vim, it’ll be syntax highlighted for you. &quot; Vim is based on Vi. Setting `nocompatible` switches from the default &quot; Vi-compatibility mode and enables useful Vim functionality. This &quot; configuration option turns out not to be necessary for the file named &quot; ‘~/.vimrc’, because Vim automatically enters nocompatible mode if that file &quot; is present. But we’re including it here just in case this config file is &quot; loaded some other way (e.g. saved as `foo`, and then Vim started with &quot; `vim -u foo`). set nocompatible &quot; Turn on syntax highlighting. syntax on &quot; Disable the default Vim startup message. set shortmess+=I &quot; Show line numbers. set number &quot; This enables relative line numbering mode. With both number and &quot; relativenumber enabled, the current line shows the true line number, while &quot; all other lines (above and below) are numbered relative to the current line. &quot; This is useful because you can tell, at a glance, what count is needed to &quot; jump up or down to a particular line, by {count}k to go up or {count}j to go &quot; down. set relativenumber &quot; Always show the status line at the bottom, even if you only have one window open. set laststatus=2 &quot; The backspace key has slightly unintuitive behavior by default. For example, &quot; by default, you can’t backspace before the insertion point set with ‘i’. &quot; This configuration makes backspace behave more reasonably, in that you can &quot; backspace over anything. set backspace=indent,eol,start &quot; By default, Vim doesn’t let you hide a buffer (i.e. have a buffer that isn’t &quot; shown in any window) that has unsaved changes. This is to prevent you from &quot; &quot; forgetting about unsaved changes and then quitting e.g. via :qa!. We find &quot; hidden buffers helpful enough to disable this protection. See :help hidden &quot; for more information on this. set hidden &quot; This setting makes search case-insensitive when all characters in the string &quot; being searched are lowercase. However, the search becomes case-sensitive if &quot; it contains any capital letters. This makes searching more convenient. set ignorecase set smartcase &quot; Enable searching as you type, rather than waiting till you press enter. set incsearch &quot; Unbind some useless/annoying default key bindings. nmap Q \\&lt;Nop&gt; &quot; ‘Q’ in normal mode enters Ex\\ mode. You almost never want this. &quot; Disable audible bell because it’s annoying. set noerrorbells visualbell t_vb= &quot; Enable mouse support. You should avoid relying on this too much, but it can &quot; sometimes be convenient. set mouse+=a &quot; Try to prevent bad habits like using the arrow keys for movement. This is &quot; not the only possible bad habit. For example, holding down the h/j/k/l keys &quot; for movement, rather than using more efficient movement commands, is also a &quot; bad habit. The former is enforceable through a .vimrc, while we don’t know &quot; how to prevent the latter. &quot; Do this in normal mode… nnoremap \\&lt;Left&gt; :echoe &quot;Use h&quot;\\&lt;CR&gt; nnoremap \\&lt;Right&gt; :echoe &quot;Use l&quot;\\&lt;CR&gt; nnoremap \\&lt;Up&gt; :echoe &quot;Use k&quot;\\&lt;CR&gt; nnoremap \\&lt;Down&gt; :echoe &quot;Use j&quot;\\&lt;CR&gt; &quot; …and in insert mode inoremap \\&lt;Left&gt; \\&lt;ESC&gt;:echoe &quot;Use h&quot;\\&lt;CR&gt; inoremap \\&lt;Right&gt; \\&lt;ESC&gt;:echoe &quot;Use l&quot;\\&lt;CR&gt; inoremap \\&lt;Up&gt; \\&lt;ESC&gt;:echoe &quot;Use k&quot;\\&lt;CR&gt; inoremap \\&lt;Down&gt; \\&lt;ESC&gt;:echoe &quot;Use j&quot;\\&lt;CR&gt;","categories":[{"name":"vim","slug":"vim","permalink":"http://example.com/categories/vim/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"},{"name":"文本编辑器","slug":"文本编辑器","permalink":"http://example.com/tags/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"}],"author":"tugumineko"},{"title":"生活在树上","slug":"生活在树上","date":"2024-05-19T04:43:48.000Z","updated":"2024-05-21T10:40:05.076Z","comments":true,"path":"2024/05/19/生活在树上/","permalink":"http://example.com/2024/05/19/%E7%94%9F%E6%B4%BB%E5%9C%A8%E6%A0%91%E4%B8%8A/","excerpt":"","text":"二叉搜索树 Treap树 每个结点有2个值 键值：value 优先级：priority value要满足BST的基本性质，priority用于满足堆的性质，用来实现二叉树的平衡 Treap通过随机化的priority属性,以及维护堆性质的过程，[打乱]了结点的插入顺序。从而让二叉搜索树达到了理想的复杂度，避免了退化成链的问题 利用Treap可以实现一个名次树而且比红黑树好写很多，在算法竞赛中很常用 结点结构 1234567891011121314151617struct Node &#123; Node *ch[2];// ch[0]左树的指针，ch[1]右树的指针 int val, rank; int rep_cnt;// val出现的次数 int siz;// 结点树的大小 Node(int val) : val(val), rep_cnt(1), siz(1) &#123; ch[0] = ch[1] = nullptr; rank = rand(); &#125; void upd_siz() &#123; siz = rep_cnt; if (ch[0] != nullptr) siz += ch[0]-&gt;siz; if (ch[1] != nullptr) siz += ch[1]-&gt;siz; &#125;&#125;; 旋转 旋转操作的含义： 在不影响搜索树的性质的前提下，把和旋转方向相反的子树变成根结点。 将新的根结点的子树变为旧根结点的子树 这里使用一个temp存新的根结点，并且最后要更改引用 123456789enum rot_type &#123; LF = 1, RT = 0 &#125;;void _rotate(Node *&amp;cur, rot_type dir) &#123; Node *tmp = cur-&gt;ch[dir];// 把和旋转方向相反的子结点变成根结点 cur-&gt;ch[dir] = tmp-&gt;ch[!dir];// 将新的根结点的子树变为旧根结点的子树 tmp-&gt;ch[!dir] = cur;// 新子树放到与旋转相同方向的根结点，从而完成旋转操作 cur-&gt;upd_siz(), tmp-&gt;upd_siz(); cur = tmp;&#125; 插入 插的过程中通过旋转来维护树堆中堆的性质,旋转完成后要更新结点大小 1234567891011121314151617181920212223void _insert(Node *&amp;cur, int val) &#123; if (cur == nullptr) &#123; cur = new Node(val); return; &#125; else if (val == cur-&gt;val) &#123; cur-&gt;rep_cnt++; cur-&gt;siz++; &#125; else if (val &lt; cur-&gt;val) &#123; _insert(cur-&gt;ch[0], val); if (cur-&gt;ch[0]-&gt;rank &lt; cur-&gt;rank) &#123; // 利用rank维护小根堆性质 _rotate(cur, RT);// 要把左结点转上来，需要右旋 &#125; cur-&gt;upd_siz(); &#125; else &#123; _insert(cur-&gt;ch[1], val); if (cur-&gt;ch[1]-&gt;rank &lt; cur-&gt;rank) &#123; _rotate(cur, LF); &#125; cur-&gt;upd_siz(); &#125;&#125; 删除 注意更新结点大小，思路和插入差不多 123456789101112131415161718192021222324252627282930313233343536373839void _del(Node *&amp;cur, int val) &#123; // 每次递归都要重新更新size if (val &gt; cur-&gt;val) &#123; _del(cur-&gt;ch[1], val); cur-&gt;upd_siz(); &#125; else if (val &lt; cur-&gt;val) &#123; _del(cur-&gt;ch[0], val); cur-&gt;upd_siz(); &#125; else &#123; if (cur-&gt;rep_cnt &gt; 1) &#123; cur-&gt;rep_cnt--, cur-&gt;siz--; return; &#125; uint8_t state = 0; state |= (cur-&gt;ch[0] != nullptr); state |= ((cur-&gt;ch[1] != nullptr) &lt;&lt; 1); Node *tmp = cur; switch (state) &#123; case 0: delete cur; cur = nullptr; break; case 1: cur = tmp-&gt;ch[0]; delete tmp; break; case 2: cur = tmp-&gt;ch[1]; delete tmp; break; case 3: rot_type dir = cur-&gt;ch[0]-&gt;rank &lt; cur-&gt;ch[1]-&gt;rank ? RT : LF;// 把优先级更小的儿子转上去 _rotate(cur, dir); _del(cur-&gt;ch[!dir], val);// 旋转完成后删除旧节点(位于根节点的旋转方向的子节点) cur-&gt;upd_siz(); break; &#125; &#125;&#125; 根据值查询排名 查询以 cur 为根节点的子树中，val 这个值的大小的排名（该子树中小于 val 的节点的个数 + 1） 1234567891011121314151617181920int _query_rank(Node* cur, int val) &#123; int less_siz = cur-&gt;ch[0] == nullptr ? 0 : cur-&gt;ch[0]-&gt;siz; // 在BST中，左儿子比父节点小 if (cur-&gt;val == val) return less_siz + 1; else if (cur-&gt;val &gt; val) &#123; if (cur-&gt;ch[0] != nullptr) return _query_rank(cur-&gt;ch[0], val); else return 1; // 没有比它小的了 &#125; else &#123; if (cur-&gt;ch[1] != nullptr) // 如果要查的值比这个节点大，那这个节点的左子树以及这个节点自身肯定都比要查的值小 // 所以要加上这两个值，再加上往右边找的结果 // （以右子树为根的子树中，val 这个值的大小的排名） return less_siz + cur-&gt;cnt + _query_rank(cur-&gt;ch[1], val); else return cur-&gt;siz + 1; // 没有右子树 &#125;&#125; 根据排名查询值 直接递归，和BST搜索的写法差不多 排名&lt;=左子树的大小，则搜索左子树 排名&gt;=左子树的大小 + 根结点的重复次数，则搜索右子树 123456789int _query_val(Node *cur, int rank) &#123; int less_siz = cur-&gt;ch[0] == nullptr ? 0 : cur-&gt;ch[0]-&gt;siz; if (rank &lt;= less_siz) return _query_val(cur-&gt;ch[0], rank); else if (rank &lt;= less_siz + cur-&gt;rep_cnt) return cur-&gt;val; else return _query_val(cur-&gt;ch[1], rank - less_siz - cur-&gt;rep_cnt);&#125; 查询第一个比 val 小的节点 全局变量，q_prev_tmp 是只有在 val 比当前节点值大的时候才会被更改的，所以返回这个变量就是返回 val 最后一次比当前节点的值大，之后就是更小了 12345678910111213141516int _query_prev(Node *cur, int val) &#123; if (val &lt;= cur-&gt;val) &#123; // 往左子树找 if (cur-&gt;ch[0] != nullptr) return _query_prev(cur-&gt;ch[0], val); &#125; else &#123; // 只有能进到这个 else 里，才会更新 q_prev_tmp 的值 q_prev_tmp = cur-&gt;val; // 因为要确定最大的，所以要到右子树继续找 if (cur-&gt;ch[1] != nullptr) _query_prev(cur-&gt;ch[1], val); // 接下来的递归可能不会更改 q_prev_tmp // 了，那就直接返回最后一次进到 这个 else 中的 // cur-&gt;val return q_prev_tmp; &#125; return -1;&#125; 查询第一个比 val 大的节点 12345678910int _query_nex(Node *cur, int val) &#123; if (val &gt;= cur-&gt;val) &#123; if (cur-&gt;ch[1] != nullptr) return _query_nex(cur-&gt;ch[1], val); &#125; else &#123; q_nex_tmp = cur-&gt;val; if (cur-&gt;ch[0] != nullptr) _query_nex(cur-&gt;ch[0], val); return q_nex_tmp; &#125; return -1;&#125; Splay树 理论 通常在任意数据结构的生命期内，不仅执行不同操作的概率往往极不均衡，而且各操作之间具有极强的关联性，并在整体上多呈现出极强的规律性。其中最为典型的，就是所谓的“数据局部性”，即： (1) 刚刚被访问过的元素，极有可能在不久之后再次被访问到 (2) 将被访问的下一元素，极有可能就处于不久之前被访问过的某个元素附近 就BST而言，数据局部性具体表现为： (1) 刚刚被访问过的节点，极有可能在不久的之后访问到 (2) 将被访问的下一节点，极有可能就处于不久之前被访问过的节点的附近 因此，只需将刚被访问过的节点，及时地”转移“至树根（附近），即可加速后续的操作。Splay树应运而生 对比Splay和Treap: (1) Splay树允许把任意节点旋转到根 (2) 需要分裂和合并时，Splay树的操作非常简便 结构与操作 每一次查询后都要splay 123456789101112131415161718192021222324252627282930313233343536373839404142int root; // 根节点int ch[N][2], fa[N]; // 子节点/父节点int val[N]; // 权值int size[N]; // 子树大小int cnt[N]; // 重复次数int tot; // 节点个数struct Splay &#123; // 维护子树大小 void maintain(int x); // 查找这个节点是父亲的左子树还是右子树 bool get(int x); // 销毁这个节点 void clear(int x); // 旋转 void rotate(int x); // 伸展操作 void splay(int x); // 插入v void insert(int v); // 查询值为v的数排名 int find_rank(int v); // 查询排名为r的数 int find_val(int r); // 查询根节点的前驱 int pre(); // 查询根节点的后继 int next(); // 删除一个值为val的数 void del(int v);&#125; tree; 基本操作 123456789101112void Splay::maintain(int x) &#123; size[x] = size[ch[x][0]] + size[ch[x][1]] + cnt[x];&#125;bool Splay::get(int x) &#123; // 左儿子返回0.右儿子返回1 return x == ch[fa[x]][1];&#125;void Splay::clear(int x) &#123; ch[x][0]=ch[x][1]=fa[x]=val[x]=size[x]=cnt[x]=0;&#125; 旋转 1234567891011121314151617181920// 节点x上升一位void Splay::rotate(int x) &#123; // 右儿子的父亲左移，左儿子的父亲右移 // 设父亲为y，祖父为z int dir = get(x); int y = fa[x], z = fa[y]; // 先杀皇帝再让太子继位，然后再供奉祖宗牌匾 ch[y][dir] = ch[x][!dir]; if (ch[y][!dir]) fa[ch[x][!dir]] = y; ch[x][!dir] = y; fa[y] = x; fa[x] = z; if (z) ch[z][y == ch[z][1]] = x; // 先维护儿子，再维护父亲 maintain(y); maintain(x); &#125; 伸展 12345678void Splay::splay(int x) &#123; // 设父亲为y,祖父为z // 若儿子种类相同，则先转祖父，再转父亲 // 若儿子种类不同，则先转父亲，再转祖父 for (int i = fa[x]; i = fa[x], i; rotate(x)) if (fa[f]) get(x) == get(i) ? rotate(i) : rotate(x); root = x;&#125; 插入 依然是三种情况： 空树nullptr 重复的值，直接cnt++然后伸展 没有，则按照BST插入后伸展 这里数组的下标用tot标记，即元素的插入顺序 123456789101112131415161718192021222324252627282930313233void Splay::insert(int v) &#123; if (!root) &#123; val[++tot] = val; cnt[tot] = size[tot] = 1; root = tot; return; &#125; else &#123; int cur = root, i = 0; while (1) &#123; if (val[cur] == v) &#123; cnt[cur]++; maintain(cur); maintain(i); splay(cur); return; &#125; i = cur; cur = ch[cur][val[cur] &lt; v]; if (cur == 0) &#123; tot++; val[tot] = v; cnt[tot]++; fa[tot] = i; ch[x][val[x] &lt; v] = tot; maintain(tot); maintain(x); splay(tot); return; &#125; &#125; &#125;&#125; 查询值为v的数的排名 经典回顾： 如果 x 比当前节点的权值小，向其左子树查找。 如果 x 比当前节点的权值大，将答案加上左子树（size）和当前节点（cnt）的大小，向其右子树查找。 如果 x 与当前节点的权值相同，将答案加 1 并返回。 最后要进行splay 1234567891011121314151617int Splay::find_rank(int v) &#123; int ans = 0, cur = root; while (1) &#123; if (v &lt; val[cur]) cur = ch[cur][0]; else &#123; ans += size[ch[cur][0]]; if(!cur)return ans+1; if (v == val[cur]) &#123; splay(cur); return ans + 1; &#125; ans += cnt[cur]; cur = ch[cur][1]; &#125; &#125;&#125; 查询排名为r的数 经典回顾： 如果左子树非空且剩余排名 r 不大于左子树的大小 size，那么向左子树查找。 否则将 r 减去左子树的和根的大小。如果此时 r 的值小于等于 0，则返回根节点的权值，否则继续向右子树查找。 123456789101112131415int Splay::find_val(int r) &#123; int cur = root; while (1) &#123; if (ch[cur][0] != 0 &amp;&amp; r &lt;= size[ch[cur][0]]) cur = ch[cur][0]; else &#123; r -= cnt[cur] + size[ch[cur][0]]; if (r &lt;= 0) &#123; splay(cur); return val[cur]; &#125; cur = ch[cur][1]; &#125; &#125;&#125; 查询前驱 前驱定义为小于 x 的最大的数，那么查询前驱可以转化为：将 x 插入（此时 x 已经在根的位置了），前驱即为 x 的左子树中最右边的节点，最后将 x 删除即可。 这里插入和删除操作请自行添加 1234567891011int Splay::pre()&#123; int cur = ch[root][0]; if( cur == 0 ) return cur; while( ch[cur][1] ) cur = ch[cur][1]; splay(cur); return cur;&#125; 查询后继 这里插入和删除操作请自行添加 1234567891011int Splay::next()&#123; int cur = ch[root][1]; if( cur == 0 ) return cur; while( ch[cur][0] ) cur = ch[cur][0]; splay(cur); return cur;&#125; 合并 对于合并两棵树，其中一棵树的值都小于另一棵树的值。 我们可以找到较小一棵树的最大值 x ，将其旋转到根节点。 再把较大一棵树作为 x 的右子树插入。 删除 首先将 x 转移到根节点 若 x 值不只一个，直接cnt[x]– 否则将它的左右子树合并 1234567891011121314151617181920212223242526272829303132333435363738394041424344void Splay::del(int v)&#123; find_rank(v);//splay if(cnt[root]&gt;1)&#123; cnt[root]--; maintain(root); return; &#125; if((ch[root][0]==0)&amp;&amp;(ch[root][1]==0))&#123; clear(root); root = 0; return; &#125; if(ch[root][0]==0)&#123; int cur = root; root = ch[root][1]; fa[root]=0; clear(cur); return; &#125; if(ch[root][1]==0)&#123; int cur = root; root = ch[root][0]; fa[root]= 0; clear(cur); return; &#125; int cur = root; int x = pre();//splay //merge fa[ch[cur][1]] = x; ch[x][1] = ch[cur][1]; clear(cur); maintain(root); return;&#125; 序列操作 按照序列建成的Splay有以下性质: Splay的中序遍历相当于原序列从左到右的遍历 Splay上的一个节点代表序列的一个元素；Splay上的一颗子树，代表原序列的一段区间 利用Splay操作，可以快速提取出代表某个区间的Splay的子树 具体操作： Splay 的一颗子树代表原序列的一段区间。现在想找到序列区间 [L, R] 代表的子树，只需要将代表 aL−1a_{L - 1}aL−1​ 的节点 Splay 到根，再将代表 aR+1a_{R + 1}aR+1​的节点 splay 到根的右儿子即可。根据「Splay 的中序遍历相当于原序列从左到右的遍历」，对应 aR+1a_{R + 1}aR+1​ 的节点的左子树中序遍历为序列 a[L, R]，故其为区间 [L, R] 代表的子树。 一般会建立左右两个哨兵节点 0 和 n + 1，放在数列的最开头和最结尾，防止 L - 1 或 R + 1 超出数列范围。 123456789101112131415void Splay::splay(int x, int goal = 0) &#123; // 如果目标点 goal 为 0 说明旋转到根节点 if (goal == 0) root = x; // 设父亲为y,祖父为z // 若儿子种类相同，则先转祖父，再转父亲 // 若儿子种类不同，则先转父亲，再转祖父 while (fa[x] != goal) &#123; int i = fa[x], g = fa[i]; if (g != goal) &#123; get(i) == get(x) ? rotate(i) : rotate(x); &#125; rotate(x); &#125;&#125; 区间翻转 一个暴力做法是每次将根节点的左右儿子交换，然后递归左右子树做同样的操作，这样复杂度为 O(n)，不可承受。 可以考虑使用懒标记，先给根打上「翻转标记」并交换其左右儿子。当递归到一个带懒标记的点时，将懒标记下传即可 12345678910111213141516171819void Splay::tagrev(int v)&#123; swap(ch[v][0],ch[v][1]); lazy[v] ^= 1;&#125;void Splay::pushdown(int v)&#123; if(lazy[v])&#123; tagrev(ch[v][0]); tagrev(ch[v][1]); lazy[v] = 0; &#125;&#125;void Splay::reverse(int l, int r)&#123; int L = find_val(l-1), R = find_val(r+1); splay(L), splay(R, L); int temp = ch[ch[L][1]][0]; tagrev(temp);&#125; 将Splay用于需要区间翻转的区间维护 对于区间反转这种操作，由于原数列的顺序已经给定，所以不能按照权值排序，所以选择按照的点的编号建立BST","categories":[{"name":"cpp","slug":"cpp","permalink":"http://example.com/categories/cpp/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"tugumineko"},{"title":"C++之旅(A Tour of C++)读书笔记","slug":"the-tour-of-cpp","date":"2024-05-08T14:55:22.000Z","updated":"2024-05-14T14:43:18.094Z","comments":true,"path":"2024/05/08/the-tour-of-cpp/","permalink":"http://example.com/2024/05/08/the-tour-of-cpp/","excerpt":"","text":"基础 程序 ISO C++标准中定义了两种实体： 核心语言特性.i.e.内置类型(char,int).循环(for,while) 标准库组件.i.e.容器(vector,map).输入输出操作(&lt;&lt;,getline) C++是一种静态语言。这意味着，每一个实体(对象、值、名称和表达式等)被使用的那一刻，编译器必须知道其准确的类型。 1int main()&#123;&#125; //最小的cpp程序 123456//import std; 是cpp20的特性#include&lt;iostream&gt; //标准库组件int main()&#123; std::cout&lt;&lt;&quot;Hello, World!\\n&quot;; //标准库命名空间std::&#125; Hello, World! 函数 123double sqrt(double d); //函数声明的时候可以包含参数的名称double s = sqrt(2); //检测参数类型在必要的时候会发生隐式类型转换char&amp; String::operator[](int index); //函数的类型是char&amp; String::(int),函数可以是类成员 类型、变量和运算 unsigned一般用于位运算 数字可以是浮点数或者整数： 浮点字面量含有小数点或者指数符号 0b二进制整数 //0b0101010 0x十六进制整数 //0x3f3f3f3f 0八进制整数 //0334 使用单引号(’)作位数字分隔符 0x3.243F’6A88’85A3’08D3 初始化: = 的形式是C语言传统的形式，会发生隐式类型转换 {} 更通用，而且可以省略’=’,不会发生隐式类型转换 常量被声明时必须被初始化，用户自定义类型可以在定义时被隐式初始化 如果变量的类型可以从初始化符号中推导出来，就无需显式指定类型 使用 auto 常用在泛型编程中，以避免书写冗长的类型名称及重复代码 1234567double d1 = 2.3;double d2 &#123;2.3&#125;;double d3 = &#123;2.3&#125;;complex&lt;double&gt; z = 1;complex&lt;double&gt; z2 &#123;d1,d2&#125;;complex&lt;double&gt; z3 = &#123;d1,d2&#125;;vector&lt;int&gt; v &#123;1, 2, 3, 4, 5, 6&#125;; 12auto y = 3.14;auto z &#123;sqrt(y)&#125;; 作用域和生命周期 声明语句把一个名字引入作用域： 局部作用域：在函数/匿名函数中定义的名字叫做局部名字(包括函数参数的名字)，以语句块({})结尾. 类作用域：不在函数、匿名函数或 enum class 中但在类的内部. 命名空间作用域：不是局部名字和类名字且在命名空间的内部. 生命周期： 对象必须先被构造（初始化）才能被使用，并且在退出作用域时被销毁。 命名空间对象在程序结束时被销毁。 对象成员的销毁时间点取决于所属对象的销毁时间点。 一个用new创建的对象则可以持续生存，直到用delete将其销毁。 常量 const 用来说明接口，可以用指针或者引用的方式传入参数而不用担心被改变 编译器负责强制执行 const 承诺 const声明的值可以在运行时计算 constexpr 声明常量，在只读内存中，提高性能 constexpr 的值必须由编译器运算 const double s1 = sum(v); //可行:允许在运行时运算 constexpr double s2 = sum(v); 123456789double sum1(const double&amp;);double sum2(const vector&lt;double&gt;&amp;);vector&lt;double&gt; v &#123;1.2, 3.4, 5.6&#125;;const double s1 = sum1(1.0); //可行constexpr double s2 = sum1(1.0); //不行constexpr double s3 = sum2(v); //不行&#125; 若要使函数在常量表达式(上文代码)中使用，这个函数必须被定义为 constexpr 或 consteval constexpr 函数 在输入非常量参数时，输出的不是常量表达式 在输入常量参数时，输出的才是常量表达式 consteval 函数可以让输入变量只能为常量表达式,即可以省略输入的常量表达式语法，还可以使输出为常量表达式。 12345constexpr double squre(double x)&#123;return x*x;&#125;constexpr double max1 = 1.4*squre(17) //可行，17为常量constexpr double max2 = 1.4*squre(var) //错误，var不是变量，所以返回值不是常量表达式const double max3 = 1.4*squre(var) //可行 1234consteval double square2(double x)&#123;return x*x;&#125;constexpr double max1 = 1.4*square2(17); //可行const double max2 = 1.4*square2(var); //错误，函数输入只能是常量表达式 总结 这里讨论的有三个部分，函数的返回值类型（函数的声明），函数的输入参数类型，数据类型,均有两种写法，注意分辨 函数的输入参数类型 (数据类型 变量名):可以是变量，也可以是常量表达式 (const 数据类型&amp; 变量名):函数不会修改他它的参数 数据类型 const:说明接口，意为“只读” cosntexpr:声明常量，赋值给他的只能是常量表达式 函数的返回值类型 constexpr:不指定输入类型，输入和输出的不变性一致 consteval:输入和输出均为常量表达式 注意const只具有接口性质，不是实际上的常量 函数的声明为常量(constexpr,consteval)可以实现C++的纯函数，即数学意义上的函数，不会有副作用，不能修改函数的输入参数 指针、数组和引用 123456T a[n]; //数组T* p; //指针T&amp; r; //引用char* p = &amp;v[3]; //p指向数组v的第四个元素char x = *p; //*p代表p指向的对象(*解引用) 注意*在定义时是定义指针,在指针前使用是解引用 空指针 空指针用nullptr表达，整数用0或NULL表达，在检验时是兼容的 不能引用空指针 映射到硬件 赋值: p和q同时指向y的地址 1234int y = 3;int* p = &amp;x;int* q = &amp;y;p = q; 地址r1,r2不同，但是使不同的地址具有相同的值 12345int x = 2;int y = 3;int&amp; r1 = x;int&amp; r2 = y;r1 = r2; 这里直接用引用的方法操作地址，没有使用指针 初始化:没有未经初始化的引用 使用 = 来初始化一个引用，注意这不是赋值 int&amp; r = x; //r指代x 补充在函数中引用的两种方法 void sort(vector&lt;double&gt;&amp;v) 若只想减少复制参数的开销，则： double sum(const vector&lt;double&gt;&amp;) 这样就不能改变函数传入的参数 用户自定义类型 内置类型：用基本类型、const操作符和声明操作符构造出来的类型 用户自定义类型：利用C++的抽象机制从其他类型构造出来的类型，包括类和枚举类型 结构 struct 1234567891011121314151617181920212223242526struct Vector &#123; double* elem; int sz; &#125;; void vector_init(Vector&amp; v, int s)&#123; v.elem = new double[s]; v.sz = s; &#125;double read_and_sum(int s) //从cin中读入s个整数，然后返回它们的和；假定s为正&#123; Vector v; vector_init(v,s); for(int i=0;i!=s;i++)&#123; std::cin&gt;&gt;v.elem[i]; &#125; double sum = 0; for(int i=0;i!=s;i++)&#123; sum += v.elem[i]; &#125; return sum;&#125; 访问结构体的成员有两种方式 用 . 表示通过名字或者引用访问 用 -&gt; 表示通过指针访问 12345void f(Vector v, Vector&amp; rv, Vector* pv)&#123; int i1 = v.sz; //通过名字访问 int i2 = rv.sz; //通过引用访问 int i3 = pv-&gt;sz; //通过指针访问 &#125; 类 class 把类型的接口（所有代码都可使用的部分）与其实现（可访问外部不可访问的数据）分离开来的语言机制被称为类 123456789class Vector &#123;public: Vector(int s) :elem&#123; new double[s] &#125;, sz&#123; s &#125; &#123;&#125; //构造函数 double&amp; operator[](int i) &#123; return elem[i]; &#125; int size() &#123; return sz; &#125;private: double* elem; int sz;&#125;; 构造函数在初始化类对象时一定会被调用 错误处理暂时没有涉及 思考通过new获取的double数组如何归还？ struct和class没有本质区别，struct是默认public的 枚举 enum class 枚举类型用于表示少量整数数值的集合 通过符号名称替代整数 后面的class表示这个枚举类型是强类型，并且具备独立作用域 不能混用不同类的枚举值 无法隐式地混用枚举类型与整数类型的值 默认情况下，一个enum class定义仅定义赋值操作符、初始化函数及比较操作符，也可以自定义其他操作符 123456789101112131415enum class Color &#123; red, blue, green &#125;;enum class Traffic_light &#123; green, yellow, red &#125;;Color col = Color::red;Traffic_light light = Traffic_light::red;Traffic_light* operator++(Traffic_light&amp; t) &#123; using enum Traffic_light; switch (t) &#123; case green:return t = yellow; case red:return t = green; case green:return t = red; &#125;&#125; Color x = redColor y = traffic_light::red int i = Color::redColor c = 2 Color z = Color::redauto z = Color::red Color x = Color{5}Color y {6} enum 普通enum中的枚举值进入与enum自身同级的作用域 可以被隐式转换为整数数值 用枚举表示一组命名的常量为枚举定义操作来简化并保证安全优先使用enum class以避免很多麻烦 12enum Color &#123;red, green, blue&#125;;int col = red; //col &#123;0&#125; 联合 union 实际占用空间就是它最大成员所占的空间，可以用来节约空间 同一时刻，union中只能保存一个成员的值 12345678910111213141516171819enum class Type &#123; ptr, num &#125;;union Value &#123; Node* p; int i;&#125;;struct Entry &#123; string name; Type t; Value v;&#125;;void f(Entry* pe)&#123; if (pe-&gt;t == Type::num) cout &lt;&lt; pe-&gt;v.i; //...&#125; 避免使用“裸”union;将其与类型字段一起封装在一个类中 使用标准库类型variant可以消除大多数需要直接使用unionvariant更简单，安全 1234567891011struct Entry &#123; string name; variant&lt;Node*,int&gt; v;&#125;;void f(Entry* pe)&#123; if (holds_alternative&lt;int&gt;(pe-&gt;v)) cout &lt;&lt; get&lt;int&gt;(pe-&gt;v); //...&#125; 模块化 一个C++程序包含许多独立开发的部分，例如函数、用户自定义类型、类层次、 模板为了让这些独立开发的部分在其他地方使用（类似于函数的声明），我们使用模块化的方法 区分声明(用作接口)和定义(用作实现) 分离编译 头文件 在C++中，接口文件后缀名为.h,里面应该包括函数的声明 实现接口函数的文件后缀名为.cpp,为了帮助编译器保持一致性，同样应该包含提供接口的.h文件 要使用这个头文件的函数，就需要在头文件中包含&quot;xxx.h&quot; 使用#include及头文件实现模块化是一种传统方法，它具有明显的缺点。 编译时间：不同的文件每一次include不同的头文件编译器都要处理一次 依赖顺序：先include的头文件的定义与宏可能会影响后一个的代码的含义 不协调：可能会出现类似下面的问题 我们有意无意地在两个源文件中定义了同一个实体的时候 不同源文件引用头文件的顺序不一致的时候 传染性：一个文件(1)包含的头文件(2)会包含其他这个文件(1)不需要的头文件，以此类推会导致代码膨胀且冗余 避免在头文件中定义非内联函数不要在头文件中使用 using 指令 模块 写法1：将class export并表示成声明的形式，就和.h写法差不多 12345678910111213141516171819202122232425export module Vector;export class Vector &#123; public: Vector(int s); double&amp; operator[](int i); int size(); private: double* elem; int sz;&#125;;Vector::Vector(int s) : elem&#123;new double[s]&#125;, sz&#123;s&#125; &#123;&#125;double&amp; Vector::operator[](int i) &#123; return elem[i]; &#125;int Vector::size() &#123; return sz; &#125;export bool operator==(const Vector&amp; v1, const Vector&amp; v2) &#123; if (v1.sieze() != v2.size()) return false; for (int i = 0; i &lt; v1.size(); i++) if (v1.elem[i] != v2.elem[i]) return false; return true;&#125; 写法2：函数export的就是可见的，没有export的就是不可见的(类似java) module Vector接口形式，后缀名为.cppm import Vector使用Vector export module Vector定义Vector 模块在维护性与编译时间方面的改进非常显著 命名空间 用 namespace 命名空间名 {} 用 :: 访问 表达某些声明是属于一个整体的 表明它们的名字不会与其他命名空间中的名字冲突 真正的main()（不是自己定义的命名空间里的） 用 using 声明将命名空间中的名字放进作用域,可以降低可读性 1234567void my_code(vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y) &#123; using std::swap; // 将标准库的swap放进作用域 //... swap(x, y); // std::swap() other::swap(x, y); // 某个其他的swap() //...&#125; 使用标准库命名空间中所有名称的访问权 using namespace std; 用以上方式使用命名空间指令不会影响使用模块的用户，影响仅限于模块内部 函数参数与返回值 函数之间传递信息有三种路径： 参数 全局变量 类对象中的共享状态 在函数的信息传递中，我们应考量： 对象是被复制的还是共享的？ 这个共享对象是否可被修改？ 这个对象是否被移动，从而留下了一个空对象？ 参数传递 默认情况复制(传值)/直接指向引用(传引用)/直接只读const&amp; 拥有默认值的函数参数可以达到和重载函数一样的效果 123void print(int value, int base = 10);print(x,8);print(x);//默认十进制 1234567void print(int value, int base)&#123; //...&#125;void print(int value)&#123; print(int value, 10);&#125; 返回值 返回值的默认行为是复制 返回引用的情况只应当出现在返回的内容不属于函数局部的时候(注意数组) 局部变量在函数返回的时候消失，因此我们不应当返回它的引用或者指针 对于较大的对象构造移动方法来极大地减少复制开销 编译器会优化复制行为，叫做省略复制优化 使用指针返回大对象的代码性能不会比使用引用返回的函数好，不要使用这样的代码 1234567891011Matrix* add(const Matrix&amp; x, const Matrix&amp; y) &#123; Matrix* p = new Matrix; //.... return p;&#125;Matrix m1, m2;//...Matrix* m3 = add(m1, m2); // 只复制指针//...delete m3; // 很容易忘记 返回类型推导 使用 auto 关键字 auto mul(int i, double d) &#123; return i*d; &#125; 返回类型后置 有的时候，我们需要先看到参数，然后决定返回值的类型。 这包括但不限于返回类型推导这种情形，这个问题与命名空间、匿名函数、概念都有一定的联系 使用 auto 关键字，表示返回值会在后面提到 auto mul(int i, double d) -&gt; double &#123; return i*d; &#125; 使用这种记法能够更有效地实现代码对齐 auto next_elem -&gt; Elem*; auto exit(int) -&gt; void; auto sqrt(double) -&gt; double; 不要过度使用返回类型推断 结构化绑定 把类对象成员赋予局部变量名称的机制 使用 {s, i} 构造 使用 [n, v] 读取(“解包”) 123456789101112131415struct Entry &#123; string name; int value;&#125;;Entry read_entry(istream&amp; is) // 简单地读函数&#123; string s; int i; is &gt;&gt; s &gt;&gt; i; return &#123;s, i&#125;;&#125;auto [n, v] = read_entry(cin);cout&lt;&lt;n&lt;&lt;&#x27; &#x27;&lt;&lt;v&lt;&lt;&#x27;\\n&#x27;; 对完全没有私有数据的类使用结构化绑定时，绑定行为是明显的：提供的名称数量必须与数据成员的数量相等，每一个绑定名称对应一个成员变量 12345678910map&lt;string, int&gt; m;//...for (const auto [key, value] : m) &#123; cout &lt;&lt; key &lt; &#x27; &#x27; &lt;&lt; value &lt;&lt; &#x27;\\n&#x27;;&#125;auto incr(map&lt;string, int&gt;&amp; m) -&gt; void &#123; for (auto&amp; [key, value]) value++;&#125; 结构化绑定也可以用于处理需要通过成员函数访问对象数据的类（?） complex&lt;double&gt; z = &#123;1,2&#125;; auto [re,im] = z+2; 不要过度使用结构化绑定","categories":[{"name":"cpp","slug":"cpp","permalink":"http://example.com/categories/cpp/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"}],"author":"tugumineko"},{"title":"python图像处理","slug":"python图像处理","date":"2024-05-06T08:31:57.000Z","updated":"2024-05-06T08:39:07.566Z","comments":true,"path":"2024/05/06/python图像处理/","permalink":"http://example.com/2024/05/06/python%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/","excerpt":"","text":"python图像处理 详见文档Pillow:Python-Imaging-Library这里使用的是Image模块 图像属性 format属性 string or None 标识了图像来源，如果图像不是从文件读取它的值就是None mode属性 string size属性 (width,height) 图像的尺寸，按照像素数计算 palette属性 palette or None 颜色调色板表格，只对模式为&quot;P&quot;的图像返回Image Palette info属性 dictionary 存储图像相关数据的字典 12345678from PIL import Imageim = Image.open(&quot;personal/1.png&quot;)print(im.format)print(im.mode)print(im.size)print(im.palette)print(im.info)im.show() PNG RGBA (1920, 1200) None &#123;'srgb': 0, 'gamma': 0.45455, 'dpi': (119.9896, 119.9896)&#125; 构建图像 Image.open(fp,mode) 123from PIL import Image im = Image.open(&quot;personal/21.jpg&quot;,&quot;r&quot;)im.show() 需要知道的是在win的环境下im.show的方式为win自带的图像显示应用。打开并确认给定的图像文件。这个是一个懒操作；该函数只会读文件头，而真实的图像数据直到试图处理该数据才会从文件读取（调用load()方法将强行加载图像数据）。如果变量mode被设置，那必须是“r”。用户可以使用一个字符串（表示文件名称的字符串）或者文件对象作为变量file的值。文件对象必须实现read()，seek()和tell()方法，并且以二进制模式打开。 Image.new(mode,size,color=0) 123from PIL import Image,ImageColorim = Image.new(&#x27;RGB&#x27;,(200,200),color=&quot;red&quot;)im.show() Image.fromarray(obj,mode=None) obj-数组接口对象 mode-不自动判断 123456from PIL import Imageimport numpy as nparr = (np.eye(300)*255) # 二维数组im = Image.fromarray(arr) # 转换为图像im.show() 12345678910111213141516from PIL import Imageimport numpy as npimage = Image.open(&quot;personal/21.jpg&quot;)image1 = image.resize((200,200)) # resizedata = image1.getdata() # 转换为数组序列print(list(data)) # 查看具体数据需要使用 list() 转换obj = []for t in data: obj.append([sum(t) / 3]) # 灰度方法：RGB三个分量的均值# 变成 200 * 200 的二维数组obj = np.array(obj).reshape((200,200))print(obj)im = Image.fromarray(obj)im.show() [[223. 222.66666667 222. ... 240.66666667 240.66666667 240.66666667] [222.66666667 222.66666667 221.66666667 ... 240.66666667 241. 240.66666667] [222.33333333 221.66666667 221.33333333 ... 240.66666667 240.66666667 240.33333333] ... [120.33333333 118.33333333 145.66666667 ... 216.66666667 189. 189.33333333] [119. 133.33333333 166. ... 205. 188. 190. ] [125.33333333 162.66666667 163. ... 196.33333333 188.33333333 190. ]] 输出如下： 图像处理 图像混合 透明度混合 Image.blend(im1,im2,alpha) im1:Image对象，透明度为(1-alpha) im2:Image对象，透明度为(alpha) alpha:透明度(0~1). 注意：im1和im2的大小必须一样，且模式为RGB 123456from PIL import Imageim1 = Image.open(&#x27;personal/10.jpg&#x27;).convert(mode=&#x27;RGB&#x27;)im2 = Image.new (&#x27;RGB&#x27;,im1.size,&#x27;blue&#x27;)im1.show()Image.blend(im1,im2,0.2).show() 效果如下图所示： 遮罩混合 Image.composite(im1,im2,mask) 均为Image对象，使用mask来混合im1和im2 这里三个Image对象的size和mode都必须相同 12345678910from PIL import Imageim1 = Image.open(&#x27;personal/7.jpg&#x27;)im2 = Image.open(&#x27;personal/14.jpg&#x27;)print(im1.mode)print(im2.mode)print(im1.size)print(im3.size)r, g, b = im2.split()Image.composite(im1,im2,b).show() RGB RGB (3840, 2160) (3840, 2160) 效果如下图所示： 其他 转换图像格式 将.png转换为.jpg,注意：不能将RGBA转化为.jpg 123456from PIL import Imageim = Image.open(&quot;personal/10.png&quot;,&quot;r&quot;)print(im)im.save(&quot;personal/10.jpg&quot;) # 将.png转化为.jpgim = Image.open(&quot;personal/10.jpg&quot;,&quot;r&quot;)print(im.format,im.size,im.mode) &lt;PIL.PngImagePlugin.PngImageFile image mode=RGB size=1920x1080 at 0x255C7FE22E0&gt; JPEG (1920, 1080) RGB","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"数字图像处理","slug":"数字图像处理","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"author":"tugumineko"},{"title":"冒泡排序曲线的推导","slug":"A-Rigorous-Derivation-of-the-Bubble-Sort-Curve","date":"2024-05-05T04:42:10.000Z","updated":"2024-05-05T11:42:08.289Z","comments":true,"path":"2024/05/05/A-Rigorous-Derivation-of-the-Bubble-Sort-Curve/","permalink":"http://example.com/2024/05/05/A-Rigorous-Derivation-of-the-Bubble-Sort-Curve/","excerpt":"","text":"冒泡排序 遍历一组数字以相邻交换的方式找到这一组数字的最值的排序方式 这里讨论的是从小到大的排序 冒泡排序曲线 给出定义 假设：在完全均匀且随机打乱一组数字的情况下进行冒泡排序，将数字的大小以柱的高度表示，在不同的时间下会生成不同的形状。假设这一形状可以用一个近似函数来表示，这个函数的曲线就是冒泡排序曲线。 建立模型 为方便表示：我们设置这张图片的长和宽均为单位1，给定变量时间t，当t=0时，为随机打乱的状态；当t=1时，为排序完成的状态 t=0 t=1 这样，就可以建立一个关于x和t的二元函数 f(x,t)={xx&gt;1−t???x≤1−tf(x, t)=\\left\\{\\begin{array}{ll}x &amp; x&gt;1-t \\\\???&amp; x \\leq 1-t\\end{array}\\right. f(x,t)={x???​x&gt;1−tx≤1−t​ 显然，图像分为两部分： 当x大于1-t的时候，函数值为其本身。 我们需要推导，当x小于1-t的时候的函数值。 所以第一部分的曲线呢？ 推导曲线 关键在于 因为冒泡排序每一次遍历只改变相邻元素，前n项元素在经过相同次数的遍历的情况下的形状是不变的，由于我们设置了单位宽–&gt;这一部分的曲线只随t的增长而横向拉伸 数据是完全均匀且随机打乱的，所以即使它们的数据不完全相同，它们形成的弧线也都是相同的–&gt;在数据量不同的情况下，取前n项元素在拉伸前有相同的形状 推导过程 我们在t的两个不同值处绘制函数，记为f(x,a)f(x, a)f(x,a)和f(x,b)f(x, b)f(x,b) 为了利用先前推导出的性质，我们将图像t较大的一方进行拉伸 由于函数是连续的，所以我们可以知道该点坐标为(1−a,1−a)(1-a,1-a)(1−a,1−a)–&gt;f(1−a,a)=1−af(1-a,a)=1-af(1−a,a)=1−a 令t从1到0呈线性变化，我们得到了推导式f(1−a,a)=1−af(1-a,a)=1-af(1−a,a)=1−a 代入到f(x⋅ba,b)f(x\\cdot \\frac{b}{a},b)f(x⋅ab​,b)中，在进行压缩，就得到了函数图像。 推导过程如下 在f(x⋅ba,b)=f(x,a),x≤1−a中，令x=1−a,则有：在f(x\\cdot \\frac{b}{a}, b)=f(x,a),x\\le1-a中， 令 x = 1-a,则有： 在f(x⋅ab​,b)=f(x,a),x≤1−a中，令x=1−a,则有： f((1−a)⋅ba,b)=f(1−a,a)=1−a.f((1-a)\\cdot \\frac{b}{a}, b)=f(1-a,a)=1-a. f((1−a)⋅ab​,b)=f(1−a,a)=1−a. 令x=(1−a)⋅ba,t=b，则有：a=tx+t令x=(1-a)\\cdot \\frac{b}{a},t=b，则有： a=\\frac{t}{x+t} 令x=(1−a)⋅ab​,t=b，则有：a=x+tt​ 所以f(x,t)={xx&gt;1−txx+tx≤1−t所以f(x, t)=\\left\\{\\begin{array}{ll}x &amp; x&gt;1-t \\\\\\frac{x}{x+t} &amp; x \\leq 1-t\\end{array}\\right. 所以f(x,t)={xx+tx​​x&gt;1−tx≤1−t​","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"tugumineko"},{"title":"PyTorch深度学习","slug":"PyTorch深度学习","date":"2024-05-04T16:38:25.000Z","updated":"2024-05-22T13:32:52.860Z","comments":true,"path":"2024/05/05/PyTorch深度学习/","permalink":"http://example.com/2024/05/05/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"PyTorch深度学习 神经网络 层层组成，多达几百层或者上千层的叫作深度神经网络。从海量的数据中进行处理和分析，提炼出物体的特征，建立模型，从而实现处理大量数据，解决复杂的任务。 架构：每个数据与不同权重相乘后加和，加上偏差后激活再将结果传入下一个神经网络。 构建一个神经网络需要下面五个步骤： 准备数据 定义模型 训练模型 评估预测 做出预测 那么我们怎么高效快速地完成上述五个步骤呢？ 卷积神经网络CNN(Convolution Neural Networks) 例：LeNet-5 PyTorch是一款流行的深度学习框架，有着丰富的工具包 利用PyTorch识别数字 准备数据：计算机将图片进行分割，将图片转化成数字信息 定义模型： 卷积层：把图像变为一系列数据范围为0~1的矩阵。 池化层：把一张很大的图像压缩，变成一张更小更容易计算的图像矩阵。 全连接层：把处理后的图像转化成一段数据。 训练模型： 将训练数据输入模型并计算损失并调整更新参数。重复进行多个周期后直到模型能够很好地识别数字。 损失函数：交叉熵损失(Cross Entropy Loss) 优化器：随机梯度下降(SGD) 评估模型+预测 卷积层(Convolutions):提取特征 池化层(Subsampling):将特征提取到最突出的元素 全连接层(Full connection):最后OUTPUT为一个十维向量，每一维代表一个数字类别的预测概率 PyTorch实操 验证/安装pytorch 12import torchprint(torch.__version__) # torch.__version__ 返回安装的 PyTorch 的版本号 2.3.0+cpu 准备数据 数据下载：将数据变为适合神经网络模型训练的格式 加载数据：经过预处理，使得数字都位于图像的中心位置，手写数据分类 12345678from torchvision.datasets import MNISTfrom torchvision.transforms import ToTensor# 定义保存或加载数据集的位置path = &#x27;~/.torch/datasets/mnist&#x27;# 下载并定义数据集train = MNIST(path, train=True, download=True, transform=ToTensor())test = MNIST(path, train=True, download=True, transform=ToTensor()) 处理图像数据 PIL图像：以像素数组的形式保存，每个像素点数字范围为0~1，这样就会有无限的精度 123456789101112131415from PIL import Imageimport torchvision.transforms as transforms# Load the image using PILimage_path = &#x27;./personal/1.png&#x27;image = Image.open(image_path)# Convert the image to a PyTorch tensortransform = transforms.ToTensor()tensor = transform(image)print(image)# Check the tensor shape to confirm conversiontensor.shape, tensor.dtype # (torch.Size([3, 1024, 1024]), torch.float32) &lt;PIL.PngImagePlugin.PngImageFile image mode=RGBA size=1920x1200 at 0x1B6D50F8F10&gt; (torch.Size([4, 1200, 1920]), torch.float32) 数据集划分: 将数据划分为更小的batch(子数据集),增加处理大量数据的效率 通过枚举的方式进行训练 1234# 定义如何枚举数据集from torch.utils.data import DataLoadertrain_dl = DataLoader(train, batch_size=64, shuffle=True)test_dl = DataLoader(test, batch_size=1024,shuffle=False) 定义模型 特征提取 卷积：将矩阵和一组权重相乘，生成一个新的二维数组 卷积核(kernel),对某个局部的加权求和，决定了权重矩阵 特征图(feature map),一个特征图对应一个图像的一个特征 不同的卷积核和同一个卷积组合，生成了不同的特征图，这些二维的特征图实际上实现了一个三维的卷积层。层数越高，可以识别的特征越高级 层与层之间会有若干个卷积核，上一层的每个特征图跟每个卷积核做卷积，都会产生下一层的一个特征图 输入的特征图也可以是多个，例如RGB 池化： 逐渐缩小表示空间的大小以提高计算效率 会单独对每个特征图进行运算 常用方法：最大池化 全连接层： 对前面卷积层提取的特征进行整合，以进行最终的分类决策 将前一层的所有神经元与当前层的每个神经元相连接，从而使网络能够理解并学习到图像更加复杂的特征 定义继承自Module父类的类CNN 建立方法__init__ 第一个卷积层使用Conv2d创建二维卷积层，接收n_channels个输入通道，输出32个特征图，使用3X3的卷积核进行卷积运算 使用kaiming_uniform_方法初始化权重(weight也称为参数)，并设置激活函数为relu (机器学习的关键是更新每次卷积的权重) 激活函数，做出是否要传递信息的决定门 第一个池化层将特征图分割成2X2大小的区域，并从每个区域中取最大值(最大池化) stride(2,2)是池化操作的步长 这意味着池化窗口每次移动两个像素，有效减少了特征图的维度 作用： 保留了最大特征的同时减少了尺寸 减少过拟合，减少泛化能力 第二层卷积层的作用是进一步提取池化层的特征，需要注意的是Conv2d的第一个参数由n_channels变成了32，这是因为这里的输入是第一层卷积层的输入 这意味着我们从32个3x3的卷积核中进行操作，并将从每个位置的3x3区域提取特征，并输出32个新的特征通道 第二层池化的作用： 通过减少特征图的空间尺寸，来降低后续网络层的计算负载 在一定程度上增强模型的抗噪声能力 通过这两层的连续操作，我们的CNN能够逐渐抽象图像内容，将原始输入转化为高级特征，从而对后续的分类或其他任务提供必要的信息 第一个全连接层将5x5x32个线索转化为100个有意义的概念 使用kaiming_uniform来初始化这个处理中心的连接权重 RELU激活函数引入了一种非线性的思考方式，让神经网络捕捉到更加复杂的模式和联系 第二个全连接层将提炼出的100个概念进一步简化为10个最终的决策，每一个决策都对应着一个手写数字的类别（0~9） 使用xavier_uniform_的方法来初始化每个连接的权重 使神经网络的网既不是太紧也不是太松–权重适中，柔韧性与强度兼得 如果权重过大–神经网络僵硬，难以捕捉细微的特征 如果权重过小–神经网络松散，容易错过重要的模式 xavier_uniform_通过初始化权重为一个均匀分布的值，帮助神经网络一开始时就保持了一种平衡状态 Softmax为激活函数，它将决策中心的输出转换为概率分布。使神经网络能够根据概率最高的类别来做出最终的预测 123456789101112131415161718192021222324252627from torch.nn import Moduleclass CNN(Module): # 定义模型属性 def __init__(self, n_channels): super().__init__() # 输入到卷积层 1 self.hidden1 = Conv2d(n_channels, 32, (3,3)) kaiming_uniform_(self.hidden1.weight, nonlinearity=&#x27;relu&#x27;) self.act1 = ReLU() # 池化层 1 self.pool1 = MaxPool2d((2,2), stride=(2,2)) # 卷积层 2 self.hidden2 = Conv2d(32, 32, (3, 3)) kaiming_uniform_(self.hidden2.weight, nonlinearity=&#x27;relu&#x27;) self.act2 = ReLU() # 池化层 2 self.pool2 = MaxPool2d((2,2), stride(2,2)) # 全连接层 1 self.hidden3 = Linear(5*5*32, 100) kaiming_uniform_(self.hidden3.weight, nonlinearity=&#x27;relu&#x27;) self.act3 = RELU() # 全连接层 2 self.hidden4 = Linear(100, 10) xavier_uniform_(self.hidden4.weight) self.act4 = Softmax(dim=1)","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"author":"tugumineko"},{"title":"markdown-syntax","slug":"markdown-syntax","date":"2024-04-29T10:35:23.000Z","updated":"2024-05-23T11:53:09.248Z","comments":true,"path":"2024/04/29/markdown-syntax/","permalink":"http://example.com/2024/04/29/markdown-syntax/","excerpt":"","text":"注： 点击run查看效果 Markdown 标题语法 #的数量代表了标题的级别 Heading level 1 Heading level 2 Heading level 3 Heading level 4 Heading level 5 Heading level 6 ==标识一级标题，–标识二级标题(两个及两个以上) Heading level 1 Heading level 2 段落，请使用空白行将一行或多行文本进行分割,但是间距是固定的。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. 换行，在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. &lt;br&gt;也可以换行 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. Markdown 强调语法 粗体，两个星号**或__ 斜体，一个星号*或_ -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. Markdown 引用语法 块引用，请在段落前添加一个 &gt; 符号。 块引用可以包含多个段落。为段落之间的空白行添加一个 &gt; 符号。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. 块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. Markdown 列表语法 有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。(列表只会按照12345的顺序进行) 同一序号的需使用换行符。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. 无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. 与引用块结合使用。也会达到缩进效果。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. 代码块 代码块通常采用四个空格或一个制表符缩进。当它们被放在列表中时，缩进八个空格或两个制表符。但是这样会造成多重缩进。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. -I'm you. So am I GOD?? -No, as Jesus said, *you are just not only a bitch, but also son of a bitch.* -😅Yes, you are right. Fuck the **Jesus**. -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. Markdown 围栏代码块 受保护的代码块(不缩进),根据Markdown处理器或编辑器的不同，您将在代码块之前和之后的行上使用三个反引号（(```）或三个波浪号（~~~）。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. 123-I&#x27;m you. So am I GOD??-No, as Jesus said, *you are just not only a bitch, but also son of a bitch.*-😅Yes, you are right. Fuck the **Jesus**. 图片 见markdown图片语法 Markdown 代码语法 要将单词或短语表示为代码，请将其包裹在反引号 (`) 中。 代码语法和代码块的显示是不一样的。 -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. Markdown 分隔线语法 在单独一行上使用三个或多个星号 (**)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。为了兼容性，请在分隔线的前后均添加__空白行__. -I’m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -😅Yes, you are right. Fuck the Jesus. Markdown 链接语法 超链接Markdown语法代码：[超链接显示名](超链接地址 &quot;超链接title&quot;)(链接title可选)(链接地址要写完整) 这是一个链接 Hello World。 使用尖括号&lt;&gt;https://tugumineko.github.io/ 强调链接, 在链接语法前后增加星号。 要将链接表示为代码，请在方括号中添加反引号。 This is Hello World. This is Hello World. This is Hello World. 为了兼容性，在写链接时请尽量使用%20代替空格。 Markdown 图片语法 代码格式![图片alt](图片链接 &quot;图片title&quot;) 对应的HTML代码：&lt;img src=&quot;图片链接&quot; alt=&quot;图片alt&quot; title=&quot;图片title&quot;&gt; Markdown 转义字符语法 要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \\ 在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要使用这些符号，你必须要使用实体的形式，像是 &amp;lt; 和 &amp;amp;。 兼容html的常用语法 删除线，一个或两个波浪~~ 下划线，&lt;u&gt;&lt;/u&gt; 上标 ，&lt;sup&gt;&lt;/sup&gt; 下标，&lt;sub&gt;&lt;/sub&gt; 小号字体，&lt;small&gt;&lt;/small&gt; 大号字体，&lt;big&gt;&lt;/big&gt; 文本高亮，&lt;mark&gt;&lt;/mark&gt; violantis主题特有的标签插件 传送门 使用标签插件时,若要换行，请使用html语法&lt;br&gt;,出现:时要使用反斜杠\\","categories":[{"name":"markdown","slug":"markdown","permalink":"http://example.com/categories/markdown/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}],"author":"tugumineko"},{"title":"素晴らしき日々～不連続存在～","slug":"素晴らしき日々","date":"2023-12-23T03:36:27.000Z","updated":"2024-05-05T05:09:12.149Z","comments":true,"path":"2023/12/23/素晴らしき日々/","permalink":"http://example.com/2023/12/23/%E7%B4%A0%E6%99%B4%E3%82%89%E3%81%97%E3%81%8D%E6%97%A5%E3%80%85/","excerpt":"","text":"世界是没有意义的。婴儿哭着来到这个世界,又不可避免地注定死亡。人的奋斗，人的情感，人的财产，人的选择对于这一切毫无意义。因此，我们不知道死亡的意义，我们无比惧怕死亡，可是无论是化身救世主，还是试图走到世界的尽头与亡者相见，死亡终会到来，我们无法愿终。世界上没有救世主，人类没有意义，世界毫无意义。 世界是有界限的。因为万物皆生，一切有限，终将回归与此。水天一色，天空回转，不可到达终点。世上没有世界末日，我们也不可回归天空。当我们无限存在于世界，美好的每一天也终将索然无味。世界没有尽头，可无限最终回归界限。无论有没有终之空，世界都是有界限的。 我们竭力渴求天空的终点，不顾一切地追求死亡的真相，这是没有意义的，因为真相存在于世界之外。世界是有界限的，世界又没有意义。尽管如此，人脑比天空更宽广，比海洋更宽阔。母亲使间宫卓司生于皆木，皆木使水上由岐生于自我之上，羽咲使皆木战胜自我而重生。也许PTSD而生的多重人格会带来无尽的痛苦，可对于皆木来说，由岐的帮助，镜和司的回忆，与卓司的对峙，一切都是真实的。人的意义不会因为世界而改变，可人的意识可以改变世界，最终战胜一切，甚至回归天空。人的意识不仅存在于世界，也存在于清明梦，更重要的是，它存在于需要你的人的精神之中。痛苦的不仅是你自己，而是大家啊，是这个世界啊。万物轮回，向死而生，可精神永存。真相，确实存在于世界之外，可并非无法触及。 人啊，幸福地活下去吧！尽管世界没有意义，我们也要做好每一个选择，体会每一丝情感，守护我们的美好，度过美好的每一天，就让我们永存的意识，这不连续的存在，去探求存在于世界之外的真相吧。","categories":[],"tags":[{"name":"黄油","slug":"黄油","permalink":"http://example.com/tags/%E9%BB%84%E6%B2%B9/"}],"author":"tugumineko"},{"title":"高雅创作","slug":"高雅创作","date":"2020-04-11T16:00:00.000Z","updated":"2024-05-05T08:20:49.674Z","comments":true,"path":"2020/04/12/高雅创作/","permalink":"http://example.com/2020/04/12/%E9%AB%98%E9%9B%85%E5%88%9B%E4%BD%9C/","excerpt":"我上初一的时候，有个女生从别的班级转来，她属于话题性人物，很多男生女生都会偷偷的讨论她…正好她的座位在我前面，本人那时候就是完全的小孩子性格， 没事喜欢和朋友追逐打闹之类的，在男女之事完全就没有啥概念，她个性开朗，又喜欢开玩笑，一来二去，我也慢慢的和她关系熟络了起来… 我和她都是会上晚自习的，每次晚自习的时候，她都会做到我边上，我那时候是真的单纯，长相也是那种可爱型的… 她很喜欢跟我开玩笑，一开始我就是把她当作男生一样的相处，她学习也很好，大多数考试，我都会把自己不会做的题目写在纸上丢给她，她都会帮我写了再传给我。 我还记得她经常会忽然跳到我背上，双臂搭载我的脖子上，说实话，我再怎么单纯也有点不好意思的感觉，只能极力隐藏尴尬，继续和她开玩笑 她长得也是萝莉型的，身材苗条，但是胸部…一马平川…丸子头，功课好，画画好，之前也谈过恋爱，不过我那时候根本对她的感情生活没啥兴趣，还是朋友告诉我的 每天晚自习，我都和她不停的开玩笑聊天，玩魔方…下五指琪，慢慢的我就感觉我们越来越亲密，她会开始时不时的用手捏我的脸，玩魔方的时候也会用她的👋抓着我的手教我… 那时候我是真的单纯，不瞒大家，我那时候还不会打飞机…也不知道男女之间的事情，甚至连大姨妈这类的我都不知道，每天就是和同学打打闹闹… 也从来没有和那些所谓的流氓混混有过任何接触… 有一天晚上晚自习，她坐在我边上，我们正在嬉戏打闹…她忽然用手把我的脸颊抓起来，然后竟然在安静的教室里亲了我的嘴唇…我整个人都直了…感觉自己要飞升… 她的五官漂亮，兔牙，反正可爱…在我呆愣中她也不说话直接把头转过去，也不知道在想什么，不过接下来，她的手抓着我的手十指相扣…我紧张的手心全是汗…真的是窘态百出…","text":"我上初一的时候，有个女生从别的班级转来，她属于话题性人物，很多男生女生都会偷偷的讨论她…正好她的座位在我前面，本人那时候就是完全的小孩子性格， 没事喜欢和朋友追逐打闹之类的，在男女之事完全就没有啥概念，她个性开朗，又喜欢开玩笑，一来二去，我也慢慢的和她关系熟络了起来… 我和她都是会上晚自习的，每次晚自习的时候，她都会做到我边上，我那时候是真的单纯，长相也是那种可爱型的… 她很喜欢跟我开玩笑，一开始我就是把她当作男生一样的相处，她学习也很好，大多数考试，我都会把自己不会做的题目写在纸上丢给她，她都会帮我写了再传给我。 我还记得她经常会忽然跳到我背上，双臂搭载我的脖子上，说实话，我再怎么单纯也有点不好意思的感觉，只能极力隐藏尴尬，继续和她开玩笑 她长得也是萝莉型的，身材苗条，但是胸部…一马平川…丸子头，功课好，画画好，之前也谈过恋爱，不过我那时候根本对她的感情生活没啥兴趣，还是朋友告诉我的 每天晚自习，我都和她不停的开玩笑聊天，玩魔方…下五指琪，慢慢的我就感觉我们越来越亲密，她会开始时不时的用手捏我的脸，玩魔方的时候也会用她的👋抓着我的手教我… 那时候我是真的单纯，不瞒大家，我那时候还不会打飞机…也不知道男女之间的事情，甚至连大姨妈这类的我都不知道，每天就是和同学打打闹闹… 也从来没有和那些所谓的流氓混混有过任何接触… 有一天晚上晚自习，她坐在我边上，我们正在嬉戏打闹…她忽然用手把我的脸颊抓起来，然后竟然在安静的教室里亲了我的嘴唇…我整个人都直了…感觉自己要飞升… 她的五官漂亮，兔牙，反正可爱…在我呆愣中她也不说话直接把头转过去，也不知道在想什么，不过接下来，她的手抓着我的手十指相扣…我紧张的手心全是汗…真的是窘态百出… 你们想想，一个心态只有初中生，却被一个异性忽然做出这种举动的时候，我的大脑才忽然意识到，她是女生，就在这一刻我对待她的感觉也完全变了，感觉有点害羞了… 但是她的👋的触感又让我舍不得放开，就这么紧紧的抓了一个小时… 一个完全没有谈过恋爱的我… “哈哈，你…” “做我男朋友吧” 她在我耳边轻轻的说着… 我的脸都红了… 反正感觉我和她的性别好像换了过来… 我的心脏一直在剧烈的狂跳… 然后本能的，把手放在她穿着短裤的腿上… “你原来也不是什么都不懂嘛…色狼” “没…没有，我有点不自觉的就这样了” 好不容易等到晚自习放学，教室里的人都走的差不多了，我和她都很默契的没有动，等到教室里一个人都没有了，我就靠近她然后也亲上了她的👄… 这感觉确实让我这个老实人上瘾… “你怎么这么笨，我来带你” 她就把👅慢慢的撬开我的牙齿，伸进了我的嘴里搅拌… 我感觉自己的极限不断的被她突破，真的感觉找到了新大陆一样… 就不断的迎合着她， 整个教室那就是我们两个亲嘴的啧啧啧声了… 与此同时我的胯下其实早就嗯了… 涨的超级难受… 但是不知道怎么弄… 只能双手不停的覆膜着她的🦵… 感觉🐎👀都出💧了… 她应该是属于有些经验的女生了… 一只手也在我的身上来回膜… 也隔着我的运动裤膜到了我的🐛… “哇…不得了…小xx（这是她平时对我的称呼）” 我那是尴尬的不得了… 在她的👋握住我的🐛的时候我就感觉那里要爆炸了… 她的手上还有我🐛分泌出来的💧… 我以为男女之间应该这就是极限了… 然后她竟然用手脱掉了我的运动裤… 我的🐛就直直的挺着…还兴奋的一抖一抖的… “小xx，我来帮帮你” 然后她就开始慢慢的上下tao弄我的🐛… 我全程一句话都没有说，不是我不想说，是我整个人都傻眼了，感觉就是个机器在被她调试着… 她的手法在现在来看其实很一般，就是那种单纯的lu，没有设啥花样，但是对那个时候啥都懵懂的我真的是“刘姥姥进大观园” 我被她弄的不停的粗喘着… “你，这是在干嘛啊，我有点想上厕所…” “你不会没打过✈️吧？” 她也有点正经… 但是👋上动作一点没停，还越来越快… “别动，没事的，不用上厕所” “可是我忍不住了啊，求求你让我去一下，我怕尿出来…” “扑哧”她看着我一脸紧张的样子忍俊不禁 “嘶呼～不行了不行了…有什么要出来了” 这种感觉越来越激烈，我真的怕尿出来，那我还怎么见她啊！ “没事，没事，出来吧，🐍出来～不要怕～” 她一只手把我的上半身顶在旁边的墙上，我们都是坐着的… 她的另一只👋动作越来越快… “没事，小xx，🐍出来～” 从那一次她帮我打完✈️过后，我感觉每天脑袋里就只有这种事情了，贼上瘾… 先说说她的之前的故事吧，在我之前她谈过两个男朋友，都是那种很会玩的混混… 各种姿势，各种玩法，都和她玩遍了… 她觉得我是那种很单纯的，而且和我在一起感觉很好，就忍不住想把我tj起来… 我真的没想到一脸清纯的女生竟然也有这么大的反差的一面 从那天晚上过后，我们的相处方式真的完全变了，虽然在朋友面前还是和以前一样，但是她会不经意的看我的胯下，然后笑嘻嘻的看着我… 晚自习也会膜我的🦵，然后当着讲台上的老师偷偷把手伸进我的裤子里，覆膜我的🐛… 我也会经常膜她的🦵，而且偶尔还会大胆的伸进她的短裤里隔着nk膜她的🍺… 那柔软的触感…我第一次还震惊了，但是从来没有看过她的🍺…心里特别好奇 有一天周末，打电话让我去她在学校周围租的房子里…说要教我其他新的东西… 我一听那里忍得住，和我妈说，晚上要去同学家里做功课，不回家了。 然后就骑着自行车快速的往她家里赶去 我一进她家，她就跳到我身上，整个人像只八抓鱼一样的，然后就和我疯狂的🐍💋… 被她指引着进了卧室…然后就被她一下按在🛏️上了… 她从柜子里拿出了绳子，把我的双手绑住，然后又把我的双🦵分别绑在床的两个脚… “你这是干嘛啊…” “这样玩cj呀…嘿嘿” 别说我感觉还真的有点爽～ 她弄好后，又从柜子里拿出了润滑油… 然后退掉我的👖… 用沾满润滑油的👋慢慢的🍵jin我的py… “卧槽…aaaa…好疼” “宝贝…忍一忍，等会就很舒服了…嘿嘿” 我挣扎着，但是没法动… 噗嗤～噗嗤～ “aoaoaoaoa…” 她的☝️慢慢的深入… 刚开始真的很疼，不过慢慢的真的感觉有点异样的愉悦感… “宝贝…我没骗你吧…嘿嘿” “以后你会求着我的…嘿嘿” 而且因为她的☝️在我的py抽查，我的🐛超级嗯… 她就一边弄我py，一边用👋帮我🦌… 我整个人就是不停的喘气哼唧… “要🐍了一定要告诉我哦”她在我耳边吹这起，轻轻的说着… 我不住的点头… 反正我当时🧠一阵空白，双重cj，我感觉我要升天了，因为已经突破我的肉体极限了… 大概过了十分钟左右，我的🐛就到达了承受的极限了…我知道应该要缴械了… “宝贝…我要🐍了…马上了…” “嗯…乖，” 她一只手扶着我的🐛身，然后👄直接喊住我的🐢…不停的x… 滋溜滋溜～ 这是她第一次给我k… “🐍吧，宝贝…全部🐍出来哦…不许私藏哦” “呼呼～来了来了…” 随着它最后的几下…我整个人到达了极限，身体绷直… 一gg，jy不停的在她的👄中倾斜… “呜呜…”她怕打着我的🦵… 她没有把我的jy屯进去… 而是吐在我半软的贴着我的肚子上的🐛身边上，然后拿出了诺基亚（那时候都用这个牌子）给我照了我整个人的窘态和惨状… 我当时心里就有一种屈辱感… 感觉自己被她玩坏了… 她看出我难受就趴在我身上，和我🐍💋… “小xx，乖，我给你看我的那里…好不好” 不得不说这货是真的把我拿捏的ss的… 或许这种念头她很早就在计划了… 在我期待的目光中，她慢慢的退掉了👖，和卡通nk… 然后把她的🍺靠近我的面前… “宝贝，让你看个够吧…嘿嘿，给你补偿。” 这是我第一次看到女生的🍺… 没有很多髦… 但是yc是粉色的… 我的心脏又开始狂跳… “宝贝，知道怎么用吗？” 我要了摇头… “我接下来就告诉你，她是怎么用的” 说着直接敷着我又嗯起的🐛，在她的🍺🚪来回的蹭… 然后慢慢的一点点的往里🍵… “oa…嘶～” 🧠爆炸了，这种感觉对当时我的来说简直就是不可思议，我赞叹造物主的神奇，原来男女之事这么美妙… “小xx，你的比我前男友的好用哦…” 我的虫身全部进去她的🍺之后，她开始慢慢的↕️浮动着… papapapapa～ 她爬在我身上在我的脖子上不停的啃不停的💊，不停的x… “求我，小xx，不然我不动了” 我刚尝到甜头哪里舍得 立马恳求道“求你了～宝贝…这样很舒服…” 她得意的坐在我的身上驰骋着… 然后用👋抓着我的脖子… 我的脸都憋的红了… papapap，整个房间都是这样的声音 我就感觉她的🍺越来越多💧… 留到我的🦵上全都是… 噗嗤噗嗤～ “宝贝，老公，好lihai，千万别🐍哦…再忍忍…等我一起…” 我的第一次就是被她bang再🛏️⬆️，任她动作，连我什么时候🐍、也必须按照她的想法。 因为她说“如果我提早🐍了，她一个星期都不会理我了” 我知道，现在我已经离不开她了，这么一步步的，喔的心和🐛早就沉沦在她的身上无法自拔了… papapapap “记得要🐍的时候一定要告诉我哦，不能🐍在我里面的宝贝…” “嗯…嗯…”不知道为什么平时在学校我都是和她有说有笑，也经常调侃她，可是在这方面我却被她牢牢的把控者，没有丝毫的自主权… 因为我🐍过了一次，第二次比较久，大概半个多小时，我就忽然说到 “不行了不行了…忍不住了宝贝…” 她没有回应我，只是忘情的在我的身上索取快感… 只是发出那种声音而已，脸上也是一阵的红晕… “不行了不行了，快拿出来啊…” 她还是不理我，就这样不停的动… 就在我快要爆发的时候，她起身，快速的用手🦌我占满了她的💧的🐛… “好了，你的任务达成了，辛苦你了宝贝，快🐍吧…” 大概快速的套n了五六下… 我的🐛又在她的👋里爆发了… 我的肚子，她的下巴…全是jy… 她看着我张脸shuang的都有点扭曲了，不禁捂嘴轻笑… “傻瓜，这样就把你shuang成这样了，真没出息，嘿嘿” 说着她就整个头埋在我的胸膛上… “宝贝…” 然后👅却不自觉的在我的胸膛上来回滑动着… 洁白的的🦵跨在被她bang在🛏️脚的我的dang部… “你放开我吧…这样我感觉好屈辱…” 她却嘿嘿笑着… “想的美，我才不会轻易放了你呢” “哎，这样真的很丢脸…” “我不管，自己🐍舒服了，就要按照我的人来” 我现在只能被动的享受，可是她却在我身上肆无忌惮的发挥… 她就像一只小狐狸一样，游走在我身上每个器官… 我真的感觉我整个人在她的眼里现在已经没有任何的隐私可言了… 她的👋把玩着我的🐛部位… “宝贝…你要是累了就睡吧” “你这样让我怎么睡啊！” 我无奈的对着她说着… 我要和大家说一下：别看我和她私下是这样的，其实再学校的时候，我们还是朋友关系，打打闹闹，开开玩笑…而且她还会故意的被我欺负… 别人都说，xx你为什么老是欺负她，她是女生啊… 可是他们哪里知道，私下我却被她乱玩… 一点尊严都没有… 我们学校之后有一对情侣中午在升旗台xx，被发现了，最后把双方的家长都叫过来了，差点开除了… 那时候大家思想都很闭塞的，被知道那是一件很丢人的事情，但是我们还是没忍住… 有一次晚自习结束了以后，我就偷偷靠近她的耳边“宝贝，今晚我们去科技楼那里吧！ 这栋楼一般都是上电脑课，做物理实验的楼… 晚上大门都锁住了，属于半开放式的，很容易就能爬进去… 我朋友还让我和他一起骑车回家，我说“我有点事，你先走”糖塞了过去… 大晚上的，那时候应该是春天，我和她偷偷溜进去了之后，就开始一层一层的找适合隐蔽的战场… 因为有先例在，我们真的怕被发现… 所以找了半天还是选了四楼的一个比较隐蔽的楼梯道，但是还是能看到楼下的情形… 真的很cj 她那时候穿的是白色的运动裤，我也是运动裤… 所以很方便… 她双手扶着栏杆… 她给了我之前和她前男友没用完多余的好多tt… 我的🐛带上过后，就一只手扶着她的pp调整好角度，慢慢的🍵🍺了… 外面还有点小冷，但是她的🍺里很温暖… “嗯…” 她轻轻的哼了一声，代表我已经jinru了… papapapap 整个楼出奇的安静，可是我们🐛🍺碰撞的声音显得很大… 我真的是在紧张和cj中🍵她… “别太快了，小xx…你不怕被发现啊…” “我控制不住速度啊…太shuang了…” papapapa… 我的旦旦拍打着她… 可能真的是太cj了，我的🐛没有🍵几下她的🍺就已经模糊一片了… 💧都到🦵上了… 我抓着她的丸子头，发泄一般的用力zhuangji… “别…别这么快，宝贝你疯了吧，别发现你负责啊” “我管不了那么多了…” 她每次要gc的时候都会用手狠狠的抓我的大腿，时不时的还会拍打… 我看她这样，也差不多，就像冲刺了，因为我感觉自己的🐛也要🐍了… papapapap… “不行了宝贝，太cj了，我缴械了…” 她没有回应我…给我感觉只是在享受我的🐛给她的🍺带来的满足感… 我快速的chou出已经张到极致的🐛… 把她的白色运动裤帮她穿起来，脱掉tt，然后用手🦌着… 直接🐍到了她的裤子上… “讨厌～你s这里我怎么回家～有jy的味道” 她用手点了下我的🐢“今天就放过你，下次可没那么容易让你休息哦” “我感觉我和你在一起这段时间越来越瘦了…” 这样下去我会静尽人亡的… “那可不关我的事哦，嘿嘿” 我们完事了之后就这样离开了这片战场… 我每次去她家的时候她都会把我当作工具一样使用，这时候，我是完全不可以反对她或者对她提意见的… 必须要按照她的tj… 有时候，我真的想自己动，不想被她永绳子束缚住，她就说必须在我s之前让她gc才行… 我肯定就答应了，可是她会不停的给我k，然后🦌，她知道我🐛的敏感点…等我🐛的状态不行了然后才放到她的🍺里… 我根本顶不住… 而且偶尔她还会给我下任务…就是没有🍵到多久就会用👋玩我的py… 有一次，她把我的双手bang住，然后把我的双🦵高高抬起… 然后我的🐛夹在双🦵中间，她就会用手指在我的py里不停的酬🍵… 而且每次她🍵我py的时候我的🐛都会特别的嗯… 她就是喜欢两面开工… 🐍完了也不会停下… 有一次我连续被她弄🐍了三次，才肯放过我瘫软的🐛身，可是py那里她还是不停的进攻… 我必须恳求她说她是我的主人，才会考虑放不放过我… 我和她的角色是经常形成反差的… 别人怎么都不会想到，一个可爱漂亮的萝莉私下会这么wan弄我… 我第一次开发她的py，是半年后了… 她之前一直不肯，然后我去她家的时候，没有像平时一样被她摆n… 我直接熟练的找出她平时藏绳子的地方把她给bang了… 然后在她疯狂的挣扎中，从她的短裤一角里🍵🦌了她的🍺… 我的🐛↕️了大约50多下左右，就tu上了润滑…在她的哀求下…一点一点的试探… “小xx…看在我平时帮你作弊，让你快乐的份上，放过这里好嘛…求求求你…” 我没有说话…只是死死的控制着她的双🦵… 在她不甘的求救声中，才勉强的把🐢🍵🦌了… “aaaa…救命啊…宝贝…放过我唯一的秘密地方吧…呜呜呜 出自后宫动漫吧https://tieba.baidu.com/p/6613346148?see_lz=1&amp;pn=2","categories":[],"tags":[]}],"categories":[{"name":"vim","slug":"vim","permalink":"http://example.com/categories/vim/"},{"name":"cpp","slug":"cpp","permalink":"http://example.com/categories/cpp/"},{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"markdown","slug":"markdown","permalink":"http://example.com/categories/markdown/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"},{"name":"文本编辑器","slug":"文本编辑器","permalink":"http://example.com/tags/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数字图像处理","slug":"数字图像处理","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"黄油","slug":"黄油","permalink":"http://example.com/tags/%E9%BB%84%E6%B2%B9/"}]}