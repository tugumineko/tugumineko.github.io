{"meta":{"title":"tugumineko","subtitle":"é¶«ã­ã“","description":"é¶«ã­ã“","author":"tugumineko","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2024-05-05T13:23:31.903Z","updated":"2024-05-05T13:23:31.903Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 å¾ˆæŠ±æ­‰ï¼Œæ‚¨è®¿é—®çš„é¡µé¢ä¸å­˜åœ¨ å¯èƒ½æ˜¯è¾“å…¥åœ°å€æœ‰è¯¯æˆ–è¯¥åœ°å€å·²è¢«åˆ é™¤"},{"title":"","date":"2024-05-05T05:04:05.176Z","updated":"2024-05-05T05:04:05.176Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"åšé¢˜å®¶ äº’è”ç½‘é­”æ€”äºº"},{"title":"æˆ‘çš„æœ‹å‹ä»¬","date":"2024-05-05T13:22:53.684Z","updated":"2024-05-05T13:22:53.684Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"è¿™é‡Œå†™å‹é“¾ä¸Šæ–¹çš„å†…å®¹ã€‚","text":"è¿™é‡Œå†™å‹é“¾ä¸Šæ–¹çš„å†…å®¹ã€‚ è¿™é‡Œå¯ä»¥å†™å‹é“¾é¡µé¢ä¸‹æ–¹çš„æ–‡å­—å¤‡æ³¨ï¼Œä¾‹å¦‚è‡ªå·±çš„å‹é“¾è§„èŒƒã€ç¤ºä¾‹ç­‰ã€‚"},{"title":"æ‰€æœ‰æ ‡ç­¾","date":"2024-05-05T05:03:28.430Z","updated":"2024-05-05T05:03:28.430Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"æ‰€æœ‰åˆ†ç±»","date":"2024-05-05T05:02:45.737Z","updated":"2024-05-05T05:02:45.737Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"çº¿æ€§ä»£æ•°äºŒæ¬¡å‹å­¦ä¹ å°è®°","slug":"Quadratic-form","date":"2024-12-06T15:29:06.000Z","updated":"2024-12-06T16:07:38.989Z","comments":true,"path":"2024/12/06/Quadratic-form/","permalink":"http://example.com/2024/12/06/Quadratic-form/","excerpt":"","text":"äºŒæ¬¡å‹å°±æ˜¯å¯ä»¥ç”¨äºŒå…ƒå‚æ•°è¡¨ç¤ºçš„å¤šé¡¹å¼ï¼Œç³»æ•°ç”¨äºŒæ¬¡å‹çŸ©é˜µè¡¨ç¤ºï¼Œè¿™ä¸ªäºŒæ¬¡å‹çŸ©é˜µå¾ˆå€¼å¾—ç ”ç©¶ã€‚ äºŒæ¬¡å‹çŸ©é˜µå¯ä»¥è¡¨ç¤ºäºŒæ¬¡æ›²çº¿ äºŒæ¬¡å‹çŸ©é˜µä¸€å®šæ˜¯å®å¯¹ç§°çŸ©é˜µï¼Œè¿™æ„å‘³ç€å®ƒå¯ä»¥è¢«æ­£äº¤å¯¹è§’åŒ–ã€‚ ä¸ºä»€ä¹ˆè¦è¢«æ­£äº¤å¯¹è§’åŒ–å‘¢ï¼Ÿè¿™æ˜¯å› ä¸ºï¼Œå¦‚æœè¦åœ¨åˆåŒå˜æ¢å‰åä¿æŒäºŒæ¬¡å‹å…¨ç­‰ä¸å˜ï¼Œå˜æ¢çŸ©é˜µéœ€è¦æ»¡è¶³QTQ=EQ^TQ=EQTQ=Eï¼Œå³Qæ˜¯æ­£äº¤çŸ©é˜µã€‚ è¿™æ ·çš„è¯ï¼Œæˆ‘ä»¬åªè¦ä½¿ç”¨ç‰¹å¾å€¼åˆ†è§£å¹¶ä¸”ç¡®ä¿å‘é‡æ­£äº¤åŒ–ï¼Œå°±å¯ä»¥è½»æ¾å®Œæˆå¯¹è§’åŒ–ï¼Œè¿›è€Œå®Œæˆæ ‡å‡†åŒ–ï¼Œè·å¾—æˆ‘ä»¬æ‰€éœ€çš„ä¿¡æ¯ äºŒæ¬¡å‹çŸ©é˜µçš„åˆåŒå˜æ¢å¯ä»¥è½¬åŒ–ä¸ºæ ‡å‡†å‹ï¼Œä¸”ä¸åŒåŸºå‘é‡ç»„ä¸‹è¡¨ç¤ºåŒä¸€ä¸ªäºŒæ¬¡å‹çš„å®å¯¹ç§°çŸ©é˜µæ˜¯ä¸€ç»„åˆåŒçŸ©é˜µã€‚å…¶ä¸­å¯¹åº”çš„åˆåŒå˜æ¢çŸ©é˜µæ˜¯å¯¹åº”çš„åŸºå˜æ¢çŸ©é˜µï¼Œä»–ä¸€å®šå¯é€†ã€‚ ä¸‹é¢å¼€å§‹æ¤­åœ†æ ‡å‡†åŒ–å’Œæ±‚é•¿çŸ­è½´çš„è¿‡ç¨‹ï¼š æˆ‘ä»¬ä»ç»™å®šçš„äºŒæ¬¡å‹æ–¹ç¨‹(æ¤­åœ†)å¼€å§‹ï¼š ax2+2bxy+cy2=1ax^2 + 2bxy + cy^2 = 1 ax2+2bxy+cy2=1 è¿™ä¸ªæ–¹ç¨‹æ˜¯ä¸€ä¸ªäºŒæ¬¡å‹ï¼Œå¯ä»¥å†™æˆçŸ©é˜µå½¢å¼ï¼š Q(x,y)=[xy][abbc][xy]=1Q(x, y) = \\begin{bmatrix} x &amp; y \\end{bmatrix} \\begin{bmatrix} a &amp; b \\\\ b &amp; c \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} = 1 Q(x,y)=[xâ€‹yâ€‹][abâ€‹bcâ€‹][xyâ€‹]=1 è¿™é‡Œçš„ç³»æ•°çŸ©é˜µæ˜¯å¯¹ç§°çŸ©é˜µï¼š A=[abbc]A = \\begin{bmatrix} a &amp; b \\\\ b &amp; c \\end{bmatrix} A=[abâ€‹bcâ€‹] æˆ‘ä»¬å¸Œæœ›é€šè¿‡åˆåŒå¯¹è§’åŒ–ï¼ˆæ­£äº¤å˜æ¢ï¼‰å°†è¿™ä¸ªçŸ©é˜µè½¬åŒ–ä¸ºå¯¹è§’çŸ©é˜µï¼Œä»è€Œå¾—åˆ°æ ‡å‡†æ¤­åœ†çš„å½¢å¼ã€‚è¿™æ ·å°±å¯ä»¥å¾—åˆ°é•¿çŸ­è½´ã€‚ å‡è®¾çŸ©é˜µ AAA çš„ç‰¹å¾å‘é‡åˆ†åˆ«ä¸º v1v_1v1â€‹ å’Œ v2v_2v2â€‹ï¼Œåˆ™çŸ©é˜µ PPP ç”±è¿™ä¸¤ä¸ªç‰¹å¾å‘é‡ç»„æˆï¼Œä¸”ï¼š P=[v1v2]P = \\begin{bmatrix} v_1 &amp; v_2 \\end{bmatrix} P=[v1â€‹â€‹v2â€‹â€‹] å¦‚æœæˆ‘ä»¬ä½¿ç”¨çŸ©é˜µ PPP è¿›è¡Œåæ ‡å˜æ¢ï¼Œå³ä»¤æ–°çš„åæ ‡ xâ€²x&#x27;xâ€² ä¸ºï¼š xâ€²=Pâˆ’1xx&#x27; = P^{-1} x xâ€²=Pâˆ’1x é‚£ä¹ˆï¼Œç»è¿‡åæ ‡å˜æ¢åï¼ŒäºŒæ¬¡å‹æ–¹ç¨‹å˜ä¸ºï¼š xâ€²TÎ›xâ€²=1x&#x27;^T \\Lambda x&#x27; = 1 xâ€²TÎ›xâ€²=1 å…¶ä¸­ Î›=diag(Î»1,Î»2)\\Lambda = \\text{diag}(\\lambda_1, \\lambda_2)Î›=diag(Î»1â€‹,Î»2â€‹) æ˜¯å¯¹è§’çŸ©é˜µï¼ŒåŒ…å«äº†äºŒæ¬¡å‹çš„ç‰¹å¾å€¼ã€‚ x1â€²21Î»12+x2â€²21Î»22=1\\frac{x_1&#x27;^2}{\\frac{1}{\\sqrt{\\lambda_1}}^2} + \\frac{x_2&#x27;^2}{\\frac{1}{\\sqrt{\\lambda_2}}^2} = 1 Î»1â€‹â€‹1â€‹2x1â€²2â€‹â€‹+Î»2â€‹â€‹1â€‹2x2â€²2â€‹â€‹=1 è¿™æ„å‘³ç€ï¼š é•¿è½´çš„åŠé•¿è½´ a=1Î»1a = \\frac{1}{\\sqrt{\\lambda_1}}a=Î»1â€‹â€‹1â€‹, çŸ­è½´çš„åŠé•¿è½´ b=1Î»2b = \\frac{1}{\\sqrt{\\lambda_2}}b=Î»2â€‹â€‹1â€‹. ä¸ºäº†å¯¹è§’åŒ–çŸ©é˜µ AAAï¼Œæˆ‘ä»¬é¦–å…ˆæ±‚è§£å…¶ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡ã€‚ç‰¹å¾å€¼ Î»1\\lambda_1Î»1â€‹ å’Œ Î»2\\lambda_2Î»2â€‹ æ˜¯çŸ©é˜µ AAA çš„è§£ï¼Œæ»¡è¶³ä»¥ä¸‹ç‰¹å¾æ–¹ç¨‹ï¼š detâ¡(Aâˆ’Î»I)=0\\det(A - \\lambda I) = 0 det(Aâˆ’Î»I)=0 å³ï¼š detâ¡[aâˆ’Î»bbcâˆ’Î»]=0\\det\\begin{bmatrix} a - \\lambda &amp; b \\\\ b &amp; c - \\lambda \\end{bmatrix} = 0 det[aâˆ’Î»bâ€‹bcâˆ’Î»â€‹]=0 è®¡ç®—è¡Œåˆ—å¼ï¼š (aâˆ’Î»)(câˆ’Î»)âˆ’b2=0(a - \\lambda)(c - \\lambda) - b^2 = 0 (aâˆ’Î»)(câˆ’Î»)âˆ’b2=0 å±•å¼€åå¾—åˆ°ï¼š Î»2âˆ’(a+c)Î»+(acâˆ’b2)=0\\lambda^2 - (a + c)\\lambda + (ac - b^2) = 0 Î»2âˆ’(a+c)Î»+(acâˆ’b2)=0 è¿™ä¸ªæ–¹ç¨‹çš„è§£å°±æ˜¯çŸ©é˜µ ( A ) çš„ç‰¹å¾å€¼ ( \\lambda_1 ) å’Œ ( \\lambda_2 )ï¼Œåˆ†åˆ«ä¸ºï¼š Î»1,Î»2=(a+c)Â±(a+c)2âˆ’4(acâˆ’b2)2\\lambda_1, \\lambda_2 = \\frac{(a + c) \\pm \\sqrt{(a + c)^2 - 4(ac - b^2)}}{2} Î»1â€‹,Î»2â€‹=2(a+c)Â±(a+c)2âˆ’4(acâˆ’b2)â€‹â€‹ è¿™ä¸¤ä¸ªç‰¹å¾å€¼å³ä¸ºäºŒæ¬¡å‹çš„ä¸»è½´æ–¹å‘ä¸Šçš„ç³»æ•°ï¼Œå®ƒä»¬å†³å®šäº†æ¤­åœ†çš„é•¿çŸ­è½´ã€‚ 12345678float det = (cov.x * cov.z - cov.y * cov.y);if (det == 0.0f) return;float det_inv = 1.f / det;float3 conic = &#123; cov.z * det_inv, -cov.y * det_inv, cov.x * det_inv &#125;;float mid = 0.5f * (cov.x + cov.z);float lambda = mid + sqrt(max(0.01f, mid * mid - det));float my_radius = extent * sqrt(lambda);","categories":[],"tags":[{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}],"author":"tugumineko"},{"title":"è®ºæ–‡é˜…è¯»ï¼šMini-Splatting2:Building 360 Scenes within Minutes via Aggresive Gaussian Densification","slug":"mini-splatting","date":"2024-12-02T10:39:01.000Z","updated":"2024-12-07T08:43:13.638Z","comments":true,"path":"2024/12/02/mini-splatting/","permalink":"http://example.com/2024/12/02/mini-splatting/","excerpt":"","text":"ç®€è¿° æœ¬æ–‡åŸºäº3DGSè¾å°„åœºæ–¹æ³•ï¼Œæå‡ºäº†ä¸€ç§æ–°çš„ç‚¹äº‘åˆ†å¸ƒå’Œä¼˜åŒ–ç­–ç•¥æ¡†æ¶ï¼Œä»è€Œåœ¨ç»´æŒ3DGS visualizationè´¨é‡å·®åˆ«ä¸å¤§çš„æƒ…å†µä¸‹ï¼Œå®ç°ä¸ªä½æ•°åˆ†é’Ÿçº§çš„è®­ç»ƒé€Ÿåº¦ã€‚æœ€ç»ˆè¾¾åˆ°äº†render qualityå’Œoptimization efficiencyçš„trade-off. è¯¥æ–¹æ³•ä»¥ä¸é€æ˜åº¦ç¡®å®šçš„Gaussian importanceä¸ºåŸºç¡€(core metric)ï¼Œæå‡º(1)aggressive Gaussian densificationï¼Œåˆ©ç”¨å…‰çº¿æ±‚äº¤å¾—å‡ºdepth pointé‡æ„ç‚¹äº‘(depth reinitialization)ï¼ŒåŒæ—¶åŠ å…¥critical Gaussian identification&amp;&amp;aggresive Gaussian clone,é˜²æ­¢depth reinitializationå¯¼è‡´çš„ç‚¹äº‘æ•°é‡çˆ†ç‚¸å’Œå›¾åƒè´¨é‡ç ´åçš„é—®é¢˜ã€‚(2)visiability Gaussian cullingï¼Œæ¯æ¬¡è®­ç»ƒéƒ½é¢„è®¡ç®—visibility maskï¼Œä»è€ŒåŠ å¿«è®¡ç®—è¿‡ç¨‹ã€‚ æœ€ç»ˆå‡å°‘ç‚¹äº‘æ•°é‡ï¼ŒåŠ å¿«æ—©æœŸä¼˜åŒ–é€Ÿåº¦ï¼Œå¹¶ä¸”ä½¿å¾—é«˜æ–¯çš„å¯†é›†åŒ–èƒ½å¤Ÿåœ¨ä¸€ä¸ªå¾ˆçŸ­çš„æ—¶æœŸå†…å®Œæˆã€‚ åœ¨ç»†èŠ‚ä¸Šï¼Œä¿®æ”¹densificationã€cullingæ¡†æ¶ä»£ç ï¼Œä¼˜åŒ–processCUDAå…‰æ …åŒ–è¿›ç¨‹ï¼Œè¾¾åˆ°optimization speed, the number of Gaussians,and rendering qualityçš„balance. Gaussian importance ç”±Compressing Volumetric Radiance Fields to 1 MBå¯çŸ¥ï¼Œå¤§å¤šæ•°ä½“ç´ å¯¹æ¸²æŸ“ç»“æœçš„å½±å“æœ€å°ï¼Œè¿™è¡¨æ˜ç½‘æ ¼æ¨¡å‹ä¸­çš„å†—ä½™å¾ˆå¤§ï¼Œå¹¶ä¸”å¯ä»¥åœ¨ä¸é™ä½æ¸²æŸ“è´¨é‡çš„æƒ…å†µä¸‹è¿›è¡Œå‰ªæ(prune)ã€‚ æˆ‘ä»¬å°†Gaussian importanceå®šä¹‰ä¸ºè¯¥åŒºåŸŸå†…(?)ä¸é€æ˜åº¦æœ€å¤§çš„é«˜æ–¯çš„ä¸é€æ˜åº¦ã€‚å› ä¸ºè¿™ç§Gaussian importanceå¯¹æ¸²æŸ“ç»“æœå½±å“è¾ƒå¤§ã€‚ aggressive Gaussian densification depth reinitialization æ‰¾åˆ°è¯¥åŒºåŸŸä¸é€æ˜åº¦æœ€å¤§çš„æ¤­çƒï¼Œå°†å…¶ä¸æ¤­çƒå…‰çº¿æ±‚äº¤å¾—åˆ°çš„ç‚¹äº‘çš„ä¸­ç‚¹ä½œä¸ºæ·±åº¦ç‚¹(depth point) d(x)=dimaxmid(x),where imax=argâ¡maxâ¡iwid(x) = d^{\\text{mid}}_{i_{\\text{max}}}(x), \\quad \\text{where} \\, i_{\\text{max}} = \\arg\\max_{i} w_i d(x)=dimaxâ€‹midâ€‹(x),whereimaxâ€‹=argimaxâ€‹wiâ€‹ åˆ›å»ºæ·±åº¦è´´å›¾ï¼Œåˆ©ç”¨ç±»ä¼¼å±å¹•åå¤„ç†çš„æ–¹æ³•é‡å»ºå’Œåˆå¹¶ç‚¹äº‘ï¼Œå³depth initalizationï¼Œä»è€ŒåŠ å¿«æ—©æœŸçš„ä¼˜åŒ–è¿­ä»£ã€‚ ç„¶è€Œï¼Œè¿™ç§ç®€å•çš„ç‚¹äº‘ä¼˜åŒ–æ–¹æ³•ï¼Œä¼šå¯¼è‡´åœºæ™¯ä¸å¤Ÿæ³›åŒ–ï¼Œç‚¹äº‘æ•°é‡çˆ†ç‚¸å’Œå›¾åƒè´¨é‡ç ´åçš„é—®é¢˜ã€‚ é€šè¿‡åŠ å…¥critical Gaussian identification&amp;&amp;aggresive Gaussian cloneï¼Œæˆ‘ä»¬å¯ä»¥è§£å†³è¿™äº›é—®é¢˜ã€‚ cirtical Gaussian identification åœ¨æ—©æœŸçš„ä¼˜åŒ–è¿­ä»£æ—¶æœŸï¼Œå‡ ä¹æ‰€æœ‰çš„è®­ç»ƒè¿‡ç¨‹ä¸­çš„Gaussianå¤„äºunder-constructionçŠ¶æ€ï¼Œå•çº¯åœ°è¿›è¡Œcloneå¯ä»¥è®¤ä¸ºæ˜¯ä¸€ç§é™ä½Gaussian importanceçš„è¡Œä¸ºï¼Œä¸åˆ©äºæ§åˆ¶é«˜æ–¯æ•°é‡ï¼Œæ‰€ä»¥æˆ‘ä»¬é‡‡ç”¨äº†represent the object surfaceã€‚å³cirtical Gaussian identification. è¿˜æ˜¯æ‰¾åˆ°è¯¥åŒºåŸŸå†…ä¸é€æ˜åº¦æœ€å¤§çš„æ¤­çƒGimaxG_{i_{max}}Gimaxâ€‹â€‹ï¼Œå°†å®ƒçš„è´¡çŒ®ä½œä¸ºalpha blendçš„ä¼°è®¡ æˆ‘ä»¬ä½¿ç”¨é€†åˆ†å¸ƒå‡½æ•°å¾—åˆ°Gaussian critcal,å…¶ä¸­Î²p\\beta_pÎ²pâ€‹ä»£è¡¨prune threshold,æœ¬æ–‡è®¾ç½®ä¸º0.99ï¼Œå¾—åˆ°çš„Î¸p\\theta_pÎ¸pâ€‹ä¸ºGimaxG_{i_{max}}Gimaxâ€‹â€‹å‰1%çš„Gaussianï¼Œå³Gaussian critical Î¸p=Fâˆ’1(Î²p)\\theta_p = F^{-1}(\\beta_p) Î¸pâ€‹=Fâˆ’1(Î²pâ€‹) aggressive Gaussian clone ç”±äºç›´æ¥å°†åŸæœ‰çš„é«˜æ–¯ä½œä¸ºç‚¹äº‘çš„ç»“æ„ä¸åˆ©äºæ—©æœŸä¼˜åŒ–ï¼Œæˆ‘ä»¬å€Ÿé‰´äº†3D Gaussian Splatting as Markov Chain Monte Carloï¼Œè¾¾åˆ°äº†å¹³æ»‘çš„é«˜æ–¯å¯†é›†åŒ–ã€‚å°†cloneè¿‡ç¨‹åº”ç”¨äºæ‰€æœ‰çš„critical Gaussianï¼Œå¹¶ä¸”ç®€åŒ–äº†é«˜æ–¯ä¸­å¿ƒçš„è®¡ç®—è¿‡ç¨‹ï¼Œå°†cloneæ•°è®¾ç½®ä¸º2ã€‚å³ï¼š Pnew=PoldP_{\\text{new}} = P_{\\text{old}} Pnewâ€‹=Poldâ€‹ Î±new=1âˆ’1âˆ’Î±old\\quad \\alpha_{\\text{new}} = 1 - \\sqrt{1 - \\alpha_{\\text{old}}} Î±newâ€‹=1âˆ’1âˆ’Î±oldâ€‹â€‹ Î£new=(Î±old)2â‹…(2Î±newâˆ’(Î±new)22)âˆ’2â‹…Î£old\\quad \\Sigma_{\\text{new}} = (\\alpha_{\\text{old}})^2 \\cdot \\left( 2\\alpha_{\\text{new}} - \\frac{(\\alpha_{\\text{new}})^2}{\\sqrt{2}} \\right)^{-2} \\cdot \\Sigma_{\\text{old}} Î£newâ€‹=(Î±oldâ€‹)2â‹…(2Î±newâ€‹âˆ’2â€‹(Î±newâ€‹)2â€‹)âˆ’2â‹…Î£oldâ€‹ Overall Aggressive Densification Pipeline æˆ‘ä»¬ä¿ç•™äº†3DGSåŸæœ‰çš„progressive densificationï¼Œå¹¶ä¸”åœ¨500æ¬¡è¿­ä»£å¼€å§‹æ¯250æ¬¡è¿›è¡Œä¸€æ¬¡critical Gaussian identification&amp;&amp;aggresive Gaussian cloneï¼Œåœ¨2Kæ¬¡è¿­ä»£å¼€å§‹è¿›è¡ŒDepth reinitializationã€‚å°†æ•´ä¸ªå¯†é›†åŒ–è¿‡ç¨‹ç¼©çŸ­è‡³3Kè¿­ä»£ï¼Œä»è€Œå°†æ•´ä¸ª30Kæ¬¡çš„è¿­ä»£è¿‡ç¨‹ç¼©çŸ­è‡³18Kæ¬¡ã€‚ å¹¶ä¸”æ•´ä¸ªæ¸²æŸ“ç®¡çº¿å¯ä»¥å…¼å®¹Mini-Splatting frameworkï¼Œå…è®¸Mini-Splatting simplificationåœ¨ç¬¬3Kæ¬¡è¿­ä»£å’Œ8Kæ¬¡è¿­ä»£ã€‚ visibility Gaussian culling å¯¹äºç¬¬kkkæ¬¡è®­ç»ƒè§†å›¾ï¼Œé¦–å…ˆé€šè¿‡å¯¹æ‰€æœ‰ä¸é«˜æ–¯ GiG_iGiâ€‹ç›¸äº¤çš„å…‰çº¿ jjjçš„æ··åˆæƒé‡wijkw_{ij}^{k}wijkâ€‹æ±‚å’Œæ¥è®¡ç®—Gaussian importance IikI_i^kIikâ€‹ã€‚ å…·ä½“è®¡ç®—å…¬å¼ä¸ºï¼š Iik=âˆ‘j=1JwijiI_i^k = \\sum_{j=1}^{J} w_{ij}^i Iikâ€‹=j=1âˆ‘Jâ€‹wijiâ€‹ å…¶ä¸­JJJæ˜¯ä¸é«˜æ–¯GiG_iGiâ€‹ç›¸äº¤çš„æ€»å…‰çº¿æ•°ã€‚ å¯è§æ€§æ©ç VikV_i^kVikâ€‹æ˜¯é€šè¿‡ä¸€ä¸ªæŒ‡ç¤ºå‡½æ•° IIIæ¥è®¡ç®—çš„ï¼Œè¯¥å‡½æ•°æ¯”è¾ƒIikI_i^kIikâ€‹æ˜¯å¦è¶…è¿‡äº†é¢„å®šä¹‰çš„é˜ˆå€¼Ï„\\tauÏ„ã€‚ å¦‚æœIikI_i^kIikâ€‹å¤§äºé˜ˆå€¼Ï„\\tauÏ„ï¼Œåˆ™Vik=1V_i^k = 1Vikâ€‹=1ï¼ˆè¡¨ç¤ºå¯è§ï¼‰ï¼›å¦åˆ™Vik=0V_i^k = 0Vikâ€‹=0ï¼ˆè¡¨ç¤ºä¸å¯è§ï¼‰ã€‚ è¯¥è®¡ç®—å…¬å¼ä¸ºï¼š Vik=I(Iik&gt;Ï„)V_i^k = \\mathcal I(I_i^k &gt; \\tau) Vikâ€‹=I(Iikâ€‹&gt;Ï„) ç¡®ä¿åªæœ‰åœ¨Gaussian importanceå‰ 1%çš„é«˜æ–¯æ‰è¢«è®¤ä¸ºæ˜¯visabilityçš„ã€‚ å¹¶ä¸”åœ¨500åˆ°13Kçš„è¿­ä»£è¿‡ç¨‹ä¸­ï¼Œé€šè¿‡åœ¨æ¯æ¬¡è®­ç»ƒè§†è§’ä¸‹é¢„è®¡ç®—visbility mask,å‰”é™¤ä¸å¿…è¦çš„Gaussianï¼Œå‡å°è®¡ç®—å¼€é”€ï¼ŒåŠ å¿«è®¡ç®—è¿‡ç¨‹ã€‚ Implementation ä¸ºäº†å‡å°å†…å­˜è´Ÿæ‹…ï¼Œåœ¨å¯†é›†åŒ–è¿‡ç¨‹ä¸­å…³é—­äº†çƒè°ç³»æ•°çš„è¿­ä»£ä¼˜åŒ–ï¼Œå¹¶ä¸”è®©è®­ç»ƒåœ¨ä¸€ä¸ªè¾ƒå°çš„åˆ†è¾¨ç‡ä¸‹è¿è¡Œã€‚ ä»£ç å®ç°ç»†èŠ‚ depth reinitalization 123456789101112131415if iteration == args.depth_reinit_iter: num_depth = gaussians._xyz.shape[0]*args.num_depth_factor # interesction_preserving for better point cloud reconstruction result at the early stage, not affect rendering quality gaussians.interesction_preserving(scene, render_simp, iteration, args, pipe, background) pts, rgb = gaussians.depth_reinit(scene, render_depth, iteration, num_depth, args, pipe, background) gaussians.reinitial_pts(pts, rgb) gaussians.training_setup(opt) gaussians.init_culling(len(scene.getTrainCameras())) mask_blur = torch.zeros(gaussians._xyz.shape[0], device=&#x27;cuda&#x27;) torch.cuda.empty_cache() # print(gaussians._xyz.shape) å…ˆæ‰¾åˆ°é€æ˜åº¦æœ€å¤§çš„æ¤­çƒ è·å–accum_weights,area_proj,area_maxå˜é‡,æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œè¿›è¡Œäº†ä¸€ä¸ªç®€å•çš„å…‰æ …åŒ–è¿‡ç¨‹ï¼Œ å®ƒä»¬éƒ½æ˜¯æ•°ç»„ï¼Œ(1)accum_weightsæ˜¯è®¡ç®—é«˜æ–¯è´¡çŒ®çš„ç´¯ç§¯ä¸é€æ˜åº¦ï¼Œ(2)area_projæ˜¯è®¡ç®—é«˜æ–¯è´¡çŒ®çš„ä¸é€æ˜åº¦çš„æ¬¡æ•°ï¼ˆè¦†ç›–çš„åƒç´ çš„ä¸ªæ•°ï¼‰ï¼Œ(3)area_maxæ˜¯è®¡ç®—è¿™ä¸ªé«˜æ–¯åœ¨æ¯ä¸ªåƒç´ æ¸²æŸ“è¿‡ç¨‹çš„æ‰€æœ‰é«˜æ–¯ä¸­è´¡çŒ®æœ€å¤§çš„æ¬¡æ•° 12# in gaussian_renderer/init.pydef render_simp(viewpoint_camera, pc : GaussianModel, pipe, bg_color : torch.Tensor, scaling_modifier = 1.0, override_color = None, culling=None): ... 123456789101112131415161718192021222324# Rasterize visible Gaussians to image, obtain their radii (on screen). rendered_image, radii, \\accum_weights_ptr, accum_weights_count, accum_max_count = rasterizer.render_simp( means3D = means3D, means2D = means2D, dc = dc, shs = shs, culling = culling, colors_precomp = colors_precomp, opacities = opacity, scales = scales, rotations = rotations, cov3D_precomp = cov3D_precomp)# Those Gaussians that were frustum culled or had a radius of 0 were not visible.# They will be excluded from value updates used in the splitting criteria.return &#123;&quot;render&quot;: rendered_image, &quot;viewspace_points&quot;: screenspace_points, &quot;visibility_filter&quot; : (radii &gt; 0).nonzero(), &quot;radii&quot;: radii, &quot;accum_weights&quot;: accum_weights_ptr, &quot;area_proj&quot;: accum_weights_count, &quot;area_max&quot;: accum_max_count, &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// in forward.cutemplate &lt;uint32_t CHANNELS&gt;__global__ void __launch_bounds__(BLOCK_X * BLOCK_Y)render_simpCUDA( const uint2* __restrict__ ranges, const uint32_t* __restrict__ point_list, int W, int H, const float2* __restrict__ points_xy_image, const float* __restrict__ features, float* __restrict__ accum_weights_p, int* __restrict__ accum_weights_count, float* __restrict__ accum_max_count, const float4* __restrict__ conic_opacity, float* __restrict__ final_T, uint32_t* __restrict__ n_contrib, const float* __restrict__ bg_color, float* __restrict__ out_color )&#123; // Identify current tile and associated min/max pixel range. auto block = cg::this_thread_block(); uint32_t horizontal_blocks = (W + BLOCK_X - 1) / BLOCK_X; uint2 pix_min = &#123; block.group_index().x * BLOCK_X, block.group_index().y * BLOCK_Y &#125;; uint2 pix_max = &#123; min(pix_min.x + BLOCK_X, W), min(pix_min.y + BLOCK_Y , H) &#125;; uint2 pix = &#123; pix_min.x + block.thread_index().x, pix_min.y + block.thread_index().y &#125;; uint32_t pix_id = W * pix.y + pix.x; float2 pixf = &#123; (float)pix.x, (float)pix.y &#125;; // Check if this thread is associated with a valid pixel or outside. // Done threads can help with fetching, but don&#x27;t rasterize // Load start/end range of IDs to process in bit sorted list. // Allocate storage for batches of collectively fetched data. // Initialize helper variables // ... // Iterate over batches until all done or range is complete // ... // Iterate over current batch for (int j = 0; !done &amp;&amp; j &lt; min(BLOCK_SIZE, toDo); j++) &#123; // Keep track of current position in range contributor++; // Resample using conic matrix (cf. &quot;Surface // Splatting&quot; by Zwicker et al., 2001) float2 xy = collected_xy[j]; float2 d = &#123; xy.x - pixf.x, xy.y - pixf.y &#125;; float4 con_o = collected_conic_opacity[j]; float power = -0.5f * (con_o.x * d.x * d.x + con_o.z * d.y * d.y) - con_o.y * d.x * d.y; if (power &gt; 0.0f) continue; // Eq. (2) from 3D Gaussian splatting paper. // Obtain alpha by multiplying with Gaussian opacity // and its exponential falloff from mean. // Avoid numerical instabilities (see paper appendix). float alpha = min(0.99f, con_o.w * exp(power)); if (alpha &lt; 1.0f / 255.0f) continue; float test_T = T * (1 - alpha); if (test_T &lt; 0.0001f) &#123; done = true; continue; &#125; // Eq. (3) from 3D Gaussian splatting paper. for (int ch = 0; ch &lt; CHANNELS; ch++) C[ch] += features[collected_id[j] * CHANNELS + ch] * alpha * T; if(weight_max&lt;alpha * T) &#123; weight_max=alpha * T; idx_max = collected_id[j]; flag_update = 1; &#125; atomicAdd(&amp;(accum_weights_p[collected_id[j]]), alpha * T); atomicAdd(&amp;(accum_weights_count[collected_id[j]]), 1); T = test_T; // Keep track of last range entry to update this // pixel. last_contributor = contributor; &#125; &#125; if(flag_update==1) &#123; atomicAdd(&amp;(accum_max_count[idx_max]), 1); &#125; // All threads that treat valid pixel write out their final // rendering data to the frame and auxiliary buffers. // ...&#125; é¦–å…ˆè¿›è¡Œintersection_preservingå¯¹é«˜æ–¯è¿›è¡Œç­›é€‰ï¼Œå¯¹äºæ¯ä¸ªè®­ç»ƒè§†å›¾ï¼Œå‡è¿›è¡Œå…‰æ …åŒ–ï¼Œè¿™æ ·å°±èƒ½å¾—åˆ°é«˜æ–¯å¯¹è¿™äº›è§†å›¾åšçš„è´¡çŒ®ç›¸å…³ä¿¡æ¯ï¼Œåœ¨è¿™é‡Œï¼Œæˆ‘å°†åšå‡ºäº†æœ€å¤§è´¡çŒ®çš„é«˜æ–¯å‘½åä¸ºæœ‰æ•ˆé«˜æ–¯ï¼Œå‰©ä½™çš„å°±æ˜¯è¢«è¾ƒé«˜æƒé‡é«˜æ–¯å®Œå…¨è¦†ç›–çš„é«˜æ–¯ï¼Œå¯¹æ¸²æŸ“å½±å“è¾ƒå°ï¼Œå¯ä»¥èˆå»ã€‚é‡è¦æ€§çš„è®¡ç®—åˆ†ä¸ºoutdoorå’Œindoorï¼Œoutdooråˆ™éœ€è¦åŠ æƒï¼Œç´¯è®¡å•ä½é¢ç§¯çš„ä¸é€æ˜åº¦è´¡çŒ®å€¼ï¼Œè‡³äºä¸ºä»€ä¹ˆè¿™æ ·åšï¼Œæˆ‘è®¤ä¸ºå¯èƒ½æ˜¯outdoorç©ºç™½åœºæ™¯è¾ƒå¤šï¼Œç‚¹äº‘ç¨€ç–ï¼Œé«˜æ–¯æ¯”è¾ƒå¤§ï¼Œå®¹æ˜“å—åˆ°æŠ•å½±é¢ç§¯çš„å½±å“ã€‚ æ¥ä¸‹æ¥å°±æ˜¯å¯¹é‡è¦æ€§è¿›è¡Œæ’åºï¼Œé€‰å‡ºè´¡çŒ®åœ¨å‰1%çš„é«˜æ–¯ï¼Œå‰©ä¸‹çš„å…¨éƒ¨è¢«å‰ªæ 1234567891011121314151617181920212223242526def interesction_preserving(self, scene, render_simp, iteration, args, pipe, background): imp_score = torch.zeros(self._xyz.shape[0]).cuda() accum_area_max = torch.zeros(self._xyz.shape[0]).cuda() views = scene.getTrainCameras_warn_up(iteration, args.warn_until_iter, scale=1.0, scale2=2.0).copy() for view in views: render_pkg = render_simp(view, self, pipe, background, culling=self._culling[:,view.uid]) accum_weights = render_pkg[&quot;accum_weights&quot;] area_proj = render_pkg[&quot;area_proj&quot;] area_max = render_pkg[&quot;area_max&quot;] accum_area_max = accum_area_max+area_max if args.imp_metric==&#x27;outdoor&#x27;: mask_t=area_max!=0 temp=imp_score+accum_weights/area_proj imp_score[mask_t] = temp[mask_t] else: imp_score=imp_score+accum_weights imp_score[accum_area_max==0]=0 non_prune_mask = init_cdf_mask(importance=imp_score, thres=0.99) self.prune_points(non_prune_mask==False) return self._xyz, SH2RGB(self._features_dc+0)[:,0] æ¥ä¸‹æ¥å°±æ˜¯depth_reinitè¿‡ç¨‹äº†,å¾—åˆ°accum_alphaç´¯è®¡é€æ˜åº¦(è¿™ä¸ªä¼¼ä¹å’Œæ·±åº¦æ²¡å…³ç³»)å’Œout_ptsè¡¨ç¤ºçš„å‘é‡ä¿¡æ¯(æ–¹å‘è¡¨ç¤ºå…‰çº¿æ–¹å‘ï¼Œæ¨¡é•¿æ˜¯æ·±åº¦),ä¸”ä¸ºå®šä¹‰çš„æ·±åº¦ç‚¹ï¼ˆå…‰çº¿ç›¸äº¤æ¤­çƒçš„ä¸­ç‚¹ï¼‰ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155template &lt;uint32_t CHANNELS&gt;__global__ void __launch_bounds__(BLOCK_X * BLOCK_Y)render_depthCUDA( const uint2* __restrict__ ranges, const uint32_t* __restrict__ point_list, int W, int H, const float2* __restrict__ points_xy_image, const float* __restrict__ features, const float4* __restrict__ conic_opacity, float* __restrict__ final_T, uint32_t* __restrict__ n_contrib, const float* __restrict__ bg_color, float* __restrict__ out_color, float* __restrict__ out_pts, float* __restrict__ out_depth, float* accum_alpha, int* __restrict__ gidx, float* __restrict__ discriminants, const float* __restrict__ means3D, const glm::vec3* __restrict__ scales, const glm::vec4* __restrict__ rotations, const float* __restrict__ viewmatrix, const float* __restrict__ projmatrix, const glm::vec3* __restrict__ cam_pos )&#123; float3 p_proj_r = &#123; Pix2ndc(pixf.x, W), Pix2ndc(pixf.y, H), 1&#125;; //inverse process of &#x27;Transform point by projecting&#x27; float p_hom_x_r = p_proj_r.x*(1.0000001); float p_hom_y_r = p_proj_r.y*(1.0000001); // self.zfar = 100.0, self.znear = 0.01 float p_hom_z_r = (100-100*0.01)/(100-0.01); float p_hom_w_r = 1; float3 p_hom_r=&#123;p_hom_x_r, p_hom_y_r, p_hom_z_r&#125;; float4 p_orig_r=transformPoint4x4(p_hom_r, projmatrix_inv); glm::vec3 ray_direction=&#123; p_orig_r.x-ray_origin.x, p_orig_r.y-ray_origin.y, p_orig_r.z-ray_origin.z, &#125;; glm::vec3 normalized_ray_direction = glm::normalize(ray_direction); // Iterate over batches until all done or range is complete // ... // Iterate over current batch for (int j = 0; !done &amp;&amp; j &lt; min(BLOCK_SIZE, toDo); j++) &#123; // Resample using conic matrix (cf. &quot;Surface // Splatting&quot; by Zwicker et al., 2001) float2 xy = collected_xy[j]; float2 d = &#123; xy.x - pixf.x, xy.y - pixf.y &#125;; float4 con_o = collected_conic_opacity[j]; float power = -0.5f * (con_o.x * d.x * d.x + con_o.z * d.y * d.y) - con_o.y * d.x * d.y; if (power &gt; 0.0f) continue; float alpha = min(0.99f, con_o.w * exp(power)); if (alpha &lt; 1.0f / 255.0f) continue; float test_T = T * (1 - alpha); if (test_T &lt; 0.0001f) &#123; done = true; continue; &#125; for (int ch = 0; ch &lt; CHANNELS; ch++) C[ch] += features[collected_id[j] * CHANNELS + ch] * alpha * T; // compute Gaussian depth // Normalize quaternion to get valid rotation glm::vec4 q = rotations[collected_id[j]];// / glm::length(rot); float rot_r = q.x; float rot_x = q.y; float rot_y = q.z; float rot_z = q.w; // Compute rotation matrix from quaternion // ... glm::vec3 temp=&#123; ray_origin.x-means3D[3*collected_id[j]+0], ray_origin.y-means3D[3*collected_id[j]+1], ray_origin.z-means3D[3*collected_id[j]+2], &#125;; glm::vec3 rotated_ray_origin = R * temp; glm::vec3 rotated_ray_direction = R * normalized_ray_direction; ///é™¤æ³•æ˜ å°„åˆ°æ¤­çƒæ ‡å‡†åæ ‡ç³» glm::vec3 a_t= rotated_ray_direction/(scales[collected_id[j]]*3.0f)*rotated_ray_direction/(scales[collected_id[j]]*3.0f); float a = a_t.x + a_t.y + a_t.z; glm::vec3 b_t= rotated_ray_direction/(scales[collected_id[j]]*3.0f)*rotated_ray_origin/(scales[collected_id[j]]*3.0f); float b = 2*(b_t.x + b_t.y + b_t.z); glm::vec3 c_t= rotated_ray_origin/(scales[collected_id[j]]*3.0f)*rotated_ray_origin/(scales[collected_id[j]]*3.0f); float c = c_t.x + c_t.y + c_t.z-1; float discriminant=b*b-4*a*c; float depth = (-b/2/a)/glm::length(ray_direction); if(depth&lt;0) continue; if(weight_max&lt;alpha * T) &#123; weight_max=alpha * T; depth_max=depth; discriminant_max=discriminant; idx_max=collected_id[j]; point_rec = ray_origin+(-b/2/a)*normalized_ray_direction; &#125; T = test_T; last_contributor = contributor; &#125; &#125; // All threads that treat valid pixel write out their final // rendering data to the frame and auxiliary buffers. if (inside) &#123; final_T[pix_id] = T; n_contrib[pix_id] = last_contributor; for (int ch = 0; ch &lt; CHANNELS; ch++) out_color[ch * H * W + pix_id] = C[ch] + T * bg_color[ch]; for (int ch = 0; ch &lt; 3; ch++) out_pts[ch * H * W + pix_id] = point_rec[ch]; out_depth[pix_id] = depth_max; accum_alpha[pix_id] = T; discriminants[pix_id] = discriminant_max; gidx[pix_id]=idx_max; &#125;&#125; é€‰å–ä¸€å®šæ¯”ä¾‹çš„æ·±åº¦ç‚¹ï¼ˆæ¯”ä¾‹æ ¹æ®ç´¯ç§¯ä¸é€æ˜åº¦å’Œè‡ªå·±çš„å®šä¹‰è°ƒæ•´ï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def depth_reinit(self, scene, render_depth, iteration, num_depth, args, pipe, background): out_pts_list=[] gt_list=[] ## é¢„çƒ­(warn up)æ—¶ä½¿ç”¨scale2ï¼Œå³(width/2 x height/2),0.5å€çš„åˆ†è¾¨ç‡ views = scene.getTrainCameras_warn_up(iteration, args.warn_until_iter, scale=1.0, scale2=2.0).copy() ## æ¯ä¸ªè§†å›¾éƒ½è¦è®¡ç®— for view in views: gt = view.original_image[0:3, :, :] ## æ¸²æŸ“æ·±åº¦å›¾ï¼Œè·å–ç›¸å…³ä¿¡æ¯ render_depth_pkg = render_depth(view, self, pipe, background, culling=self._culling[:,view.uid]) out_pts = render_depth_pkg[&quot;out_pts&quot;] accum_alpha = render_depth_pkg[&quot;accum_alpha&quot;] prob=1-accum_alpha prob = prob/prob.sum() prob = prob.reshape(-1).cpu().numpy() ## æ ¹æ®æ·±åº¦é€‰æ‹©é‡‡æ ·æ¯”ä¾‹ factor=1/(gt.shape[1]*gt.shape[2]*len(views)/num_depth) N_xyz=prob.shape[0] num_sampled=int(N_xyz*factor) ## åŠ æƒéšæœºé‡‡æ ·ï¼Œprobè¶Šé«˜(opacityè¶Šé«˜)çš„ç‚¹äº‘è¶Šå®¹æ˜“è¢«é€‰ä¸­ indices = np.random.choice(N_xyz, size=num_sampled, p=prob,replace=False) &#x27;&#x27;&#x27; print(f&quot;Normalized prob: &#123;prob&#125;&quot;) print(f&quot;Reshaped and moved to numpy: &#123;prob&#125;&quot;) print(f&quot;Factor: &#123;factor&#125;&quot;) print(f&quot;N_xyz (Total samples): &#123;N_xyz&#125;&quot;) print(f&quot;Number of sampled points: &#123;num_sampled&#125;&quot;) print(f&quot;Sampled indices: &#123;indices&#125;&quot;) &#x27;&#x27;&#x27; out_pts = out_pts.permute(1,2,0).reshape(-1,3) gt = gt.permute(1,2,0).reshape(-1,3) out_pts_list.append(out_pts[indices]) gt_list.append(gt[indices]) out_pts_merged=torch.cat(out_pts_list) gt_merged=torch.cat(gt_list) return out_pts_merged, gt_merged æœ€ç»ˆåªä¿ç•™æ·±åº¦ç‚¹å’Œç›¸åº”çš„é¢œè‰²,ä¹‹ååœ¨è¿›è¡Œåˆå¹¶ 12345678910111213141516171819202122232425## after depth reinitdef reinitial_pts(self, pts, rgb): fused_point_cloud = pts fused_color = RGB2SH(rgb) features = torch.zeros((fused_color.shape[0], 3, (self.max_sh_degree + 1) ** 2)).float().cuda() features[:, :3, 0 ] = fused_color features[:, 3:, 1:] = 0.0 # print(&quot;Number of points at initialisation : &quot;, fused_point_cloud.shape[0]) dist2 = torch.clamp_min(distCUDA2(fused_point_cloud), 0.0000001) scales = torch.log(torch.sqrt(dist2))[...,None].repeat(1, 3) rots = torch.zeros((fused_point_cloud.shape[0], 4), device=&quot;cuda&quot;) rots[:, 0] = 1 opacities = inverse_sigmoid(0.1 * torch.ones((fused_point_cloud.shape[0], 1), dtype=torch.float, device=&quot;cuda&quot;)) self._xyz = nn.Parameter(fused_point_cloud.contiguous().requires_grad_(True)) self._features_dc = nn.Parameter(features[:,:,0:1].transpose(1, 2).contiguous().requires_grad_(True)) self._features_rest = nn.Parameter(features[:,:,1:].transpose(1, 2).contiguous().requires_grad_(True)) self._scaling = nn.Parameter(scales.requires_grad_(True)) self._rotation = nn.Parameter(rots.requires_grad_(True)) self._opacity = nn.Parameter(opacities.requires_grad_(True)) self.max_radii2D = torch.zeros((self.get_xyz.shape[0]), device=&quot;cuda&quot;) å¯ä»¥çœ‹åˆ°ï¼Œä½œè€…é€šè¿‡æ§åˆ¶æ¯”ä¾‹ï¼Œä½¿å¾—depth_reinitå‰åç‚¹äº‘æ•°é‡åŸºæœ¬ç›¸ç­‰ï¼Œä½†æ˜¯æ ¹æ®æ·±åº¦è´´å›¾å®ç°äº†ç‚¹çš„é‡æ„","categories":[{"name":"3DV","slug":"3DV","permalink":"http://example.com/categories/3DV/"}],"tags":[{"name":"3dgs","slug":"3dgs","permalink":"http://example.com/tags/3dgs/"}],"author":"tugumineko"},{"title":"3DGSå®æ—¶æ¸²æŸ“ç®€è¿°","slug":"3dgs-sketch","date":"2024-11-25T02:38:22.000Z","updated":"2024-11-25T13:49:42.359Z","comments":true,"path":"2024/11/25/3dgs-sketch/","permalink":"http://example.com/2024/11/25/3dgs-sketch/","excerpt":"","text":"å‰ç½®çŸ¥è¯†ï¼šé«˜æ–¯åˆ†å¸ƒï¼Œåæ–¹å·®çŸ©é˜µï¼Œçº¿æ€§å˜æ¢ï¼Œå››å…ƒæ•°ï¼Œæœºå™¨å­¦ä¹ ï¼Œè®¡ç®—æœºå›¾å½¢å­¦/è®¡ç®—æœºè§†è§‰ï¼Œé«˜æ€§èƒ½è®¡ç®— å®šä¹‰ï¼š 3DGSå®æ—¶æ¸²æŸ“ï¼Œå³3D Gaussian Splatting in Real-time Renderingï¼Œä½¿ç”¨äº†3D gaussianä½œä¸ºåŸºåº•ï¼Œå¯¹è¾“å…¥çš„SfMç‚¹äº‘çš„ä½ç½®(x,y,z)å’Œé¢œè‰²(r,g,b)è¿›è¡Œgaussian modelåˆå§‹åŒ–ï¼Œé€šè¿‡GPUå¹¶è¡Œè®¡ç®—ï¼Œè¿ç”¨è®¡ç®—æœºå›¾å½¢å­¦çš„ä¼ ç»Ÿå…‰æ …åŒ–æ–¹æ³•å°†é«˜æ–¯æ¸²æŸ“åˆ°å±å¹•ä¸Šé¢ï¼Œé€šè¿‡æ¸²æŸ“ç»“æœåšåå¾®åˆ†åšlossåå‘ä¼ æ’­å¹¶æ›´æ–°é«˜æ–¯å‚æ•°ï¼Œåˆ©ç”¨éšæœºæ¢¯åº¦ä¸‹é™è¿›è¡Œå­¦ä¹ ï¼Œå¹¶ä¸”äº¤é”™è¿­ä»£ä¼˜åŒ–ã€‚ å…·ä½“ç»†èŠ‚ï¼š ä¸ºä»€ä¹ˆé€‰ç”¨é«˜æ–¯ï¼Ÿ é«˜æ–¯å¯ä»¥è¿‘ä¼¼ä¸ºæ¤­çƒï¼Œæ¸²æŸ“åˆ°2Då±å¹•ä¸Šè¿‘ä¼¼ä¸ºåœ†ï¼Œä¸ä»…å¯ä»¥å®ç°ä»¥åœ†ä¸ºåŸºåº•çš„å…‰æ …åŒ–æ¸²æŸ“ï¼Œè€Œä¸”å…·æœ‰å¯å¾®çš„æ€§è´¨ï¼Œæ‰€ä»¥å¯å­¦ä¹ ã€‚ 2é˜¶åæ–¹å·®çŸ©é˜µè½¬æ¢ä¸ºäºŒæ¬¡æ›²çº¿å¾—åˆ°æ¤­åœ†è¡¨è¾¾å¼ åå¾®åˆ†å¾—åˆ°ä½ç½®meanå’Œåæ–¹å·®çŸ©é˜µ(ç”¨scaleå’Œquternionè¡¨ç¤º)ï¼Œé¢œè‰²(r,g,b)ï¼Œopacity Î±\\alphaÎ±ï¼Œåæ·±åº¦ï¼Œæ¤­çƒæ›²çº¿conicç­‰ä¿¡æ¯ï¼Œä¸L1å’ŒSSIM Lossåšåå‘ä¼ æ’­è¿›è¡Œä¼˜åŒ–æ›´æ–° é«˜æ–¯æœ‰å¾ˆå¤šä¼˜ç§€çš„æ€§è´¨ï¼ŒåŠ å¿«è®¡ç®—ä»¥è¾¾åˆ°å®æ—¶æ¸²æŸ“ åæ–¹å·®çŸ©é˜µè¡¨ç¤º3Dé«˜æ–¯åœ¨å„ä¸ªåæ ‡è½´çš„ç¼©æ”¾åŠæ—‹è½¬ï¼Œç›¸åº”åœ°å¯ä»¥é€šè¿‡æ—‹è½¬çŸ©é˜µå’Œç¼©æ”¾çŸ©é˜µè¡¨ç¤ºåæ–¹å·®çŸ©é˜µ 3Dé«˜æ–¯é€šè¿‡çŸ©é˜µå˜æ¢åå¾—åˆ°çš„è¿˜æ˜¯ä¸€ä¸ª3Dé«˜æ–¯ï¼Œæˆ‘ä»¬å…‰æ …åŒ–æ—¶è½¬æ¢åæ ‡ç³»æ—¶éœ€è¦ç”¨åˆ° ä¸¤ä¸ªé«˜æ–¯åšå·ç§¯è¿˜æ˜¯ä¸€ä¸ªé«˜æ–¯ï¼Œå¹¶ä¸”å¾—åˆ°çš„é«˜æ–¯çš„åæ–¹å·®çŸ©é˜µæ˜¯ä¸¤ä¸ªé«˜æ–¯çš„åæ–¹å·®çŸ©é˜µä¹‹å’Œï¼Œåé¢åšEWAåèµ°æ ·æ—¶ä¼šç”¨åˆ° 3Dé«˜æ–¯æ²¿ç€æŸä¸ªè½´åšç§¯åˆ†å¯ä»¥å¾—åˆ°2Dé«˜æ–¯ï¼Œè€Œä¸”è¿™ä¸ª2Dé«˜æ–¯çš„åæ–¹å·®çŸ©é˜µå°±æ˜¯3Dé«˜æ–¯çš„åæ–¹å·®çŸ©é˜µçš„å·¦ä¸Šè§’2x2éƒ¨åˆ† å¦‚ä½•è¿›è¡Œå…‰æ …åŒ–ï¼Ÿ 3D -&gt; 2D è½¬æ¢åæ ‡ç³»ï¼Œä»3Dé«˜æ–¯æŠ•å½±ä¸º2Dé«˜æ–¯ï¼Œæ³¨æ„è¿™é‡Œçš„3Dæ¤­çƒä»ä¸åŒè§†è§’çœ‹æŠ•å½±å‡ºæ¥çš„2Dæ¤­åœ†æ˜¯ä¸åŒçš„ã€‚æˆ‘ä»¬ä½¿ç”¨äº†åæ–¹å·®çŸ©é˜µä¸ºæ ¸å¿ƒï¼Œä»ä¸–ç•Œç©ºé—´åˆ°ç›¸æœºç©ºé—´æ˜¯ä¸€ä¸ªä»¿å°„å˜æ¢ã€‚è€Œä»ç›¸æœºç©ºé—´é½æ¬¡ç©ºé—´æ˜¯ä¸€ä¸ªéçº¿æ€§å˜æ¢ï¼Œä¸æ»¡è¶³ä¸Šè¿°æ€§è´¨ï¼Œè®ºæ–‡ä¸­æå‡ºäº†ä¸€ç§è¿‘ä¼¼çš„æ”¾å°„æŠ•å½±å˜æ¢(local affine approximation),æ˜¯äºŒé˜¶æ³°å‹’å±•å¼€å¾—åˆ°çš„Jacobian Matrix,ç„¶ååšç§¯åˆ†å¾—åˆ°2Dé«˜æ–¯ï¼Œè€Œä¸”æ ¹æœ¬ä¸ç”¨åšç§¯åˆ†è¿ç®—ï¼Œå› ä¸º2Dé«˜æ–¯åæ–¹å·®çŸ©é˜µå·²ç»å¾—åˆ°äº†ã€‚ ä¸ºäº†å‡å°‘é˜´å½±å’Œæ··å ï¼Œæˆ‘ä»¬éœ€è¦åèµ°æ ·Antialiasingï¼Œæˆ‘ä»¬å¯¹ä¿¡å·å¢åŠ ä¸€ä¸ªä½é€šæ»¤æ³¢å™¨ä»¥é¿å…æ··å ç°è±¡ã€‚ç»è¿‡è¯æ˜ï¼Œå¯¹æ•´ä¸ªä¿¡å·çš„å·ç§¯ç­‰ä»·äºå¯¹è¶³è¿¹å‡½æ•°çš„å·ç§¯ï¼Œå³2Dåæ–¹å·®çŸ©é˜µå¯¹è§’çº¿çš„ä¸¤ä¸ªæ•°åŠ ä¸Šå®šå€¼0.3ï¼Œè®©æ‰€æœ‰é«˜æ–¯&quot;èƒ–&quot;ä¸€äº›ï¼Œè®©æ›´å¤šé«˜æ–¯è´¡çŒ®åˆ°æŸä¸€åƒç´ ä¸Šã€‚ ç”¨åæ–¹å·®çŸ©é˜µå¾—åˆ°ç›¸åº”çš„æ¤­çƒå½¢çŠ¶ï¼Œç„¶åè¿‘ä¼¼æˆåœ†ï¼Œå¾—åˆ°åŠå¾„å’Œåœ†å¿ƒ(2Dmean)ï¼Œæ‰¾åˆ°è¿™ä¸ªåœ†å¯¹åº”äº†å‡ ä¸ªTileï¼Œç”¨çƒè°å‡½æ•°æ‹Ÿåˆè¿™ä¸ªåœ†çš„é¢œè‰²ï¼ŒæŒ‰ä½æ·±åº¦æ’åºå¾—åˆ° [Tile | Sphere] é”®å€¼å¯¹ï¼Œä»¥Tileä¸ºBlockï¼ŒPixelä¸ºThreadè¿›è¡ŒGPUå¹¶è¡Œè®¡ç®—ï¼ŒåŠ å¿«æ¸²æŸ“é€Ÿåº¦ã€‚ æ¸²æŸ“æ–¹ç¨‹ âˆ‘kcÎ»kokgk(qkâŠ—h)(x^)\\sum_{k}^{} c_{\\lambda k}o_{k}g_{k}(q_{k}\\otimes h)(\\hat{x}) kâˆ‘â€‹cÎ»kâ€‹okâ€‹gkâ€‹(qkâ€‹âŠ—h)(x^) å¯¹åº”åˆ°3DGSç®—æ³•ä¸Šé¢ï¼ŒcÎ»kc_{\\lambda k}cÎ»kâ€‹è¡¨ç¤ºæŸä¸ªé«˜æ–¯çš„é¢œè‰²(feature)ï¼Œoko_{k}okâ€‹æ˜¯ç´¯è®¡çš„é€æ˜åº¦ï¼Œgkg_{k}gkâ€‹æ˜¯è¿™æ¬¡çš„é€æ˜åº¦ï¼Œå·ç§¯ç»è¿‡é¢„è®¡ç®—çš„åæ–¹å·®çŸ©é˜µå¯ä»¥å¾—å‡ºã€‚ å…¶ä¸­ï¼š é¢œè‰²æ˜¯è¾“å…¥çš„é¢œè‰²ï¼Œä½†æ˜¯ä¸ºäº†è®©ä¸åŒè§†è§’çœ‹èµ·æ¥çš„é¢œè‰²ä¸åŒ(é«˜å…‰å’Œæ¼«åå°„)ï¼Œæˆ‘ä»¬ä½¿ç”¨çƒè°å‡½æ•°æ‹Ÿåˆå‡ºä¸åŒè§†è§’çš„é¢œè‰²ã€‚ é€æ˜åº¦ä¹˜ä»¥è¶³è¿¹å‡½æ•°å°±æ˜¯é«˜æ–¯åˆ†å¸ƒï¼Œå³æ¦‚ç‡ è¿™æ ·ï¼Œæˆ‘ä»¬ä¸æ–­è¿›è¡Œç´¯åŠ ï¼Œè¿ç”¨GPUå¹¶è¡Œè®¡ç®—ï¼Œå°±å¯ä»¥å¾—åˆ°ä¸€ä¸ª2Dè§†å›¾åœºæ™¯ã€‚ æ€æ ·åšåå‘ä¼ æ’­ï¼Ÿ å¯¹äºä¸€ä¸ªå¯å­¦ä¹ æ¨¡å‹çš„åå‘ä¼ æ’­ï¼Œæˆ‘ä»¬è¦å…ˆçŸ¥é“è¾“å…¥é¡¹å’Œè¾“å‡ºé¡¹ã€‚ åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å¯ä»¥è®¤ä¸ºè¾“å…¥é¡¹æ˜¯é€åƒç´ çš„é¢œè‰²å¼ é‡ Prgb(p,3)P_{rgb}(p,3)Prgbâ€‹(p,3)ã€‚ è¾“å‡ºé¡¹æ˜¯é«˜æ–¯çš„ç›¸å…³å‚æ•°ï¼ŒåŒ…æ‹¬ï¼šé€é«˜æ–¯çš„é¢œè‰²å¼ é‡Grgb(g,3)G_{rgb}(g,3)Grgbâ€‹(g,3)ã€é€é«˜æ–¯çš„ä¸é€æ˜åº¦Gopacity(g,1)G_{opacity}(g,1)Gopacityâ€‹(g,1)ã€æ¤­çƒä¸­å¿ƒçš„ä½ç½®Gpoint3D(g,3)G_{point3D}(g,3)Gpoint3Dâ€‹(g,3)ã€æ¤­çƒçš„æ—‹è½¬è§’åº¦Grotation(g,4)G_{rotation}(g,4)Grotationâ€‹(g,4)ã€æ¤­çƒçš„è½´é•¿Gscale(g,3)G_{scale}(g,3)Gscaleâ€‹(g,3)ã€‚ ç”±äºæ˜¯æ¢¯åº¦ä¸‹é™æ³•ï¼Œç„¶åå°±æ˜¯è®¡ç®—æ¢¯åº¦ï¼Œåˆ©ç”¨Losså‡½æ•°åå¾®åˆ†è®¡ç®—å‡ºå³å¯ã€‚ å…·ä½“å°±æ˜¯Pytorchå’ŒLossæ¯”è¾ƒï¼Œåœ¨å‰å‘ä¼ æ’­åä¼šè¿”å›ä¸€ä¸ªLosså¯¹è¾“å‡ºå€¼çš„åå¾®åˆ†ï¼Œå³dLdPrgb(p,3)\\frac {dL}{dP_{rgb}(p,3)}dPrgbâ€‹(p,3)dLâ€‹,ç„¶åæˆ‘ä»¬å¯ä»¥é€šè¿‡æ¢å…ƒä¸€æ­¥æ­¥è®¡ç®—å‡ºå¯¹åº”çš„åå¾®åˆ†ï¼Œå³å¾—åˆ°æ¢¯åº¦ã€‚ åœ¨è¿™é‡Œï¼ŒLossä¸ºL1å’ŒD-SSIMçš„ç»„åˆæŸå¤±å‡½æ•°ï¼Œå…¶ä¸­D-SSIMæƒé‡ä¸º0.2 è®­ç»ƒæ—¶å¦‚ä½•ä¼˜åŒ–ï¼Ÿ å¢åŠ é«˜æ–¯çš„æ•°é‡ã€‚ è®ºæ–‡ä¸­ä½¿ç”¨äº†ä¸€ç§åŸºäºgradientçš„densificationæ–¹æ³•å¯¹é«˜æ–¯å¯†åº¦è¿›è¡Œè°ƒèŠ‚ã€‚ è®ºæ–‡å°†éœ€è¦è°ƒèŠ‚çš„é«˜æ–¯åˆ†ä¸ºä¸¤ç±»: under-reconstruction:é«˜æ–¯å¹¶ä¸èƒ½å¡«æ»¡éœ€è¦è¡¨è¾¾çš„å‡ ä½• over-reconstrucition:é«˜æ–¯è¿‡å¤§å¯¼è‡´å®Œå…¨è¦†ç›–äº†ä¸€ç‰‡åŒºåŸŸ è¿™äº›éœ€è¦è°ƒèŠ‚çš„é«˜æ–¯çš„ä½ç½®æ¢¯åº¦å¾€å¾€å¾ˆå¤§ï¼Œå› ä¸ºä¼˜åŒ–å™¨æ›´å€¾å‘äºæŠŠè¿™äº›é”™è¯¯çº æ­£ã€‚ è®ºæ–‡ä¸­ç›´æ¥ç®—å†å²å¹³å‡ä½ç½®æ¢¯åº¦ï¼Œå¦‚æœåœ¨æŸæ¬¡è°ƒèŠ‚ä¸­å‘ç°è¿™ä¸ªé«˜æ–¯çš„å¹³å‡æ¢¯åº¦å¤§äºæŸä¸ªé¢„å®šå€¼ï¼Œå°±è®¤ä¸ºè¿™ä¸ªé«˜æ–¯éœ€è¦è°ƒèŠ‚ã€‚ å¯¹é«˜æ–¯è¿›è¡Œå‰ªæã€‚ å½“é€æ˜åº¦å°äº0.005æ—¶ï¼Œå°±è®¤ä¸ºè¿™ä¸ªé«˜æ–¯ä¸å­˜åœ¨ï¼ˆå¤§ç‰‡ç©ºç™½åœºæ™¯ï¼‰ï¼Œå°†å…¶å‰ªæ å½“é«˜æ–¯scaleè¿‡å¤§æ—¶æˆ–è€…æŠ•å½±åˆ°å±å¹•ä¸Šè¿‡å¤§æ—¶ï¼Œå°†å…¶å‰ªæ æ¯è¿‡3000æ¬¡è¿­ä»£å°†æ‰€æœ‰é«˜æ–¯çš„é€æ˜åº¦è®¾ç½®ä¸º0.01ï¼Œè¿™æ ·ä¼˜åŒ–å™¨å°±ä¼šå¿½ç•¥å¢åŠ é‚£äº›é”™è¯¯çš„é«˜æ–¯çš„é€æ˜åº¦ä»è€Œåšåˆ°å‰ªææ‰ç©ºä¸­çš„â€™floaterâ€™çš„ä½œç”¨ã€‚ å¢åŠ çƒè°å‡½æ•°çš„ç»´åº¦ã€‚ æ¯è¿‡1000æ¬¡è¿­ä»£å¢åŠ ä¸€ä¸ªçƒè°å‡½æ•°çš„ç»´åº¦ï¼Œæœ€é«˜ä¸º3 é€šè¿‡å­¦ä¹ ç‡å˜åŒ–ç­–ç•¥ã€‚ å…ˆwarm-upå†ä¸‹é™ ä¸åŒçš„å‚æ•°äº¤é”™è®­ç»ƒï¼Œä¸”ä½¿ç”¨ä¸åŒçš„ä¼˜åŒ–å™¨å’Œåˆå§‹å­¦ä¹ ç‡","categories":[{"name":"CV","slug":"CV","permalink":"http://example.com/categories/CV/"},{"name":"CG","slug":"CG","permalink":"http://example.com/categories/CG/"},{"name":"3DV","slug":"3DV","permalink":"http://example.com/categories/3DV/"}],"tags":[{"name":"3dgs","slug":"3dgs","permalink":"http://example.com/tags/3dgs/"}],"author":"tugumineko"},{"title":"2024/11/11ç¯å¢ƒé…ç½®è¸©å‘","slug":"softras-environment","date":"2024-11-11T15:05:21.000Z","updated":"2024-11-12T06:35:48.439Z","comments":true,"path":"2024/11/11/softras-environment/","permalink":"http://example.com/2024/11/11/softras-environment/","excerpt":"","text":"ä»Šå¤©åœ¨è·‘Soft Rasterizer (SoftRas)è¿™ä¸€ç¯‡è®ºæ–‡ä»£ç æ—¶å‡ºç°äº†å¾ˆå¤šçš„é—®é¢˜ï¼Œç”±äºæ˜¯ä¸€ç¯‡2019å¹´çš„è®ºæ–‡ï¼Œæœ‰å¾ˆå¤šç‰ˆæœ¬å…¼å®¹çš„é—®é¢˜ï¼Œäºæ˜¯è®°å½•ä¸‹æ¥ã€‚ å‰è¨€ æœ‰ä¸€äº›ç”±äºç‰ˆæœ¬å…¼å®¹å‡ºç°çš„è­¦å‘Šç‰ˆæœ¬è¿‡é«˜/è¿‡ä½/ä¸åŒ¹é…å…¶å®å¤§å¤šæ•°æ˜¯ä¸ç”¨ç®¡çš„ï¼Œæ³¨æ„åŒºåˆ† CUDA 10ä¸å…¼å®¹ é¦–å…ˆæ˜¯æŒ‰ç…§è®ºæ–‡æ‰€ç»™çš„ç¯å¢ƒ(Python3 and PyTorch 1.6.0. CUDA (10.1))è·‘ä¸äº†,å› ä¸ºCUDA 10ä¸èƒ½å…¼å®¹30ç³»æ˜¾å¡ã€‚ æ‰€ä»¥è¦æ›´æ¢å…¼å®¹æ›´é«˜ç‰ˆæœ¬çš„PyTorch,æˆ‘è¿™é‡Œä½¿ç”¨çš„æ˜¯PyTorch 1.9.0,ä½¿ç”¨å¦‚ä¸‹ä»£ç å¯ä»¥æŸ¥çœ‹ç‰ˆæœ¬ï¼š 1234567python - &lt;&lt;-EOFimport platformimport torchprint(f&quot;Python : &#123;platform.python_version()&#125;&quot;)print(f&quot;PyTorch: &#123;torch.__version__&#125;&quot;)print(f&quot; CUDA : &#123;torch.version.cuda&#125;&quot;)EOF gcc/g++ç‰ˆæœ¬è¿‡é«˜ ä¸»è¦å‚è€ƒä»¥ä¸‹åšå®¢Linuxç³»ç»Ÿ åˆ©ç”¨condaæ›´æ”¹gccã€g++ç‰ˆæœ¬(érootç”¨æˆ·)å»ºç«‹è½¯è¿æ¥å®ç°,æ³¨æ„ä¸è¦å¿˜è®°ä¸‹è½½g++ gccå’Œg++ç‰ˆæœ¬ä¸€å®šè¦æ£€æŸ¥æ˜¯å¦ä¸€æ · gccé™çº§å¯¼è‡´ç¯å¢ƒå˜é‡å´©æºƒ å‚è€ƒåšå®¢érootç”¨æˆ·æ„å»ºé¡¹ç›®ä»£ç è¸©å‘è®°å½•_conda å®‰è£… gcc_cannot find /lib64/libpthread.so.0 è‹±æ–‡ç‰ˆld-cannot-find-lib64-libpthread-so-0-ld-cannot-find-usr-lib64-libpthread-non 12cannot find /lib64/libpthread.so.0cannot find /usr/lib64/libpthread_nonshared.a å…·ä½“ä¸ºä»€ä¹ˆä¼šè¿™æ ·å‘¢ï¼Œå¯èƒ½è¿˜è¦åˆ°ä»¥åå»æ¢ç©¶ ç”±äºæ›´æ”¹ç‰ˆæœ¬æ— æ³•å®‰è£…çš„ä¾èµ– æ¯”å¦‚æˆ‘è¿™é‡Œpythonæ˜¯3.7ï¼Œè€Œpytorchæ˜¯1.9.0ï¼Œè¿™æ ·å¯¼è‡´pytorchéœ€è¦çš„åŒ…æ²¡æœ‰æˆ–è€…æ²¡æœ‰å¯¹åº”çš„ç‰ˆæœ¬ï¼Œå…¶å®ç›´æ¥pip/condaå®‰è£…å¯¹åº”çš„æœ€é«˜ç‰ˆæœ¬/åº“å³å¯ å‚è€ƒé“¾æ¥ï¼š å¯å¾®æ¸²æŸ“ SoftRas å®è·µ Linuxç³»ç»Ÿ åˆ©ç”¨condaæ›´æ”¹gccã€g++ç‰ˆæœ¬(érootç”¨æˆ·) érootç”¨æˆ·æ„å»ºé¡¹ç›®ä»£ç è¸©å‘è®°å½•_conda å®‰è£… gcc_cannot find /lib64/libpthread.so.0 ld-cannot-find-lib64-libpthread-so-0-ld-cannot-find-usr-lib64-libpthread-non error: Couldnâ€™t find a setup script in /tmp/easy_install-ian85kkj/scikit_image-0.23.2.tar.gz","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"cuda","slug":"cuda","permalink":"http://example.com/categories/cuda/"}],"tags":[{"name":"æ¸²æŸ“","slug":"æ¸²æŸ“","permalink":"http://example.com/tags/%E6%B8%B2%E6%9F%93/"},{"name":"æ·±åº¦å­¦ä¹ ","slug":"æ·±åº¦å­¦ä¹ ","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"author":"tugumineko"},{"title":"3dgs real-time radiance rendering","slug":"3dgs-real-time-radiance-rendering","date":"2024-11-05T10:36:13.000Z","updated":"2024-12-06T10:01:17.035Z","comments":true,"path":"2024/11/05/3dgs-real-time-radiance-rendering/","permalink":"http://example.com/2024/11/05/3dgs-real-time-radiance-rendering/","excerpt":"","text":"introduce 3D Gaussians as a flexible and expressive scene representation. input: cameras calibrated with Structure-from-Motion(SfM) initalize the set of 3D Gaussians with the sparse point cloud produced for free as part of the SfM process. (only SfM points as input) optimization of the properities of the 3D Gaussians - 3D position, opacity Î±\\alphaÎ± (?), anisotropic covarianice, and SH coefficients - interleaved with adaptive density control steps, where we add and occasionally remove 3D Gaussians during optimization produce ï¼ˆreasonably compact,unstructured,and precise representation of the sceneï¼‰ real-time rendering solution that uses fast GPU sorting algorithms ansd is inspired by tile-based rasterization. (visibility-aware, allows anisotropic splatting and fast back-propagation(åå‘ä¼ æ’­) to achieve high-quality novel view synthesis) light field (å…‰åœº) The first novel-view synthesis approaches were based on light fields. SfM estimates a sparse point cloud during camera calibration. Rendering using volumetric ray-marching has a significant cost due to the large number of samples required to query the volume. recent methods have focused on faster training and/or rendering mostly by expoiting(å¼€å‘) three design choices: the use of spatial data structures to store (neural) features that are subsequently interpolated during volumetric ray-matching different encoding MLP capacity Many methods has limits: struggle to represent empty space effectively,depending in part on the scene/capture type image quality is limited in large part by the choice of the structured grids used for acceleration, and rendering speed is hindered(é˜»ç¢) by the need to query many samples for a given ray-marching step. aliasing(èµ°æ ·) image formation model(æˆåƒæ¨¡å‹) Point-based alpha-blending and NeRF-style volumetric rendering The color C is given by volumetric rendering along a ray:(?) A typical neutral point-based approach computes the color C of a pixel by blending N order points overlapping the pixel:(?) â€“&gt; Points are an unstructured,discrete representation that is flexible enough to allow creation,destruction,and displacement of geometry similar to NeRF. â€“&gt; This is achieved by optimizing opacity(?ä»€ä¹ˆæ„æ€) and positions. â€“&gt; optimization of anisotropic covariance, interleaved optimization/density control, and efficient depth sorting for rendering allow us to handle complete, complex scenes including background, both indoors and outdoors and with large depth complexity. OVERVIEW The input to our method is a set of images of a static scene, together with the corresponding cameras calibrated by SfM [SchÃ¶nberger and Frahm 2016] which produces a sparse point cloud as a side effect. From these points we create a set of 3D Gaussians (Sec. 4), defined by a position (mean), covariance matrix and opacity ğ›¼, that allows a very flexible optimization regime. This results in a reasonably compact(ç®€åŒ–) representation of the 3D scene, in part because highly anisotropic volumetric splats(é«˜åº¦å„å‘å¼‚æ€§çš„ä½“ç§¯æ–‘ç‚¹) can be used to represent fine structures compactly. The directional appearance component (color) of the radiance field is represented via spherical harmonics (SH), following standard practice [Fridovich-Keil and Yu et al. 2022; MÃ¼ller et al. 2022]. Our algorithm proceeds to create the radiance field representation (Sec. 5) via a sequence of optimization steps of 3D Gaussian parameters, i.e., position, covariance, ğ›¼ and SH coefficients interleaved with operations for adaptive control of the Gaussian density. The key to the efficiency of our method is our tile-based rasterizer (Sec. 6) that allows ğ›¼-blending of anisotropic splats, respecting visibility order thanks to fast sorting. Out fast rasterizer also includes a fast backward pass by tracking accumulated ğ›¼ values, without a limit on the number of Gaussians that can receive gradients. The overview of our method is illustrated in Fig. 2. input : a set of images of a static scene + the corresponding cameras calibrated by SfM (produces a sparse point cloud [side effect?]) -&gt; 3D Gaussians (include a position(mean), covariance matrix and opacity alpha) compact representation of the 3D scene SH -&gt; The directional appearance component(color) of the radiance field optimization regime(?) Model the geometry as a set of 3D Gaussians that donâ€™t require normals. affine(ä»¿å°„) æ¨å…¬å¼ï¼š 3D Gaussianè¡¨ç¤ºäº†ä¸€ä¸ªä¸‰ç»´æ•°æ®ç»„ï¼Œæ»¡è¶³ä¸‰ç»´çš„é«˜æ–¯åˆ†å¸ƒï¼Œç»è¿‡æ¨å¯¼ä¹‹åå¯ä»¥ç”¨åæ–¹å·®çŸ©é˜µçš„é€†å’Œåæ–¹å·®çŸ©é˜µçš„è¡Œåˆ—å¼è¡¨ç¤ºã€‚ æ•°æ®éœ€è¦ç»è¿‡Camera Calibration,æ‰€ä»¥åæ–¹å·®çŸ©é˜µä¹Ÿè¦ç»è¿‡ç›¸åº”çš„å˜æ¢ï¼Œæ–¹æ³•æ˜¯å·¦ä¹˜W(ä¸–ç•Œåæ ‡ç³»åˆ°æ‘„åƒæœºåæ ‡ç³»çš„å˜æ¢çŸ©é˜µ)å’ŒJ(3Dæ‘„åƒæœºåæ ‡ç³»åˆ°2Dåƒç´ åæ ‡ç³»çš„jacobian matrixï¼Œä¸ºäº†æŠµæ¶ˆéçº¿æ€§å˜æ¢å¸¦æ¥çš„å½±å“)ï¼Œç”±äºæ˜¯åˆ†å¸ƒå˜æ¢ï¼Œæ‰€ä»¥è¿˜è¦å³ä¹˜å¯¹åº”çš„çŸ©é˜µçš„è½¬ç½®ã€‚ åæ–¹å·®çŸ©é˜µç»è¿‡ç‰¹å¾å€¼åˆ†è§£çš„ç‰¹å¾å‘é‡å’Œç‰¹å¾å€¼çŸ©é˜µï¼Œåœ¨å‡ ä½•æ„ä¹‰ä¸Šæ˜¯æ—‹è½¬çŸ©é˜µå’Œç¼©æ”¾çŸ©é˜µçš„å¹³æ–¹(å› ä¸ºæ˜¯æ–¹å·®)çš„å½¢å¼å¯¹åº”ï¼Œç”¨Vè¡¨ç¤ºæ—‹è½¬çŸ©é˜µï¼Œç”¨Lè¡¨ç¤ºç‰¹å¾å€¼çŸ©é˜µæœ‰: âˆ‘=VLVâˆ’1\\sum = VLV^{-1} âˆ‘=VLVâˆ’1 åœ¨è®ºæ–‡ä¸­ç”¨ R è¡¨ç¤ºæ—‹è½¬çŸ©é˜µ ç”¨ S è¡¨ç¤ºç¼©æ”¾çŸ©é˜µï¼Œåˆ™æœ‰ï¼š âˆ‘=RSSRâˆ’1\\sum = RSSR^{-1} âˆ‘=RSSRâˆ’1 ç”¨ T è¡¨ç¤ºå˜æ¢çŸ©é˜µï¼Œåˆ™å¯ä»¥å†™æˆï¼š âˆ‘=RSSTRT=RS(SR)T=TTT\\sum = RSS^{T}R^{T} = RS(SR)^{T} = TT^{T} âˆ‘=RSSTRT=RS(SR)T=TTT æ­¤å¤–ï¼Œä¸ºäº†èŠ‚çº¦è®¡ç®—é‡ï¼Œä½¿ç”¨å››å…ƒæ•°è¡¨ç¤ºæ—‹è½¬çŸ©é˜µ covariance matrices have physical meaning only when they are positive semi-definite. --&gt; cannot directly optimize the covariance matrix âˆ‘\\sumâˆ‘ to obtain 3D Gaussians that represent the radiance field. constrain(çº¦æŸ) So, use the formula : âˆ‘=RSSTRT=RS(SR)T=TTT\\sum = RSS^{T}R^{T} = RS(SR)^{T} = TT^{T} âˆ‘=RSSTRT=RS(SR)T=TTT And store them separately : a 3D vector sss for scaling a quaternion qqq to represent rotation derive the gradients for all parameters explicitly --&gt; avoid significant overhead due to automatic differentiation during training. optimization: positions ppp,Î±\\alphaÎ±,covarivance âˆ‘\\sumâˆ‘,SH coefficients The optimization of these parameters is interleaved with steps that control the density of the Gaussians to better represent the scene. Inevitably, geometry may be incorrectly palced due to the ambiguities of 3D to 2D projection. --&gt; our optimization thus needs to be able to create geometry and also destroy or mobe geometry if it is incorrect. The quality of the parameters of the covarivances of the 3D Gaussians is critical. --&gt; large homogeneous areas can be captured with a small number of large anisotropic Gaussians. Stochastic Gradient Descent sigmoid activation function for Î±\\alphaÎ± exponential activation function for the scale of the covariance Reason : to constrain it in the [0 - 1) range and obtain smooth gradients. densify every 100 iterations and remove any Gaussians that are essentially transparent. densify Gaussians with an average magnitude of view-space position gradients above a threshold Ï„pos\\tau_{pos}Ï„posâ€‹ under-reconstructed regions â€“ regions with missing geometric features over-reconstructed regions â€“ regions where Gaussians cover large area in the scene. cover the new geometry that must be created (For small Gaussian that are in under-reconstructed regions) --&gt; clone the gaussians. simply creating a copy of the same size, and moving it in the direction of the positional gradient large Gaussians in regions with high variance need to be split into smaller Gaussians, also initialize their position by using the original 3D Gaussian as a PDF for sampling. A effective way to moderate the increase in the number of Gaussians is to set the Î±\\alphaÎ± value close to zero every N = 3000 iterations Our fast rasterizer allows efficient backpropagation over an arbitrary number of blended Gaussians with low additional memory consumption, requiring only a constant overhead per pixel. Specially, we only keep Gaussians with a 99% confidence interval intersecting the view frustum. Additionally, we use a guard band to trivially reject Gaussians at extreme positions. instantiate each Gaussian according to the number of tiles they overlap and assign each instance a key that combines view space depth and tile ID. sort Gaussians based on these keys using a single fast GPU Radix Sort. (Î±\\alphaÎ± blending) these approximations become negligible as splats approach the size of individual pixels. During rasterization, the saturation of Î±\\alphaÎ± is the only stopping cirterion. During the backward pass, we must therefore recover the full sequence of blended points per-pixel in the forward pass. traverse the per-tile lists again. To facilitate gradient computation, we now traverse them back-to-front. Rasterization The traversal starts from the last point that affected any pixel in the tile, and loading of points into shared memory again happens collaboratively. Additionally, each pixel will only start overlap testing and processing of points if their depth is lower than or equal to the depth of the last point that contributed to its color during the forward pass. (æ·±åº¦æµ‹è¯•?) recover intermediate opacities by storing only the total accumulated opacity at the end of the forward pass. Specifically, each point stores the final accumulated opacity Î±\\alphaÎ± in the forward process. We divide this by each pointâ€™s Î±\\alphaÎ± in our back-to-front traversal to obtain the required coefficients for gradient computation. implementation SH coefficient optimization is sensitive to the lack of angular information. optimizing only the zero-order component, and then introduce one band of the SH after every 1000 interations unitl all 4 bands of SH are represented. Initialization with SfM points helps Densification splitting big Gaussians is important to allow good reconstruction of the background cloning the small Gaussians instead of splitting them allows for a better and faster convergence especially when thin structures appear in the scene. Unlimited is better. If we limit the number of points that receive gradients, the effect on visual quality is significant. The use of anisotropic volumetric splats enables modelling of fine structures and has a significant impact on visual quality. spherical harmonics improves (?) limitations popping artifacts when our optimization creates large Gaussians view-dependent appearance reason: trivial rejection of Gaussians via a guard band in the rasterizer simple visibility algorithm,which can lead to Gaussians suddenly switching depth/blending order (antialiasing) do not apply any regularization(æ­£åˆ™åŒ–) to our optimization the GPU memory figure could be significantly reduced by a careful low-level implementation of the optimization logic. (i.e. Compression techniques method) å¯å¾®çš„3D Gaussian Splatting åˆå§‹åŒ–åˆ©ç”¨SfMçš„ç‚¹äº‘ï¼ŒåŒ…å« Position(Mean)ã€Covariance Matrixã€Opacity Î±\\alphaÎ± ã€Spherical harmonics å…¶ä¸­ï¼š ç‚¹çš„ä½ç½®(ä¹Ÿå³3D Gaussiançš„å‡å€¼)ã€ åæ–¹å·®çŸ©é˜µï¼Œå†³å®šGaussianå½¢çŠ¶ ä¸é€æ˜åº¦ï¼Œç”¨äºæ¸²æŸ“ï¼ŒæŠŠä»–ç‚¹å¾€å›¾åƒå¹³é¢ä¸ŠæŠ•çš„æ—¶å€™ï¼Œå®ƒä»¬çš„æ‰©æ•£ç—•è¿¹æ˜¯é€šè¿‡è¿™ä¸ªä¸é€æ˜åº¦ï¼Œå åŠ åœ¨ä¸€èµ·çš„ çƒè°å‡½æ•°ï¼Œç”¨æ¥æ‹Ÿåˆè§†è§’ç›¸å…³çš„å¤–è§‚ ï¼ˆçƒè°å‡½æ•°æœ¬èº«å°±æ˜¯ç”¨ä¸€ç»„æ­£äº¤åŸºçš„çº¿æ€§ç»„åˆæ¥æ‹Ÿåˆå…‰åœºï¼‰ 3D Gaussianï¼Œéœ€è¦ä¸€ç§å›¾å…ƒï¼Œèƒ½å¤Ÿåœ¨æ‹¥æœ‰åœºæ™¯è¡¨è¾¾èƒ½åŠ›çš„æ—¶å€™å¯å¾®ï¼Œä¸”æ˜¾å¼åœ°æ”¯æŒå¿«é€Ÿæ¸²æŸ“ 3D Gaussianç‚¹äº‘é‡Œé¢çš„å‚æ•°å¯ä»¥åœ¨è¿­ä»£ä¼˜åŒ–çš„è¿‡ç¨‹ä¸­æ›´æ–°ï¼Œè€Œä¸”èƒ½å¤Ÿå¾ˆå®¹æ˜“åœ°ç”¨splatçš„æ–¹æ³•ï¼Œæ¥æŠ•å½±åˆ°2Då›¾åƒä¸Šï¼Œåšéå¸¸å¿«çš„Î±\\alphaÎ±æ··åˆ ï¼ˆrenderingï¼‰ Jacobian Matrixçš„æ¨å¯¼ æŠ•å½±å…¬å¼ æŠ•å½±å…¬å¼ç”¨äºå°†ä¸‰ç»´ç©ºé—´ä¸­çš„ç‚¹ (x,y,z)(x, y, z)(x,y,z) æ˜ å°„åˆ°äºŒç»´å±å¹•å¹³é¢ä¸Šçš„ç‚¹ (xâ€²,yâ€²)(x&#x27;, y&#x27;)(xâ€²,yâ€²)ã€‚ (1)ç›¸æœºåæ ‡ç³»ä¸è§†å›¾åæ ‡ç³» é¦–å…ˆå‡è®¾ç‚¹ (x,y,z)(x, y, z)(x,y,z) æ˜¯åœ¨ç›¸æœºåæ ‡ç³»ä¸‹çš„ä¸‰ç»´åæ ‡ã€‚ç›¸æœºä½äºåŸç‚¹ï¼Œè§†çº¿æ²¿ zzz-è½´æ­£æ–¹å‘ã€‚ (x,y,z)( x, y, z )(x,y,z) è¡¨ç¤ºç‚¹çš„ä¸‰ç»´ä½ç½®ã€‚ zzz æ˜¯ç‚¹ä¸ç›¸æœºçš„è·ç¦»ã€‚ (2)è½¬æ¢åˆ°æŠ•å½±å¹³é¢(æ·±åº¦é€è§†) åœ¨ç›¸æœºçš„æŠ•å½±æ¨¡å‹ä¸­ï¼ŒæŠ•å½±å¹³é¢é€šå¸¸è®¾ç½®ä¸ºè·ç¦»ç›¸æœºåŸç‚¹ä¸º 1 çš„ä½ç½®ï¼ˆå³ z=1z = 1z=1)ã€‚é€šè¿‡æŠ•å½±ï¼Œä¸‰ç»´ç‚¹ (x,y,z)(x, y, z)(x,y,z) ä¼šæ˜ å°„åˆ°æŠ•å½±å¹³é¢ä¸Šçš„ç‚¹ (xp,yp,1)(x_p, y_p, 1)(xpâ€‹,ypâ€‹,1)ï¼ŒæŠ•å½±å…³ç³»ä¸ºï¼š xp=xz,yp=yzx_p = \\frac{x}{z}, \\quad y_p = \\frac{y}{z} xpâ€‹=zxâ€‹,ypâ€‹=zyâ€‹ å…¶ä¸­ï¼š x/z è¡¨ç¤ºæ°´å¹³è§†è§’ä¸‹ç‚¹çš„ä½ç½®ä¸æ·±åº¦çš„æ¯”ä¾‹ã€‚ y/z è¡¨ç¤ºå‚ç›´è§†è§’ä¸‹ç‚¹çš„ä½ç½®ä¸æ·±åº¦çš„æ¯”ä¾‹ã€‚ ä¸ºäº†å°†æŠ•å½±å¹³é¢çš„åæ ‡ (xp,yp)(x_p, y_p)(xpâ€‹,ypâ€‹) è½¬æ¢ä¸ºå±å¹•ä¸Šçš„åƒç´ åæ ‡ï¼Œéœ€è¦è€ƒè™‘ç›¸æœºçš„ç„¦è· fxf_xfxâ€‹ å’Œ fyf_yfyâ€‹ï¼ˆå•ä½åƒç´ ï¼‰ï¼Œä»¥åŠå±å¹•çš„åˆ†è¾¨ç‡å’Œå°ºåº¦å˜æ¢ã€‚æŠ•å½±å…¬å¼ä¸ºï¼š xâ€²=fxâ‹…xp=fxâ‹…xz,yâ€²=fyâ‹…yp=fyâ‹…yzx&#x27; = f_x \\cdot x_p = \\frac{f_x \\cdot x}{z}, \\quad y&#x27; = f_y \\cdot y_p = \\frac{f_y \\cdot y}{z} xâ€²=fxâ€‹â‹…xpâ€‹=zfxâ€‹â‹…xâ€‹,yâ€²=fyâ€‹â‹…ypâ€‹=zfyâ€‹â‹…yâ€‹ å…¶ä¸­ï¼š fx=Width2â‹…tanâ¡(æ°´å¹³è§†è§’FovX/2)f_x = \\frac{\\text{Width}}{2 \\cdot \\tan(\\text{æ°´å¹³è§†è§’FovX} / 2)} fxâ€‹=2â‹…tan(æ°´å¹³è§†è§’FovX/2)Widthâ€‹ fy=Height2â‹…tanâ¡(å‚ç›´è§†è§’FovY/2)f_y = \\frac{\\text{Height}}{2 \\cdot \\tan(\\text{å‚ç›´è§†è§’FovY} / 2)} fyâ€‹=2â‹…tan(å‚ç›´è§†è§’FovY/2)Heightâ€‹ å…¶ä¸­fx,fyf_x, f_yfxâ€‹,fyâ€‹æ˜¯ç›¸æœºå†…å‚ï¼Œå®šä¹‰äº†æŠ•å½±æ¯”ä¾‹ã€‚ ç»“åˆä»¥ä¸Šæ¨å¯¼ï¼Œé€è§†æŠ•å½±å…¬å¼å¯ä»¥å†™ä¸ºï¼š xâ€²=fxâ‹…xz,yâ€²=fyâ‹…yzx&#x27; = \\frac{f_x \\cdot x}{z}, \\quad y&#x27; = \\frac{f_y \\cdot y}{z} xâ€²=zfxâ€‹â‹…xâ€‹,yâ€²=zfyâ€‹â‹…yâ€‹ æ¨å¯¼JacobiançŸ©é˜µ åœ¨è®¡ç®—æœºå›¾å½¢å­¦å’Œ3Då˜æ¢ä¸­ï¼ŒJacobian çŸ©é˜µç”¨äºæè¿°ä»ä¸€ä¸ªç©ºé—´ï¼ˆä¾‹å¦‚ä¸–ç•Œåæ ‡ç³»ï¼‰åˆ°å¦ä¸€ä¸ªç©ºé—´ï¼ˆä¾‹å¦‚è§†å›¾ç©ºé—´æˆ–å±å¹•ç©ºé—´ï¼‰çš„åæ ‡æ˜ å°„å˜åŒ–ç‡ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼ŒJacobian çŸ©é˜µ J æè¿°ä» 3D è§†å›¾ç©ºé—´åˆ° 2D æŠ•å½±ç©ºé—´ï¼ˆå±å¹•åæ ‡ï¼‰çš„å˜åŒ–ã€‚ Jacobian çŸ©é˜µæ˜¯æŠ•å½±å˜æ¢å¯¹è¾“å…¥åæ ‡çš„åå¯¼æ•°çŸ©é˜µï¼š J=âˆ‚(xâ€²,yâ€²)âˆ‚(x,y,z)J = \\frac{\\partial(x&#x27;, y&#x27;)}{\\partial(x, y, z)} J=âˆ‚(x,y,z)âˆ‚(xâ€²,yâ€²)â€‹ å®ƒè¡¨ç¤ºæŠ•å½±å˜æ¢ä¸­ï¼Œæ¯ä¸ª 3D åæ ‡åˆ†é‡çš„å¾®å°å˜åŒ–å¯¹ 2D åæ ‡çš„å½±å“ã€‚ å°†ä»¥ä¸Šåå¯¼æ•°å†™æˆçŸ©é˜µå½¢å¼ï¼š J=[âˆ‚xâ€²âˆ‚xâˆ‚xâ€²âˆ‚yâˆ‚xâ€²âˆ‚zâˆ‚yâ€²âˆ‚xâˆ‚yâ€²âˆ‚yâˆ‚yâ€²âˆ‚z]=[fxz0âˆ’fxâ‹…xz20fyzâˆ’fyâ‹…yz2]J = \\begin{bmatrix} \\frac{\\partial x&#x27;}{\\partial x} &amp; \\frac{\\partial x&#x27;}{\\partial y} &amp; \\frac{\\partial x&#x27;}{\\partial z} \\\\ \\frac{\\partial y&#x27;}{\\partial x} &amp; \\frac{\\partial y&#x27;}{\\partial y} &amp; \\frac{\\partial y&#x27;}{\\partial z} \\end{bmatrix} = \\begin{bmatrix} \\frac{f_x}{z} &amp; 0 &amp; -\\frac{f_x \\cdot x}{z^2} \\\\ 0 &amp; \\frac{f_y}{z} &amp; -\\frac{f_y \\cdot y}{z^2} \\end{bmatrix} J=[âˆ‚xâˆ‚xâ€²â€‹âˆ‚xâˆ‚yâ€²â€‹â€‹âˆ‚yâˆ‚xâ€²â€‹âˆ‚yâˆ‚yâ€²â€‹â€‹âˆ‚zâˆ‚xâ€²â€‹âˆ‚zâˆ‚yâ€²â€‹â€‹]=[zfxâ€‹â€‹0â€‹0zfyâ€‹â€‹â€‹âˆ’z2fxâ€‹â‹…xâ€‹âˆ’z2fyâ€‹â‹…yâ€‹â€‹] 1234glm::mat3 J = glm::mat3( focal_x / t.z, 0.0f, -(focal_x * t.x) / (t.z * t.z), 0.0f, focal_y / t.z, -(focal_y * t.y) / (t.z * t.z), 0, 0, 0); è¿™ä¸ªçŸ©é˜µç”¨åœ¨åç»­çš„é«˜æ–¯åˆ†å¸ƒæŠ•å½±ä¸­ï¼Œç”¨æ¥å‡è½»éçº¿æ€§å˜æ¢å¯¹è§†å›¾å¸¦æ¥çš„å½±å“ åæ–¹å·®çŸ©é˜µè½¬æ¢ä¸ºå‡ ä½•è¡¨è¾¾çš„æ¤­åœ† åœ¨äºŒç»´é«˜æ–¯åˆ†å¸ƒä¸­ï¼Œç­‰æ¦‚ç‡å¯†åº¦çš„è½®å»“æ˜¯ä¸€ä¸ªæ¤­åœ†ï¼Œå…¶å®šä¹‰å¦‚ä¸‹ï¼š (xâˆ’Î¼)TÎ£âˆ’1(xâˆ’Î¼)=c(x - \\mu)^T \\Sigma^{-1} (x - \\mu) = c (xâˆ’Î¼)TÎ£âˆ’1(xâˆ’Î¼)=c å…¶ä¸­æŠŠ(xâˆ’Î¼)(x-\\mu)(xâˆ’Î¼)å½“ä½œå‘é‡åŸºï¼Œåæ–¹å·®çŸ©é˜µçš„é€†çŸ©é˜µçœ‹ä½œåŸºçš„ç³»æ•°ï¼Œå¯ä»¥è½¬åŒ–ä¸ºä¸€ä¸ªxyåæ ‡ç³»ä¸Šé¢çš„äºŒæ¬¡æ›²çº¿ æˆ‘ä»¬å°†æ¤­åœ†çš„éšå¼æ–¹ç¨‹ç”±åæ–¹å·®é€†çŸ©é˜µ Î£âˆ’1\\Sigma^{-1}Î£âˆ’1 ç»™å‡ºï¼š [x y][Î£11âˆ’1Î£12âˆ’1Î£12âˆ’1Î£22âˆ’1][xy]=1[x \\; y] \\begin{bmatrix} \\Sigma^{-1}_{11} &amp; \\Sigma^{-1}_{12} \\\\ \\Sigma^{-1}_{12} &amp; \\Sigma^{-1}_{22} \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} = 1 [xy][Î£11âˆ’1â€‹Î£12âˆ’1â€‹â€‹Î£12âˆ’1â€‹Î£22âˆ’1â€‹â€‹][xyâ€‹]=1 å±•å¼€åï¼š Î£11âˆ’1â‹…x2+2â‹…Î£12âˆ’1â‹…xy+Î£22âˆ’1â‹…y2=1\\Sigma^{-1}_{11} \\cdot x^2 + 2 \\cdot \\Sigma^{-1}_{12} \\cdot xy + \\Sigma^{-1}_{22} \\cdot y^2 = 1 Î£11âˆ’1â€‹â‹…x2+2â‹…Î£12âˆ’1â€‹â‹…xy+Î£22âˆ’1â€‹â‹…y2=1 æˆ‘ä»¬çŸ¥é“å¯¹ç§°çŸ©é˜µåæ–¹å·®çŸ©é˜µä¸ºï¼š Î£=[cov.xcov.ycov.ycov.z]\\Sigma = \\begin{bmatrix} \\text{cov.x} &amp; \\text{cov.y} \\\\ \\text{cov.y} &amp; \\text{cov.z} \\end{bmatrix} Î£=[cov.xcov.yâ€‹cov.ycov.zâ€‹] å…¶é€†çŸ©é˜µ Î£âˆ’1\\Sigma^{-1}Î£âˆ’1ï¼š Î£âˆ’1=1detâ¡(Î£)[cov.zâˆ’cov.yâˆ’cov.ycov.x]\\Sigma^{-1} = \\frac{1}{\\det(\\Sigma)} \\begin{bmatrix} \\text{cov.z} &amp; -\\text{cov.y} \\\\ -\\text{cov.y} &amp; \\text{cov.x} \\end{bmatrix} Î£âˆ’1=det(Î£)1â€‹[cov.zâˆ’cov.yâ€‹âˆ’cov.ycov.xâ€‹] æ‰€ä»¥å¯ä»¥å¾—å‡ºå¯¹åº”äºŒæ¬¡æ›²çº¿çš„ç³»æ•° a=Î£11âˆ’1=cov.zdetâ¡(Î£)a = \\Sigma^{-1}_{11} = \\frac{\\text{cov.z}}{\\det(\\Sigma)}a=Î£11âˆ’1â€‹=det(Î£)cov.zâ€‹ b=Î£12âˆ’1=âˆ’cov.ydetâ¡(Î£)b = \\Sigma^{-1}_{12} = -\\frac{\\text{cov.y}}{\\det(\\Sigma)}b=Î£12âˆ’1â€‹=âˆ’det(Î£)cov.yâ€‹ c=Î£22âˆ’1=cov.xdetâ¡(Î£)c = \\Sigma^{-1}_{22} = \\frac{\\text{cov.x}}{\\det(\\Sigma)}c=Î£22âˆ’1â€‹=det(Î£)cov.xâ€‹ ä¸ºäº†è¡¨ç¤ºä¸ºå‚æ•°å½¢å¼ï¼š conic={Î£11âˆ’1,Î£12âˆ’1,Î£22âˆ’1}={cov.zdetâ¡(Î£),âˆ’cov.ydetâ¡(Î£),cov.xdetâ¡(Î£)}\\text{conic} = \\{\\Sigma^{-1}_{11}, \\Sigma^{-1}_{12}, \\Sigma^{-1}_{22}\\} = \\{\\frac{\\text{cov.z}}{\\det(\\Sigma)}, -\\frac{\\text{cov.y}}{\\det(\\Sigma)}, \\frac{\\text{cov.x}}{\\det(\\Sigma)}\\} conic={Î£11âˆ’1â€‹,Î£12âˆ’1â€‹,Î£22âˆ’1â€‹}={det(Î£)cov.zâ€‹,âˆ’det(Î£)cov.yâ€‹,det(Î£)cov.xâ€‹} 123456789101112131415161718192021// Compute 2D screen-space covariance matrixfloat3 cov = computeCov2D(p_orig, focal_x, focal_y, tan_fovx, tan_fovy, cov3D, viewmatrix);// è°ƒæ•´covå¯¹è§’çº¿é¡¹ï¼Œé¿å…æ— æ³•æ±‚é€†ï¼Œä¸”å¢åŠ æ³›åŒ–ç¨‹åº¦constexpr float h_var = 0.3f;const float det_cov = cov.x * cov.z - cov.y * cov.y;cov.x += h_var;cov.z += h_var;const float det_cov_plus_h_cov = cov.x * cov.z - cov.y * cov.y;float h_convolution_scaling = 1.0f;if(antialiasing) h_convolution_scaling = sqrt(max(0.000025f, det_cov / det_cov_plus_h_cov)); // max for numerical stability// Invert covariance (EWA algorithm)const float det = det_cov_plus_h_cov;if (det == 0.0f) return;float det_inv = 1.f / det;float3 conic = &#123; cov.z * det_inv, -cov.y * det_inv, cov.x * det_inv &#125;; æ±‚æ—‹è½¬æ¤­åœ†çš„é•¿çŸ­è½´ æˆ‘ä»¬ä»ç»™å®šçš„äºŒæ¬¡å‹æ–¹ç¨‹(æ¤­åœ†)å¼€å§‹ï¼š ax2+2bxy+cy2=1ax^2 + 2bxy + cy^2 = 1 ax2+2bxy+cy2=1 è¿™ä¸ªæ–¹ç¨‹æ˜¯ä¸€ä¸ªäºŒæ¬¡å‹ï¼Œå¯ä»¥å†™æˆçŸ©é˜µå½¢å¼ï¼š Q(x,y)=[xy][abbc][xy]=1Q(x, y) = \\begin{bmatrix} x &amp; y \\end{bmatrix} \\begin{bmatrix} a &amp; b \\\\ b &amp; c \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} = 1 Q(x,y)=[xâ€‹yâ€‹][abâ€‹bcâ€‹][xyâ€‹]=1 è¿™é‡Œçš„ç³»æ•°çŸ©é˜µæ˜¯å¯¹ç§°çŸ©é˜µï¼š A=[abbc]A = \\begin{bmatrix} a &amp; b \\\\ b &amp; c \\end{bmatrix} A=[abâ€‹bcâ€‹] æˆ‘ä»¬å¸Œæœ›é€šè¿‡åˆåŒå¯¹è§’åŒ–ï¼ˆæ­£äº¤å˜æ¢ï¼‰å°†è¿™ä¸ªçŸ©é˜µè½¬åŒ–ä¸ºå¯¹è§’çŸ©é˜µï¼Œä»è€Œå¾—åˆ°æ ‡å‡†æ¤­åœ†çš„å½¢å¼ã€‚è¿™æ ·å°±å¯ä»¥å¾—åˆ°é•¿çŸ­è½´ã€‚ å‡è®¾çŸ©é˜µ AAA çš„ç‰¹å¾å‘é‡åˆ†åˆ«ä¸º v1v_1v1â€‹ å’Œ v2v_2v2â€‹ï¼Œåˆ™çŸ©é˜µ PPP ç”±è¿™ä¸¤ä¸ªç‰¹å¾å‘é‡ç»„æˆï¼Œä¸”ï¼š P=[v1v2]P = \\begin{bmatrix} v_1 &amp; v_2 \\end{bmatrix} P=[v1â€‹â€‹v2â€‹â€‹] å¦‚æœæˆ‘ä»¬ä½¿ç”¨çŸ©é˜µ PPP è¿›è¡Œåæ ‡å˜æ¢ï¼Œå³ä»¤æ–°çš„åæ ‡ xâ€²x&#x27;xâ€² ä¸ºï¼š xâ€²=Pâˆ’1xx&#x27; = P^{-1} x xâ€²=Pâˆ’1x é‚£ä¹ˆï¼Œç»è¿‡åæ ‡å˜æ¢åï¼ŒäºŒæ¬¡å‹æ–¹ç¨‹å˜ä¸ºï¼š xâ€²TÎ›xâ€²=1x&#x27;^T \\Lambda x&#x27; = 1 xâ€²TÎ›xâ€²=1 å…¶ä¸­ Î›=diag(Î»1,Î»2)\\Lambda = \\text{diag}(\\lambda_1, \\lambda_2)Î›=diag(Î»1â€‹,Î»2â€‹) æ˜¯å¯¹è§’çŸ©é˜µï¼ŒåŒ…å«äº†äºŒæ¬¡å‹çš„ç‰¹å¾å€¼ã€‚ x1â€²21Î»12+x2â€²21Î»22=1\\frac{x_1&#x27;^2}{\\frac{1}{\\sqrt{\\lambda_1}}^2} + \\frac{x_2&#x27;^2}{\\frac{1}{\\sqrt{\\lambda_2}}^2} = 1 Î»1â€‹â€‹1â€‹2x1â€²2â€‹â€‹+Î»2â€‹â€‹1â€‹2x2â€²2â€‹â€‹=1 è¿™æ„å‘³ç€ï¼š é•¿è½´çš„åŠé•¿è½´ a=1Î»1a = \\frac{1}{\\sqrt{\\lambda_1}}a=Î»1â€‹â€‹1â€‹, çŸ­è½´çš„åŠé•¿è½´ b=1Î»2b = \\frac{1}{\\sqrt{\\lambda_2}}b=Î»2â€‹â€‹1â€‹. ä¸ºäº†å¯¹è§’åŒ–çŸ©é˜µ AAAï¼Œæˆ‘ä»¬é¦–å…ˆæ±‚è§£å…¶ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡ã€‚ç‰¹å¾å€¼ Î»1\\lambda_1Î»1â€‹ å’Œ Î»2\\lambda_2Î»2â€‹ æ˜¯çŸ©é˜µ AAA çš„è§£ï¼Œæ»¡è¶³ä»¥ä¸‹ç‰¹å¾æ–¹ç¨‹ï¼š detâ¡(Aâˆ’Î»I)=0\\det(A - \\lambda I) = 0 det(Aâˆ’Î»I)=0 å³ï¼š detâ¡[aâˆ’Î»bbcâˆ’Î»]=0\\det\\begin{bmatrix} a - \\lambda &amp; b \\\\ b &amp; c - \\lambda \\end{bmatrix} = 0 det[aâˆ’Î»bâ€‹bcâˆ’Î»â€‹]=0 è®¡ç®—è¡Œåˆ—å¼ï¼š (aâˆ’Î»)(câˆ’Î»)âˆ’b2=0(a - \\lambda)(c - \\lambda) - b^2 = 0 (aâˆ’Î»)(câˆ’Î»)âˆ’b2=0 å±•å¼€åå¾—åˆ°ï¼š Î»2âˆ’(a+c)Î»+(acâˆ’b2)=0\\lambda^2 - (a + c)\\lambda + (ac - b^2) = 0 Î»2âˆ’(a+c)Î»+(acâˆ’b2)=0 è¿™ä¸ªæ–¹ç¨‹çš„è§£å°±æ˜¯çŸ©é˜µ ( A ) çš„ç‰¹å¾å€¼ ( \\lambda_1 ) å’Œ ( \\lambda_2 )ï¼Œåˆ†åˆ«ä¸ºï¼š Î»1,Î»2=(a+c)Â±(a+c)2âˆ’4(acâˆ’b2)2\\lambda_1, \\lambda_2 = \\frac{(a + c) \\pm \\sqrt{(a + c)^2 - 4(ac - b^2)}}{2} Î»1â€‹,Î»2â€‹=2(a+c)Â±(a+c)2âˆ’4(acâˆ’b2)â€‹â€‹ è¿™ä¸¤ä¸ªç‰¹å¾å€¼å³ä¸ºäºŒæ¬¡å‹çš„ä¸»è½´æ–¹å‘ä¸Šçš„ç³»æ•°ï¼Œå®ƒä»¬å†³å®šäº†æ¤­åœ†çš„é•¿çŸ­è½´ã€‚ åˆ†å¸ƒå˜æ¢","categories":[{"name":"CV","slug":"CV","permalink":"http://example.com/categories/CV/"},{"name":"CG","slug":"CG","permalink":"http://example.com/categories/CG/"}],"tags":[{"name":"3dgs","slug":"3dgs","permalink":"http://example.com/tags/3dgs/"}],"author":"tugumineko"},{"title":"cv,cgç›¸å…³æ¦‚å¿µ","slug":"cv-concepts","date":"2024-11-05T07:43:13.000Z","updated":"2024-11-11T15:39:40.251Z","comments":true,"path":"2024/11/05/cv-concepts/","permalink":"http://example.com/2024/11/05/cv-concepts/","excerpt":"","text":"ç›¸æœºæ ¡æ­£ Camera Calibration å‰è¨€ ä»è¿™é‡Œå¼€å§‹æ˜¯ç ”ç©¶ç°å®ä¸–ç•Œè½¬åŒ–åˆ°å±å¹•ç©ºé—´çš„å…³ç³»ï¼Œæ³¨æ„å’Œå›¾å½¢å­¦åˆ†åˆ«å¼€ åœ¨å›¾åƒæµ‹é‡è¿‡ç¨‹ä»¥åŠæœºå™¨è§†è§‰åº”ç”¨ä¸­ï¼Œä¸ºç¡®å®šç©ºé—´ç‰©ä½“è¡¨é¢æŸç‚¹çš„ä¸‰ç»´å‡ ä½•ä½ç½®ä¸å…¶åœ¨å›¾åƒä¸­å¯¹åº”ç‚¹ä¹‹é—´çš„ç›¸äº’å…³ç³»ï¼Œå¿…é¡»å»ºç«‹ç›¸æœºæˆåƒçš„å‡ ä½•æ¨¡å‹ï¼Œè¿™äº›å‡ ä½•æ¨¡å‹å‚æ•°å°±æ˜¯ç›¸æœºå‚æ•° Camera Calibrationç®€å•æ¥è¯´å°±æ˜¯æ±‚è§£ä¸–ç•Œç©ºé—´åˆ°åƒç´ ç©ºé—´çš„è¿‡ç¨‹ï¼Œä¹Ÿå°±æ˜¯æ±‚è§£æœ€ç»ˆçš„æŠ•å½±çŸ©é˜µçš„è¿‡ç¨‹ åæ ‡ç³» ï¼ˆcoordinate systemï¼‰ ä¸–ç•Œåæ ‡ç³»ã€ç›¸æœºåæ ‡ç³»ã€å›¾åƒåæ ‡ç³»ã€åƒç´ åæ ‡ç³» æ ‡å®š ï¼ˆcalibrationï¼‰ ä½¿ç”¨æ£‹ç›˜ä½œä¸ºæ ‡å®šç‰©ï¼ŒäºŒç»´ç‰©ä½“ç›¸å¯¹äºä¸‰ç»´ç‰©ä½“ä¼šç¼ºå°‘ä¸€éƒ¨åˆ†ä¿¡æ¯ï¼Œäºæ˜¯å¤šæ¬¡æ”¹å˜æ£‹ç›˜çš„æ–¹ä½æ¥æ•æ‰å›¾åƒã€‚ ä»ä¸–ç•Œåæ ‡ç³»åˆ°ç›¸æœºåæ ‡ç³» æ—‹è½¬å¹³ç§»çŸ©é˜µ ç›¸æœºåæ ‡ç³»åˆ°ç†æƒ³å›¾åƒåæ ‡ç³» ç›¸ä¼¼ä¸‰è§’å½¢ ç†æƒ³å›¾åƒåæ ‡ç³»åˆ°å®é™…å›¾åƒåæ ‡ç³» Radial Distortion (å¾„å‘ç•¸å˜) å…‰çº¿ç»è¿‡é€é•œçš„è¾¹ç¼˜æ—¶ï¼Œå…¶å¼¯æ›²ç¨‹åº¦æ¯”åœ¨é€é•œçš„ä¸­å¿ƒä¸ºå¤§ distortionçš„æƒ…å†µåœ¨é€é•œè¶Šå°æ—¶è¶Šæ˜æ˜¾ å¯ä»¥é€šè¿‡æ³°å‹’çº§æ•°å±•å¼€å¼æ¥æ ¡æ­£ï¼ˆk1,k2,k3ï¼‰ Tangential Distortion (åˆ‡å‘ç•¸å˜) æˆåƒä»ªè¢«è´´ä¸Šæ‘„åƒæœºçš„æ—¶å€™ï¼Œè¯¯å·®ä½¿å¾—å½±åƒå¹³é¢å’Œé€é•œä¸å®Œå…¨å¹³è¡Œï¼Œä»è€Œäº§ç”Ÿåˆ‡å‘ç•¸å˜ å¦‚æœä¸€ä¸ªçŸ©å½¢è¢«æŠ•å½±åˆ°æˆåƒä»ªä¸Šæ—¶ï¼Œå¯èƒ½ä¼šå˜æˆä¸€ä¸ªæ¢¯å½¢ ä½¿ç”¨ (p1,p2)æ¥æ ¡æ­£ ä»å®é™…å›¾åƒåæ ‡ç³»åˆ°åƒç´ åæ ‡ç³» å¹³ç§»ï¼Œå¹¶ä¸”é€‚åº”åˆ†è¾¨ç‡ æ–°è§†è§’åˆæˆ Novel View Synthesis æ–°è§†è§’åˆæˆä»»åŠ¡(Novel view synthesis)æŒ‡çš„æ˜¯ç»™å®šæºå›¾åƒ(src image)å’Œæºå§¿æ€(src pose),ä»¥åŠç›®æ ‡å§¿æ€(Target pose)ï¼Œæ¸²æŸ“ç”Ÿæˆç›®æ ‡å§¿æ€å¯¹åº”çš„å›¾ç‰‡ (Target image) æºå§¿æ€ ä»ç›¸æœºåæ ‡ç³»è½¬åŒ–åˆ°ä¸–ç•Œåæ ‡ç³»çš„å˜æ¢çŸ©é˜µ ä»æœºå™¨å­¦ä¹ çš„è§’åº¦ç†è§£ï¼šä»ä¸€äº›&lt;å›¾ç‰‡ï¼Œç›¸æœºçŸ©é˜µ&gt;æ„æˆçš„è®­ç»ƒé›†ä¸­æ¨¡å‹ï¼Œæµ‹è¯•æ—¶ç»™ä¸€ä¸ªè®­ç»ƒé›†ä¸­æ²¡æœ‰çš„ç›¸æœºçŸ©é˜µï¼Œæ¨¡å‹èƒ½é¢„æµ‹å‡ºå¯¹åº”çš„å›¾ç‰‡ SfM(Structure from Motion) æ˜¯ä¸€ç§ä¸‰ç»´é‡å»ºçš„æ–¹æ³•ï¼Œç”¨äºä»motionä¸­å®ç°3Dé‡å»º ä»æ—¶é—´ç³»åˆ—çš„2Då›¾åƒä¸­æ¨æµ‹å‡º3Dä¿¡æ¯ æœ€ä¼˜åŒ– (Optimization) æ³›æŒ‡å®šé‡å†³ç­–é—®é¢˜ï¼Œä¸»è¦å…³å¿ƒå¦‚ä½•å¯¹æœ‰é™èµ„æºè¿›è¡Œæœ‰æ•ˆåˆ†é…å’Œæ§åˆ¶ï¼Œå¹¶è¾¾åˆ°æŸç§æ„ä¹‰ä¸Šçš„æœ€ä¼˜ TBR (tile-based rendering) GPUçš„Tile-Basedæ¶æ„ æ‰€è°“Tileï¼Œå°±æ˜¯å°†å‡ ä½•æ•°æ®è½¬æ¢æˆå°çŸ©å½¢åŒºåŸŸçš„è¿‡ç¨‹ã€‚å…‰æ …åŒ–å’Œç‰‡æ®µå¤„ç†åœ¨æ¯Tileçš„è¿‡ç¨‹ä¸­è¿›è¡Œã€‚Tile-Based Renderingçš„ç›®çš„æ˜¯åœ¨æœ€å¤§é™åº¦åœ°å‡å°‘fragment shadingæœŸé—´GPU éœ€è¦çš„å¤–éƒ¨å†…å­˜è®¿é—®é‡,ä»è€Œæ¥èŠ‚çœå†…å­˜å¸¦å®½ã€‚TBRå°†å±å¹•åˆ†æˆå°å—ï¼Œå¹¶åœ¨å°†æ¯ä¸ªå°å›¾å—å†™å…¥å†…å­˜ä¹‹å‰å¯¹æ¯ä¸ªå°å›¾å—è¿›è¡Œç‰‡æ®µç€è‰²ã€‚ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼ŒGPU å¿…é¡»é¢„å…ˆçŸ¥é“å“ªäº›å‡ ä½•ä½“å±äºè¿™ä¸ªtile.å› æ­¤ï¼ŒTBRå°†æ¯ä¸ªæ¸²æŸ“é€šé“æ‹†åˆ†ä¸ºä¸¤ä¸ªå¤„ç†é€šé“ï¼š ç¬¬ä¸€éæ‰§è¡Œæ‰€æœ‰ä¸å‡ ä½•ç›¸å…³çš„å¤„ç†ï¼Œå¹¶ç”Ÿæˆè¯¥tileä¸“å±çš„Primitive listï¼ŒæŒ‡ç¤ºå“ªäº›å›¾å…ƒåœ¨tileå†…ã€‚ ç¬¬äºŒéé€tileè¿›è¡Œå…‰æ …åŒ–å¹¶ä¸”è¿›è¡ŒFragment shadingï¼Œå¹¶åœ¨å®Œæˆåå°†å…¶å†™å›å†…å­˜ã€‚ æ–¹ä¾¿äº†éƒ¨åˆ†ç®—æ³•çš„å®ç° TBRå¯ç”¨äº†ä¸€äº›ç®—æ³•ï¼Œå¦åˆ™è¿™äº›ç®—æ³•çš„è®¡ç®—æˆæœ¬å¤ªé«˜æˆ–å¸¦å®½ä½¿ç”¨è¿‡é«˜ã€‚ tileè¶³å¤Ÿå°ï¼Œäºæ˜¯å¯ä»¥åœ¨å†…å­˜ä¸­æœ¬åœ°å­˜å‚¨è¶³å¤Ÿå¤šçš„sampleï¼Œä»¥å®ç°MSAAã€‚å› æ­¤ï¼Œç¡¬ä»¶å¯ä»¥åœ¨tileå†™å›å†…å­˜æœŸé—´å°†å¤šä¸ªæ ·æœ¬resolveï¼Œè€Œæ— éœ€å•ç‹¬çš„resolve passã€‚ ä¼ ç»Ÿçš„Defer-Renderingå°†ä½¿ç”¨å¤šæ¸²æŸ“ç›®æ ‡ (MRT) æ¸²æŸ“æ¥å®ç°å»¶è¿Ÿç…§æ˜ï¼Œå°†æ¯ä¸ªåƒç´ çš„å¤šä¸ªä¸­é—´å€¼å†™å›ä¸»å†…å­˜ï¼Œç„¶ååœ¨ç¬¬äºŒéä¸­é‡æ–°è¯»å–å®ƒä»¬ã€‚è€Œåœ¨TBRä¸­ç‰‡æ®µç€è‰²å™¨ä»¥ç¼–ç¨‹æ–¹å¼è®¿é—®ç”±å…ˆå‰ç‰‡æ®µå­˜å‚¨åœ¨å¸§ç¼“å†²åŒºä¸­çš„å€¼å¯ä»¥å¯¹Defer-Renderingè¿›è¡Œä¼˜åŒ–ã€‚ Point Cloud A point cloud is a discrete set of data points in space. (ä¸‰ç»´å›¾åƒ) ray marching å¯¹äºæŸäº›æ•ˆæœä½¿ç”¨å‚æ•°åŒ–æè¿°ï¼Œéš¾ä»¥ä½¿ç”¨ä¸‰è§’é¢ç‰‡æè¿°ï¼Œä½¿ç”¨ray marchingèƒ½å¤Ÿè§£å†³è¿™äº›é—®é¢˜ ray marchingæŒ‰ç…§æ‘„åƒæœºæ–¹å‘(Ray)é€æ­¥å‰è¿›(Marching)è¿›è¡Œé‡‡æ ·ï¼Œæ˜¯ä»¥è¿­ä»£æ–¹å¼è¿›è¡Œé‡‡æ ·çš„ è·ç¦»åœº æŒ‰è·ç¦»ç‰©ä½“è¡¨é¢æœ€å°è·ç¦»è¿›è¡Œè¿­ä»£çš„æ­¥è¿› å¦‚æœå‡ºç°æŸäº›å°„çº¿åœ¨æ­¥è¿›ä¸€æ¬¡å¹¶æ²¡æœ‰è¾¾åˆ°è¡¨é¢æ—¶ï¼Œå¯ä»¥ä»¥æ­¤æ—¶è·ç¦»ç‰©ä½“çš„è·ç¦»åœºå†æ¬¡æŒ‰ç…§åŸæ–¹å‘è¿›è¡Œæ­¥è¿›ã€‚å¦‚æœæŸæ¡çº¿åœ¨æ­¥è¿›å¤šæ¬¡åä¸€ç›´é€æ¸è¿œç¦»ï¼Œä¹Ÿå°±æ˜¯è¯´æ˜è¿™æ ¹å°„çº¿æ°¸è¿œæ— æ³•ä¸ç‰©ä½“ç›¸äº¤ï¼Œå¦‚æœä¸€æ ¹å°„çº¿åœ¨æ­¥è¿›å¤šæ¬¡åè·ç¦»åœºçš„å€¼è¶Šæ¥è¶Šå°ï¼Œå¦‚æœè®¾å€¼ä¸º0.01ï¼Œé‚£ä¹ˆå°±å¯ä»¥ç¡®å®šè¿™ä¸ªç‚¹çš„ä½ç½®å°±æ˜¯ç‰©ä½“è¡¨é¢ã€‚ SDFæœ‰å‘è·ç¦»åœº æè¿°ç©ºé—´ä¸­ä»»æ„ä¸€ä¸ªç‚¹åˆ°è¾¾ç‰©ä½“æœ€è¿‘çš„è·ç¦» gradient descent optimization æ¢¯åº¦ä¸‹é™ä¼˜åŒ–ç®—æ³• gradient æ²¿æ¢¯åº¦çš„è´Ÿæ–¹å‘çš„å‡½æ•°å€¼ä¸‹é™æœ€å¿«çš„æ–¹å‘ eta å­¦ä¹ ç‡ xâ†xâˆ’etaâ‹…df(x)dxx \\gets x - eta \\cdot \\frac {df(x)} {dx} xâ†xâˆ’etaâ‹…dxdf(x)â€‹ è®© xxxå‡å»etaetaetaä¹˜ä»¥å‡½æ•°çš„å¯¼æ•° å¤šå…ƒå‡½æ•°çš„æ¢¯åº¦ä¸‹é™ rotation quaternion å››å…ƒæ•° Euler rotation ç¼ºç‚¹ï¼š è¿™ç§æ–¹æ³•æ˜¯è¦æŒ‰ç…§ä¸€ä¸ªå›ºå®šçš„åæ ‡è½´çš„é¡ºåºæ—‹è½¬çš„ï¼Œå› æ­¤ä¸åŒçš„é¡ºåºä¼šé€ æˆä¸åŒçš„ç»“æœ æ¬§æ‹‰æ—‹è½¬æœ‰çˆ¶å­å±‚çº§ï¼Œå½“ä¸­é—´å±‚çº§çš„åæ ‡è½´æ—‹è½¬è¶…è¿‡ä¸€å®šçš„èŒƒå›´æ—¶ï¼Œå¯¼è‡´ä¸­å±‚å’Œå¤–å±‚åæ ‡è½´é‡åˆï¼Œäº§ç”Ÿä¸‡å‘æ­»é”(Gimbal Lock) Gimbal Lockä¼šå¯¼è‡´Euler Rotationæ— æ³•å®ç°çƒé¢å¹³æ»‘æ’å€¼ quaternion å››å…ƒæ•° q=w+xâ‹…i+yâ‹…j+zâ‹…kq = w + x \\cdot i + y \\cdot j + z \\cdot k q=w+xâ‹…i+yâ‹…j+zâ‹…k å…¶ä¸­ï¼š i2=j2=k2=âˆ’1i^2 = j^2 = k^2 = -1 i2=j2=k2=âˆ’1 ij=âˆ’ji=kij = -ji = k ij=âˆ’ji=k jk=âˆ’kj=ijk = -kj = i jk=âˆ’kj=i ki=âˆ’ik=jki = -ik = j ki=âˆ’ik=j ä¸‰ç»´ç©ºé—´ä¸­çš„æ—‹è½¬å¯ä»¥è¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªå‡½æ•° Ï•\\phiÏ•ï¼Œä» R3\\mathbb{R}^3R3åˆ°è‡ªèº«çš„æ˜ å°„ã€‚å‡½æ•° Ï•\\phiÏ• è¦æƒ³è¡¨ç¤ºä¸€ä¸ªæ—‹è½¬ï¼Œå¿…é¡»åœ¨æ—‹è½¬è¿‡ç¨‹ä¸­ä¿æŒå‘é‡é•¿åº¦(lengths)ã€å‘é‡å¤¹è§’(angles)å’Œhandednessä¸å˜ã€‚(handednesså’Œå·¦å³æ‰‹åæ ‡ç³»æœ‰å…³ï¼Œä¾‹å¦‚å·¦æ‰‹åæ ‡ç³»ä¸­å‘é‡æ—‹è½¬åï¼Œä»è¦ç¬¦åˆå·¦æ‰‹åæ ‡ç³»è§„åˆ™) é•¿åº¦ä¿æŒä¸å˜è¦æ»¡è¶³ï¼š âˆ¥Ï•(P)âˆ¥=âˆ¥Pâˆ¥\\left \\|\\phi(\\mathbf{P}) \\right \\| = \\left \\|\\mathbf{P} \\right\\| âˆ¥Ï•(P)âˆ¥=âˆ¥Pâˆ¥ è§’åº¦ä¸å˜è¦æ»¡è¶³ï¼š Ï•(P1)â‹…Ï•(P2)=P1â‹…P2\\phi(\\mathbf{P_1})\\cdot \\phi(\\mathbf{P_2}) = \\mathbf{P_1}\\cdot \\mathbf{P_2} \\qquad Ï•(P1â€‹)â‹…Ï•(P2â€‹)=P1â€‹â‹…P2â€‹ æœ€åï¼Œhandednessä¿æŒä¸å˜è¦æ»¡è¶³ï¼š Ï•(P1)Ã—Ï•(P2)=Ï•(P1Ã—P2)\\phi(\\mathbf{P_1})\\times \\phi(\\mathbf{P_2})=\\phi(\\mathbf{P_1}\\times\\mathbf{P_2}) \\qquad Ï•(P1â€‹)Ã—Ï•(P2â€‹)=Ï•(P1â€‹Ã—P2â€‹) (æœªå®Œå¾…ç»­) å¯ä»¥çœ‹3B1Bæ¥ç†è§£ ä¸¤ä¸ªå››å…ƒæ•°ç›¸ä¹˜éœ€è¦16ä¸ªä¹˜åŠ è¿ç®—ï¼Œç„¶è€Œä¸¤ä¸ª3x3çŸ©é˜µç›¸ä¹˜éœ€è¦27ä¸ªä¹˜åŠ è¿ç®—ï¼Œå› æ­¤åœ¨æŸäº›æƒ…å†µä¸‹ï¼ˆæ¯”å¦‚è¦å¯¹åŒä¸€ä¸ªå¯¹è±¡æ–½åŠ å¤šä¸ªæ—‹è½¬å˜æ¢æ—¶ï¼‰ï¼Œç”¨å››å…ƒæ•°è¡¨ç¤ºæ—‹è½¬ï¼Œæé«˜è¿ç®—æ•ˆç‡ åˆ†å¸ƒå˜æ¢ Warm-up å­¦ä¹ ç‡é¢„çƒ­ åœ¨é¢„çƒ­çš„å°å­¦ä¹ ç‡ä¸‹ï¼Œæ¨¡å‹å¯ä»¥æ…¢æ…¢è¶‹äºç¨³å®šï¼Œç­‰æ¨¡å‹ç›¸å¯¹ç¨³å®šåå†é€‰æ‹©é¢„å…ˆè®¾ç½®çš„å­¦ä¹ ç‡è¿›è¡Œè®­ç»ƒï¼Œä½¿å¾—æ¨¡å‹æ”¶æ•›é€Ÿåº¦å˜å¾—æ›´å¿«ï¼Œæ¨¡å‹æ•ˆæœæ›´ä½³ guard band å›¾ä¸­ç²‰è‰²çš„åŒºåŸŸæ˜¯ 6500x4900 çš„å±å¹•ç©ºé—´ï¼Œå¤–åœˆé»„è‰²éƒ¨åˆ†æ˜¯XYè½´ä¸Š+16K~-16Kçš„ guard bandã€‚ä¸‹é¢çš„ä¸¤ä¸ªç»¿è‰²ä¸‰è§’å½¢ï¼Œä¼šåœ¨ä¸‰è§’å½¢å‡†å¤‡é˜¶æ®µè¢«å‰”é™¤æ‰ã€‚æœ€å¸¸è§çš„æƒ…å†µæ˜¯ç±»ä¼¼è“è‰²ä¸‰è§’å½¢çš„æƒ…å†µï¼Œå’Œå±å¹•åŒºåŸŸç›¸äº¤ï¼Œä½†æ˜¯æ²¡æœ‰è¶…å‡º guard-band åŒºåŸŸå¤–ï¼Œä¼šèµ°æ­£å¸¸çš„ tile å¤„ç†æµç¨‹ï¼Œä¸ä¼šå‘ç”Ÿè£å‰ªã€‚çº¢è‰²çš„ä¸‰è§’å½¢ï¼Œå³å’Œå±å¹•ç©ºé—´ç›¸äº¤ï¼Œåˆæœ‰è¶…å‡º guard-bandåŒºåŸŸå¤–çš„éƒ¨åˆ†ï¼Œä¼šå‘ç”Ÿè£å‰ªã€‚æ³¨æ„å³è¾¹çš„çº¢è‰²ä¸‰è§’å½¢ï¼Œè£å‰ªæ—¶åˆ’åˆ†æˆäº†ä¸¤ä¸ªå°ä¸‰è§’å½¢ã€‚ ç”±äºæ˜¾å¡çš„å¸§ç¼“å†²æ˜¯æœ‰é™çš„ï¼Œä¸ºäº†èƒ½å¤Ÿæ”¯æŒæ›´å¤§çš„ä¸–ç•Œï¼Œå®é™…æ˜¾å¡çš„å¸§ç¼“å†²æ˜¯æ”¯æŒæ¯” viewport çš„å¸§ç¼“å†²å¤§å°å¤§å¾—å¤šçš„çš„ï¼Œè¿™ä¸ªå«åšguard bandã€‚ä½†æ˜¯ä»–ä»ç„¶æ˜¯æœ‰é™çš„ï¼Œæ˜¾å¡èƒ½å¤Ÿå¤„ç†çš„ä¸‰è§’å½¢ä¹Ÿæ˜¯å¿…é¡»åœ¨æœ‰é™çš„ç©ºé—´é‡Œçš„ï¼ˆä½†æ˜¯ä¸‰è§’å½¢çš„ä¸ªæ•°å¯ä»¥è½»æ¾ä¸Šäº¿ç”šè‡³åå‡ äº¿ï¼‰ï¼Œä¸€åŠ 60 å¸§çš„å¼•æ“åŒå±æ¸²æŸ“å‡ äº¿ä¸‰è§’å½¢åº”è¯¥ä¸åœ¨è¯ä¸‹ã€‚ æ‰€ä»¥å®é™… CPU ä¼ ç»™ GPU è¿›è¡Œå…‰æ …åŒ–çš„ä¸‰è§’å½¢ç©ºé—´ä½ç½®ä¹Ÿä¸èƒ½è¶…å‡ºè§†å£å¤ªå¤šç„¶åè¿˜è¦æ¸²æŸ“çš„ï¼Œè¿™æ ·çš„ç»“æœæ˜¯æ˜¾å¡è‡ªå·±å¤„ç†ä¸äº†è¿™ç§ä¸‰è§’å½¢ï¼Œå› ä¸ºä»–æ— æ³•è®¿é—®è¿™ä¹ˆå¤§èŒƒå›´çš„æ•°æ®ã€‚ æ‰€ä»¥æ˜¯ä¸¤é˜¶æ®µè£å‰ªç®—æ³•ï¼šCPU å¿…é¡»ä¿è¯æ‰€æœ‰ä¼ é€çš„ä¸‰è§’å½¢éƒ½åœ¨ Guard band é‡Œé¢ã€‚GPU è‡ªå·±å†è£ä¸€éã€‚ thread block thread: ä¸€ä¸ªCUDAçš„å¹¶è¡Œç¨‹åºä¼šè¢«ä»¥è®¸å¤šä¸ªthreadæ¥æ‰§è¡Œã€‚ block: æ•°ä¸ªthreadä¼šè¢«ç¾¤ç»„æˆä¸€ä¸ªblockï¼ŒåŒä¸€ä¸ªblockä¸­çš„threadå¯ä»¥åŒæ­¥ï¼Œä¹Ÿå¯ä»¥é€šè¿‡shared memoryè¿›è¡Œé€šä¿¡ã€‚ ablation studies ç‹­ä¹‰ä¸Šçš„æ¶ˆèå®éªŒ åœ¨æœºå™¨å­¦ä¹ é¢†åŸŸï¼Œå°¤å…¶æ˜¯å¤æ‚çš„æ·±åº¦ç¥ç»ç½‘ç»œä¸­ï¼Œ&quot;æ¶ˆèç ”ç©¶ &quot;è¢«ç”¨æ¥æè¿°åˆ‡é™¤ç½‘ç»œæŸäº›éƒ¨åˆ†çš„è¿‡ç¨‹ï¼Œä»¥ä¾¿æ›´å¥½åœ°äº†è§£ç½‘ç»œçš„è¡Œä¸ºã€‚ å¯ä»¥çœ‹å‡ºï¼Œæ¶ˆèå®éªŒçš„ç›®çš„åœ¨äºç§»é™¤ç³»ç»Ÿä¸­çš„ç‰¹å®šçš„éƒ¨åˆ†ï¼Œæ¥æ§åˆ¶å˜é‡å¼çš„ç ”ç©¶è¿™ä¸ªéƒ¨åˆ†å¯¹äºç³»ç»Ÿæ•´ä½“çš„å½±å“ã€‚å¦‚æœå»é™¤è¿™ä¸€éƒ¨åˆ†åç³»ç»Ÿçš„æ€§èƒ½æ²¡æœ‰å¤ªå¤§æŸå¤±ï¼Œé‚£ä¹ˆè¯´æ˜è¿™ä¸€éƒ¨åˆ†å¯¹äºæ•´ä¸ªç³»ç»Ÿè€Œè¨€å¹¶ä¸å…·æœ‰å¤ªå¤§çš„é‡è¦æ€§ï¼›å¦‚æœå»é™¤ä¹‹åç³»ç»Ÿæ€§èƒ½æ˜æ˜¾çš„ä¸‹é™ï¼Œåˆ™è¯´æ˜è¿™ä¸€éƒ¨åˆ†çš„è®¾è®¡æ˜¯å¿…ä¸å¯å°‘çš„ã€‚å½“ç„¶ï¼Œå¦‚æœå‡ºç°äº†ç¬¬ä¸‰ç§æƒ…å†µï¼Œä¹Ÿå°±æ˜¯å»é™¤ä¹‹åæ¨¡å‹çš„æ€§èƒ½ä¸é™åå‡ï¼Œé‚£ä¹ˆå»ºè®®æ‰¾ä¸€ä¸‹bugæˆ–è€…ä¿®æ”¹è®¾è®¡ã€‚ å¹¿ä¹‰ä¸Šçš„æ¶ˆèå®éªŒ æˆ‘ä»¬çŸ¥é“ï¼Œæ¶ˆèå®éªŒçš„æœ¬è´¨ä¸Šå°±æ˜¯æ§åˆ¶å˜é‡ç ”ç©¶å•ä¸ªå˜é‡çš„ä½œç”¨ã€‚é’ˆå¯¹é‚£äº›æ— æ³•å»é™¤çš„å˜é‡ï¼Œæ¯”å¦‚è¶…å‚æ•°çš„é€‰æ‹©ï¼Œè¿™æ—¶å€™æ€»ä¸èƒ½è¯´è®©æˆ‘ä»¬æŠŠè¶…å‚æ•°ç›´æ¥å»æ‰æ¥ç ”ç©¶å®ƒçš„å½±å“ï¼Œå› æ­¤åœ¨è¿™ç§æƒ…å†µä¸‹åº”è¯¥åº”è¯¥é€‰æ‹©æ§åˆ¶ç³»ç»Ÿçš„å…¶ä»–æ–¹é¢ä¸å˜ï¼Œæ¥æµ‹è¯•ä¸€ç»„è¶…å‚æ•°æ¥ç ”ç©¶è¿™ä¸ªå‚æ•°å¯¹äºç³»ç»Ÿçš„å½±å“ã€‚å› æ­¤ï¼Œè¶…å‚æ•°è°ƒå‚å¸¸ç”¨çš„grid searchå’Œrandom searchæœ¬è´¨ä¸Šä¹Ÿæ˜¯æ¶ˆèå®éªŒï¼Œå®ƒä»¬æ¢ç©¶äº†åœ¨åªæ”¹å˜ä¸€ä¸ªå‚æ•°çš„æƒ…å†µä¸‹ç³»ç»Ÿæ€§èƒ½çš„å˜åŒ–ä»è€Œå±•ç¤ºå‚æ•°å¯¹äºç³»ç»Ÿçš„å½±å“ã€‚ gradient flow æ¢¯åº¦æµ ä¼˜åŒ–ç®—æ³•ä¸­çš„æ¢¯åº¦æµä¸å¾®åˆ†æ–¹ç¨‹ å‚è€ƒèµ„æ–™ï¼š åæ–¹å·®çŸ©é˜µçš„å‡ ä½•è§£é‡Š","categories":[{"name":"cv","slug":"cv","permalink":"http://example.com/categories/cv/"},{"name":"cg","slug":"cg","permalink":"http://example.com/categories/cg/"}],"tags":[{"name":"3dgs","slug":"3dgs","permalink":"http://example.com/tags/3dgs/"}],"author":"tugumineko"},{"title":"TAç™¾äººè®¡åˆ’ç¬”è®°","slug":"TAç™¾äººè®¡åˆ’ç¬”è®°","date":"2024-10-22T11:14:45.000Z","updated":"2024-10-22T11:37:25.206Z","comments":true,"path":"2024/10/22/TAç™¾äººè®¡åˆ’ç¬”è®°/","permalink":"http://example.com/2024/10/22/TA%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92%E7%AC%94%E8%AE%B0/","excerpt":"","text":"å›¾å½¢ 1.2 å‘é‡å‰ç§¯ç†è§£ Unityä¸­ä½¿ç”¨CGè¯­è¨€æ—¶ï¼ŒçŸ©é˜µçš„å­˜å‚¨éµå¾ªCGè¯­è¨€çš„è§„åˆ™æ˜¯è¡Œä¼˜å…ˆå¡«å……çš„ï¼Œä½†Unityæä¾›äº†ä¸€ç§ç‰¹æ®Šçš„çŸ©é˜µç±»å‹â€”â€”Matrix4x4ä¾¿äºå˜æ¢çŸ©é˜µçš„å®šä¹‰ï¼Œåªæœ‰è¿™ç§Matrix4x4æ˜¯åˆ—ä¼˜å…ˆå¡«å……çš„ã€‚ å…¶å®å°±å…ˆæƒ³è±¡ä¸–ç•Œç©ºé—´å’Œè§†è§‰ç©ºé—´æ˜¯é‡åˆçš„ï¼Œå†å°†è§†è§‰ç©ºé—´ä½œä¸ºå‚ç…§ç‰©ï¼Œè®©ä¸–ç•Œç©ºé—´ç›¸å¯¹äºè§†è§‰ç©ºé—´é€šè¿‡ç¼©æ”¾æ—‹è½¬å¹³ç§»å˜æ¢è¿˜åŸåˆ°ä¸–ç•Œç©ºé—´åŸæœ¬æ‰€åœ¨çš„ä½ç½®ï¼Œè€Œå‰é¢ç¼©æ”¾æ—‹è½¬å¹³ç§»å˜æ¢æ‰€å¾—çŸ©é˜µå³ä¸–ç•Œç©ºé—´å˜æ¢åˆ°è§†è§‰ç©ºé—´çš„çŸ©é˜µ","categories":[{"name":"CG","slug":"CG","permalink":"http://example.com/categories/CG/"}],"tags":[{"name":"æ¸¸æˆ","slug":"æ¸¸æˆ","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F/"}],"author":"tugumineko"},{"title":"æ™ºèƒ½è½¯ç¡¬ä»¶è“ç‰™ç³»ç»ŸArdiFan","slug":"ArdiFan","date":"2024-09-06T15:11:47.000Z","updated":"2024-09-06T15:34:31.741Z","comments":true,"path":"2024/09/06/ArdiFan/","permalink":"http://example.com/2024/09/06/ArdiFan/","excerpt":"","text":"æ ¹æ®åä¸œå¸ˆèŒƒå¤§å­¦ã€Šåˆ›å®¢å®è·µã€‹è¯¾ç¨‹æœŸæœ«è€ƒæŸ¥æ–¹æ¡ˆç›¸å…³è¦æ±‚ï¼ŒArdiFanæ˜¯åŸºäºArduino Nano 3å¼€å‘æ¿çš„æ™ºèƒ½è½¯ç¡¬ä»¶ç³»ç»Ÿï¼Œæ—¨åœ¨å®ç°é£æ‰‡çš„æ™ºèƒ½æ§åˆ¶ï¼Œæœ¬é¡¹ç›®ä¸ºæœ¬äººä½œä¸šä¸Šä¼ ã€‚ é¡¹ç›®ç®€ä»‹ ArdiFanæ˜¯åŸºäºArduino Nano 3å¼€å‘æ¿çš„æ™ºèƒ½è½¯ç¡¬ä»¶ç³»ç»Ÿï¼Œæ—¨åœ¨å®ç°é£æ‰‡çš„æ™ºèƒ½æ§åˆ¶ã€‚ ArdiFanåç§°Ardiå–è‡ªArduinoã€Remoteã€Detectionã€Intelligentçš„ç¼©å†™ï¼Œå¹¶ä¸”ç®€è¦æ¦‚æ‹¬äº†è¯¥æ™ºèƒ½è½¯ç¡¬ä»¶ç³»ç»Ÿçš„æ ¸å¿ƒåŠŸèƒ½ã€‚Fanå–è‡ªé¡¹ç›®ç±»å‹ï¼Œå³ç”µåŠ¨é£æ‰‡ã€‚ æœ¬é¡¹ç›®åŒ…å«ä¸‰ä¸ªç»„æˆéƒ¨åˆ†ï¼šArdiFanä¸ºä¸»ä½“ç¡¬ä»¶ï¼ŒArdiFan.inoä¸ºarduinoä¸Šè¿è¡Œçš„ç³»ç»Ÿç¨‹åºï¼Œ AndroidClientæ˜¯è“ç‰™æ§åˆ¶Androidå¹³å°çš„appå·¥ç¨‹æºæ–‡ä»¶ã€‚ æœ¬é¡¹ç›®åŒ…å«è¶…å£°æ³¢ã€æŒ‰é’®ä¸è“ç‰™ä¸‰ç§æ§åˆ¶æ–¹å¼ï¼šå½“è¶…å£°æ³¢æ£€æµ‹åˆ°è·ç¦»å°äº40cmæ—¶ï¼Œè‡ªåŠ¨å¯åŠ¨é£æ‰‡ï¼›è·ç¦»å¤§äº40cmå¹¶æŒç»­3ç§’åï¼Œé£æ‰‡è‡ªåŠ¨å…³é—­ï¼›æŒ‰é’®æ§åˆ¶éœ€è¦åœ¨è¶…å£°æ³¢æ£€æµ‹è·ç¦»å°äº40cmçš„æƒ…å†µä¸‹æ–¹å¯æ“ä½œã€‚æ­¤å¤–ï¼Œè“ç‰™æ¨¡å—å¯é€šè¿‡æ‰‹æœºAPPè¿œç¨‹æ§åˆ¶é£æ‰‡çš„å¼€é—­ï¼Œè¿›ä¸€æ­¥æå‡ä½¿ç”¨ä¾¿æ·æ€§ã€‚æœ¬ç³»ç»Ÿé‡‡ç”¨ç›´æµç”µæœºå’Œç»§ç”µå™¨è¿›è¡Œç®€å•ã€ä½æˆæœ¬çš„é£æ‰‡æ“ä½œï¼Œä¸”å…·å¤‡èŠ‚èƒ½ã€è¿œç¨‹æ§åˆ¶ç­‰ä¼˜åŠ¿ï¼Œé€‚ç”¨äºå…¬å…±äº¤é€šå’Œè½¦è½½æœåŠ¡ç­‰åœºæ™¯ã€‚ é¡¹ç›®èƒŒæ™¯ éšç€ç§‘å­¦æŠ€æœ¯çš„æ—¥ç›Šå‘å±•ï¼Œæ™ºèƒ½å®¶å±…æˆä¸ºäº†ä¸€ç§è¶‹åŠ¿ï¼Œä»è€Œå¯¹ä¼ ç»Ÿå®¶ç”µè¿›è¡Œæ™ºèƒ½å‡çº§æˆä¸ºäº†ä¸€ä¸ªçƒ­é—¨è¯é¢˜ã€‚ArdiFanåº”è¿è€Œç”Ÿï¼Œå®ƒé€šè¿‡ç°ä»£é€šä¿¡è“ç‰™æŠ€æœ¯ä¸ºç”¨æˆ·æä¾›äº†ä¾¿æ·çš„é£æ‰‡æ§åˆ¶æ–¹å¼ã€‚ ä¸»è¦åŠŸèƒ½ 1.è¶…å£°æ³¢è‡ªåŠ¨æ§åˆ¶ï¼šå½“è¶…å£°æ³¢ä¼ æ„Ÿå™¨æ£€æµ‹åˆ°è·ç¦»å°äº40cmæ—¶ï¼Œé£æ‰‡è‡ªåŠ¨å¯åŠ¨ï¼›è·ç¦»å¤§äº40cmä¸”æŒç»­3ç§’æ—¶ï¼Œé£æ‰‡è‡ªåŠ¨å…³é—­ã€‚ 2.æŒ‰é’®æ‰‹åŠ¨æ§åˆ¶ï¼šå½“è¶…å£°æ³¢æ£€æµ‹åˆ°è·ç¦»å°äº40cmæ—¶ï¼Œç”¨æˆ·å¯ä»¥é€šè¿‡æŒ‰é’®å¯¹é£æ‰‡è¿›è¡Œæ‰‹åŠ¨æ§åˆ¶ã€‚ 3.è“ç‰™è¿œç¨‹æ§åˆ¶ï¼šé€šè¿‡è“ç‰™æ¨¡å—ä¸æ‰‹æœºAPPè¿æ¥ï¼Œç”¨æˆ·åœ¨ä»»ä½•è·ç¦»ä¸‹éƒ½èƒ½è¿œç¨‹æ§åˆ¶é£æ‰‡çš„å¼€å…³ã€‚ åº”ç”¨åœºæ™¯ ä¸‹é¢å°†ä»¥è½¦è½½æœåŠ¡ä¸­çš„æ™ºèƒ½é£æ‰‡æ§åˆ¶ç³»ç»Ÿä¸ºä¾‹ï¼Œä»‹ç»æœ¬ç³»ç»Ÿè¿›è¡Œçš„ç®€å•ã€ä½æˆæœ¬çš„é£æ‰‡æ“ä½œï¼Œä¸”å…·å¤‡èŠ‚èƒ½ã€è¿œç¨‹æ§åˆ¶ç­‰ä¼˜åŠ¿ï¼Œé€‚ç”¨äºå…¬å…±äº¤é€šå’Œè½¦è½½æœåŠ¡ç­‰åœºæ™¯ã€‚ åœ¨è½¦è½½æœåŠ¡åœºæ™¯ä¸­ï¼Œä¹˜å®¢çš„èˆ’é€‚åº¦ç›´æ¥å½±å“æœåŠ¡ä½“éªŒã€‚å°¤å…¶åœ¨ç‚çƒ­çš„å¤å­£ï¼Œè½¦å†…çš„æ¸©åº¦ç®¡ç†æˆä¸ºäº†æé«˜ä¹˜å®¢æ»¡æ„åº¦çš„å…³é”®å› ç´ ä¹‹ä¸€ã€‚ä¼ ç»Ÿçš„è½¦å†…é£æ‰‡æ§åˆ¶å¤šä¾èµ–äºé©¾é©¶å‘˜æ‰‹åŠ¨æ“ä½œæˆ–ä¹˜å®¢çš„å£å¤´è¯·æ±‚ï¼Œè¿™åœ¨å®é™…åº”ç”¨ä¸­å¯èƒ½æ— æ³•åŠæ—¶å“åº”ä¹˜å®¢çš„éœ€æ±‚ï¼Œå°¤å…¶æ˜¯åœ¨ä¹˜å®¢å¯†é›†æˆ–é©¾é©¶å‘˜æ³¨æ„åŠ›é›†ä¸­äºé“è·¯æƒ…å†µæ—¶ã€‚ ArdiFanæ™ºèƒ½é£æ‰‡æ§åˆ¶ç³»ç»Ÿé’ˆå¯¹çš„æ­£æ˜¯ä¸Šè¿°é—®é¢˜ã€‚é€šè¿‡åœ¨è½¦å†…å®‰è£…åŸºäºArduino Nano 3å¼€å‘æ¿çš„ArdiFanç³»ç»Ÿï¼Œé…åˆè¶…å£°æ³¢ä¼ æ„Ÿå™¨ã€è“ç‰™æ¨¡å—å’Œç›¸å…³æ§åˆ¶é€»è¾‘ï¼Œèƒ½å¤Ÿå®ç°ä»¥ä¸‹åŠŸèƒ½ï¼š 1.è‡ªåŠ¨è°ƒèŠ‚é£æ‰‡å¼€å…³ï¼šå½“è¶…å£°æ³¢ä¼ æ„Ÿå™¨æ£€æµ‹åˆ°è½¦å†…ç‰¹å®šåŒºåŸŸï¼ˆå¦‚ä¹˜å®¢åº§ä½åŒºï¼‰æœ‰ä¹˜å®¢å­˜åœ¨ï¼ˆè·ç¦»å°äº40cmï¼‰æ—¶ï¼Œè‡ªåŠ¨å¯åŠ¨é£æ‰‡ï¼Œå½“ä¹˜å®¢ç¦»å¼€è¯¥åŒºåŸŸä¸”æ— æ–°ä¹˜å®¢è¿›å…¥è¶…è¿‡3ç§’åï¼Œé£æ‰‡è‡ªåŠ¨å…³é—­ã€‚è¿™ä½¿å¾—è½¦å†…æ¸©åº¦ç®¡ç†æ›´åŠ æ™ºèƒ½åŒ–å’Œè‡ªåŠ¨åŒ–ï¼Œå³æ—¶å“åº”ä¹˜å®¢çš„èˆ’é€‚åº¦éœ€æ±‚ã€‚ 2.æ‰‹åŠ¨æ§åˆ¶æœºåˆ¶ï¼šåœ¨éœ€è¦æ‰‹åŠ¨è°ƒèŠ‚é£æ‰‡å¼€å…³çš„æƒ…å†µä¸‹ï¼Œä¹˜å®¢æˆ–é©¾é©¶å‘˜å¯ä»¥ç›´æ¥é€šè¿‡å®‰è£…äºè½¦å†…æ–¹ä¾¿è§¦è¾¾çš„æŒ‰é’®è¿›è¡Œæ“ä½œï¼Œæˆ–é€šè¿‡é¢„å…ˆé…å¯¹çš„è“ç‰™è®¾å¤‡ï¼ˆå¦‚æ™ºèƒ½æ‰‹æœºAPPï¼‰è¿œç¨‹æ§åˆ¶é£æ‰‡ï¼Œæ»¡è¶³ç‰¹å®šéœ€æ±‚ã€‚ 3.æ™ºèƒ½èŠ‚èƒ½ï¼šé€šè¿‡è‡ªåŠ¨æ§åˆ¶é£æ‰‡çš„å¼€é—­ï¼ŒArdiFanèƒ½å¤Ÿæ ¹æ®å®æ—¶éœ€æ±‚è°ƒæ•´é£æ‰‡è¿è¡Œï¼Œé¿å…æ— æ•ˆçš„ç”µèƒ½æ¶ˆè€—ï¼Œå®ç°èŠ‚èƒ½å‡æ’çš„åŒæ—¶ä¿éšœä¹˜å®¢èˆ’é€‚ã€‚ åœ¨å…¬å…±äº¤é€šå·¥å…·ï¼ˆå¦‚å…¬äº¤è½¦ã€å‡ºç§Ÿè½¦ï¼‰å’Œè½¦è½½æœåŠ¡ï¼ˆå¦‚ç½‘çº¦è½¦ï¼‰åœºæ™¯ä¸­ï¼ŒArdiFançš„éƒ¨ç½²èƒ½æå¤§æå‡ä¹˜è½¦ä½“éªŒï¼Œå°¤å…¶åœ¨ç‚çƒ­æˆ–æ‹¥æŒ¤çš„æ¡ä»¶ä¸‹ï¼Œè‡ªåŠ¨å’Œæ™ºèƒ½åŒ–çš„é£æ‰‡æ§åˆ¶èƒ½ä¸ºä¹˜å®¢æä¾›å³æ—¶çš„å‡‰çˆ½ç¯å¢ƒï¼Œå¢åŠ ä¹˜å®¢æ»¡æ„åº¦ï¼Œå¯¹æå‡æœåŠ¡å“è´¨å’Œç«äº‰åŠ›å…·æœ‰ç§¯æçš„æ¨åŠ¨ä½œç”¨ã€‚åŒæ—¶ï¼ŒèŠ‚èƒ½ç‰¹æ€§ä¹Ÿç¬¦åˆç°ä»£ç¯ä¿ç†å¿µï¼Œæœ‰åŠ©äºå‡å°‘èƒ½æºæµªè´¹ï¼Œæ¨åŠ¨ç»¿è‰²å‡ºè¡Œã€‚ é€šè¿‡åœ¨è½¦è½½æœåŠ¡åœºæ™¯ä¸­å¼•å…¥ArdiFanè¿™æ ·çš„æ™ºèƒ½é£æ‰‡æ§åˆ¶ç³»ç»Ÿï¼Œä½“ç°äº†æ™ºèƒ½ç§‘å­¦æŠ€æœ¯åœ¨æå‡ä¼ ç»ŸæœåŠ¡é¢†åŸŸç”¨æˆ·ä½“éªŒä¸­çš„å·¨å¤§æ½œåŠ›å’Œåº”ç”¨ä»·å€¼ã€‚ æŠ€æœ¯åŸç† é¡¹ç›®åŸºäºArduino Nano 3å¼€å‘æ¿ï¼Œåˆ©ç”¨è¶…å£°æ³¢ä¼ æ„Ÿå™¨HC-SR04è¿›è¡Œè·ç¦»æ£€æµ‹ï¼Œé€šè¿‡ç»§ç”µå™¨æ¨¡å—æ§åˆ¶é£æ‰‡ç”µæºå¼€å…³ã€‚è“ç‰™é€šä¿¡éƒ¨åˆ†é‡‡ç”¨HC-06æ¨¡å—ï¼Œå®ç°ä¸Androidå®¢æˆ·ç«¯çš„æ•°æ®äº¤æ¢ã€‚ Androidå®¢æˆ·ç«¯çš„æŠ€æœ¯åŸç†åˆ™ä¸»è¦å›´ç»•è“ç‰™é€šä¿¡ã€åŠ¨æ€æƒé™è¯·æ±‚ã€æ•°æ®æµçš„è¯»å†™æ“ä½œã€å¤šçº¿ç¨‹ç®¡ç†ä»¥åŠç•Œé¢ç”¨æˆ·äº¤äº’(UI)æ›´æ–°å‡ ä¸ªå…³é”®ç‚¹å±•å¼€ã€‚ ä»£ç éƒ¨åˆ†å°†ä¼šåœ¨å®ç°æ–¹æ³•ä¸æ­¥éª¤è¯´æ˜ å®ç°æ–¹æ³•ä¸æ­¥éª¤ ä¸€ã€ç¡¬ä»¶éƒ¨åˆ† ä½¿ç”¨å™¨æï¼š Arduino Nano 3 --1 Bluetooth Wireless HC-06 --1 Distance sensor HC-SR04 --1 R3000C DC motor --1 Button switch --1 1 Channel 5v Relay Module --1 AAA Battery Holders --1 Breadboard half-size --2 AAA Battery --2 å¯¼çº¿è‹¥å¹² æ ¹æ®ç”µè·¯å›¾è¿æ¥ï¼Œå¦‚å›¾æ‰€ç¤ºï¼š å®ç‰©è¿æ¥å¦‚ä¸‹ï¼š äºŒã€è½¯ä»¶éƒ¨åˆ† ä¸‹é¢æˆ‘å°†å¯¹ä»£ç è¿›è¡Œåˆ†æè¯´æ˜ï¼š Arduinoéƒ¨åˆ† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;SoftwareSerial.h&gt;const int TrigPin = 2;const int EchoPin = 3;const int FAN_PIN = 4;const int BUTTON_PIN = 5;unsigned long fanOffBeginTime = 0;unsigned long lastDebounceTime = 0; // ä¸Šä¸€æ¬¡é˜²æŠ–æ—¶é—´unsigned long lastButtonPressTime = 0; // ä¸Šæ¬¡æŒ‰é’®æŒ‰ä¸‹çš„æ—¶é—´const unsigned long debounceDelay = 50; // é˜²æŠ–å»¶è¿Ÿå¸¸é‡bool controlByBT = true; // è“ç‰™æ€»æ§åˆ¶// æŒ‰é’®æ“ä½œæ ‡å¿—bool button2ON = false; bool button2OFF = false; SoftwareSerial BTSerial(10, 11); // åˆ›å»ºè½¯ä»¶ä¸²å£void setup() &#123; pinMode(TrigPin, OUTPUT); pinMode(EchoPin, INPUT); pinMode(FAN_PIN, OUTPUT); pinMode(BUTTON_PIN, INPUT_PULLUP); // å¯ç”¨å†…éƒ¨ä¸Šæ‹‰ç”µé˜» Serial.begin(9600); BTSerial.begin(9600);&#125;void loop() &#123; static bool fanStatus = false; static int lastButtonStatus = HIGH; // é»˜è®¤çŠ¶æ€æ˜¯ HIGHï¼Œå› ä¸ºå¯ç”¨äº†å†…éƒ¨ä¸Šæ‹‰ int distance = getAvgDistance(); unsigned long currentMillis = millis(); static unsigned long previousMillis = 0; const long interval = 1000; // è®¾ç½®æ—¶é—´é—´éš”ä¸º100æ¯«ç§’ // æŒ‰é’®æ¨¡å— int currentButtonStatus = digitalRead(BUTTON_PIN); if (currentButtonStatus != lastButtonStatus &amp;&amp; millis() - lastDebounceTime &gt; debounceDelay) &#123; lastDebounceTime = millis(); lastButtonStatus = currentButtonStatus; if (currentButtonStatus == LOW) &#123; // æŒ‰é’®ä» HIGH å˜ä¸º LOW (fanStatus ? button2OFF : button2ON) = true; lastButtonPressTime = millis(); // è®°å½•æŒ‰é’®æŒ‰ä¸‹æ—¶é—´ &#125; &#125; // è“ç‰™æ¿å— if(BTSerial.available())&#123; String state = BTSerial.readString(); if(state == &quot;on&quot;)&#123; controlByBT = true; // å¦‚æœæ¥æ”¶åˆ°&quot;on&quot;ï¼Œåˆ™ controlByBT è®¾ç½®ä¸º true &#125; else if(state == &quot;off&quot;)&#123; controlByBT = false; // å¦‚æœæ¥æ”¶åˆ°&quot;off&quot;ï¼Œåˆ™ controlByBT è®¾ç½®ä¸º falseï¼Œå…³é—­é£æ‰‡ fanStatus = false; button2ON = false; button2OFF = false; &#125; &#125; // è·ç¦»æ§åˆ¶é£æ‰‡é€»è¾‘ if (controlByBT) &#123; if (distance &lt; 40) &#123; if(button2OFF)&#123; fanStatus = false; &#125; if(button2ON)&#123; fanStatus = true; button2ON = false; button2OFF = false; &#125; if(!button2ON &amp;&amp; !button2OFF)&#123; fanStatus = true; &#125; fanOffBeginTime = millis(); &#125; if (millis() - fanOffBeginTime &gt; 3000) &#123; fanStatus = false; button2ON = false; button2OFF = false; &#125; &#125; digitalWrite(FAN_PIN, fanStatus ? HIGH : LOW); // æ§åˆ¶é£æ‰‡ //è“ç‰™ä¸²å£è¾“å‡º if (currentMillis - previousMillis &gt;= interval) &#123; previousMillis = currentMillis; BTSerial.print(distance); BTSerial.print(&quot; &quot;); BTSerial.println(fanStatus ? &quot;on&quot; : &quot;off&quot;); &#125;&#125;// é˜²æŠ– å¤šæ¬¡æµ‹é‡æ±‚ä¸­ä½æ•°int getAvgDistance() &#123; int readings[10]; for (int i = 0; i &lt; 10; i++) &#123; digitalWrite(TrigPin, LOW); delayMicroseconds(5); digitalWrite(TrigPin, HIGH); delayMicroseconds(10); digitalWrite(TrigPin, LOW); readings[i] = pulseIn(EchoPin, HIGH) / 58.0; delay(10); &#125; qsort(readings, 10, sizeof(int), cmp); return readings[5]; // è¿”å›ä¸­ä½æ•°&#125;int cmp(const void *a, const void *b) &#123; return *(int*)a - *(int*)b;&#125; æ¦‚æ‹¬åœ°è¯´ï¼Œè¿™æ®µä»£ç åŒ…å«ä»¥ä¸‹å››ä¸ªå…³é”®éƒ¨åˆ†çš„å®ç°ï¼šè¶…å£°æ³¢è·ç¦»æ„Ÿæµ‹ã€æŒ‰é’®æ§åˆ¶ã€è“ç‰™é€šä¿¡æ§åˆ¶ï¼Œä»¥åŠé˜²æŠ–å¤„ç†ã€‚ è¶…å£°æ³¢è·ç¦»æ„Ÿæµ‹ï¼šè¶…å£°æ³¢ä¼ æ„Ÿå™¨HC-SR04ç”¨äºæµ‹é‡å¯¹è±¡åˆ°ä¼ æ„Ÿå™¨çš„è·ç¦»ã€‚å½“è§¦å‘è„šï¼ˆTrigPinï¼‰æ¥æ”¶åˆ°é«˜ç”µå¹³è„‰å†²ä¿¡å·æ—¶ï¼ŒHC-SR04ä¼šå‘å°„ä¸€ç³»åˆ—è¶…å£°æ³¢è„‰å†²ã€‚è¿™äº›è„‰å†²é‡åˆ°éšœç¢ç‰©åä¼šåå°„å›æ¥ï¼Œè¢«å›å£°è„šï¼ˆEchoPinï¼‰æ¥æ”¶ã€‚é€šè¿‡è®¡ç®—è¶…å£°æ³¢è¢«å‘å°„å’Œæ¥æ”¶çš„æ—¶é—´å·®ï¼Œå¯ä»¥æ ¹æ®å£°æ³¢åœ¨ç©ºæ°”ä¸­çš„ä¼ æ’­é€Ÿåº¦è®¡ç®—å‡ºè·ç¦»ã€‚è¿™éƒ¨åˆ†ä»£ç é¦–å…ˆå°†è¶…å£°æ³¢ä¿¡å·å‘å°„å‡ºå»ï¼Œç„¶åæµ‹é‡æ¥æ”¶åˆ°å›å£°çš„æ—¶é—´ï¼Œä»è€Œè®¡ç®—å‡ºè·ç¦»ã€‚ æŒ‰é’®æ§åˆ¶ï¼šæŒ‰é’®æ§åˆ¶éƒ¨åˆ†é€šè¿‡ç›‘å¬æŒ‰é’®å¼•è„šçš„ç”µå¹³å˜åŒ–æ¥æ§åˆ¶é£æ‰‡å¼€å…³çŠ¶æ€ã€‚ç”±äºç‰©ç†æŒ‰é’®åœ¨çŠ¶æ€å˜åŒ–æ—¶ä¼šå­˜åœ¨æ¥è§¦æŠ–åŠ¨ï¼Œå› æ­¤éœ€è¦è¿›è¡Œé˜²æŠ–å¤„ç†ï¼Œä»¥é¿å…è¯¯åˆ¤ã€‚è¿™é‡Œå½“æ£€æµ‹åˆ°æŒ‰é’®çŠ¶æ€æ”¹å˜ï¼Œå¹¶ä¸”è·ç¦»ä¸Š ä¸€æ¬¡çŠ¶æ€å˜åŒ–è¶…è¿‡ä¸€å®šçš„é˜²æŠ–å»¶æ—¶ï¼ˆdebounceDelayï¼‰ï¼Œæ‰è®¤ä¸ºæ˜¯æœ‰æ•ˆçš„æŒ‰é’®æ“ä½œã€‚ è“ç‰™é€šä¿¡æ§åˆ¶ï¼šé€šè¿‡SoftWareSerialåº“åˆ›å»ºçš„è½¯ä»¶ä¸²å£BTSerialå®ç°ä¸è“ç‰™æ¨¡å—HC-06çš„é€šä¿¡ã€‚ç³»ç»Ÿé€šè¿‡è¯»å–è“ç‰™æ¨¡å—ä¼ æ¥çš„å­—ç¬¦ä¸²å‘½ä»¤ï¼ˆâ€œon&quot;æˆ–&quot;offâ€ï¼‰ï¼Œæ¥æ§åˆ¶é£æ‰‡çš„å¼€å¯å’Œå…³é—­ã€‚ é˜²æŠ–å¤„ç†ï¼šé‡‡ç”¨å¤šæ¬¡æµ‹é‡å¹¶æ’åºå–ä¸­ä½æ•°çš„æ–¹æ³•ï¼Œå¯ä»¥æœ‰æ•ˆå‡å°‘å¶å‘é”™è¯¯è¯»æ•°çš„å½±å“ï¼Œæé«˜æµ‹é‡çš„å‡†ç¡®æ€§ã€‚ åŸºäºè¿™äº›è¾“å…¥ï¼Œç³»ç»Ÿå®ç°äº†ä¸€ä¸ªæ—¢èƒ½è‡ªåŠ¨å“åº”ç¯å¢ƒå˜åŒ–ï¼Œåˆèƒ½æ¥å—å¤–éƒ¨æŒ‡ä»¤æˆ–æ‰‹åŠ¨æ§åˆ¶çš„æ™ºèƒ½æ§åˆ¶é€»è¾‘ã€‚ Android Studioéƒ¨åˆ† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265package com.example.heart;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import androidx.cardview.widget.CardView;import androidx.core.app.ActivityCompat;import androidx.core.content.ContextCompat;import android.Manifest;import android.bluetooth.BluetoothAdapter;import android.bluetooth.BluetoothDevice;import android.bluetooth.BluetoothSocket;import android.content.Intent;import android.content.IntentFilter;import android.content.pm.PackageManager;import android.os.Build;import android.os.Bundle;import android.widget.LinearLayout;import android.widget.TextView;import android.widget.Toast;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.util.UUID;public class MainActivity extends AppCompatActivity &#123; LinearLayout ll_start,ll_stop; // è·å–åˆ°è“ç‰™é€‚é…å™¨ private BluetoothAdapter mBluetoothAdapter; // UUIDï¼Œè“ç‰™å»ºç«‹é“¾æ¥éœ€è¦çš„ private final UUID MY_UUID = UUID .fromString(&quot;00001101-0000-1000-8000-00805F9B34FB&quot;); // é€‰ä¸­å‘é€æ•°æ®çš„è“ç‰™è®¾å¤‡ï¼Œå…¨å±€å˜é‡ï¼Œå¦åˆ™è¿æ¥åœ¨æ–¹æ³•æ‰§è¡Œå®Œå°±ç»“æŸäº† private BluetoothDevice selectDevice; // è·å–åˆ°é€‰ä¸­è®¾å¤‡çš„å®¢æˆ·ç«¯ä¸²å£ï¼Œå…¨å±€å˜é‡ï¼Œå¦åˆ™è¿æ¥åœ¨æ–¹æ³•æ‰§è¡Œå®Œå°±ç»“æŸäº† private BluetoothSocket clientSocket; // è·å–åˆ°å‘è®¾å¤‡å†™çš„è¾“å‡ºæµï¼Œå…¨å±€å˜é‡ï¼Œå¦åˆ™è¿æ¥åœ¨æ–¹æ³•æ‰§è¡Œå®Œå°±ç»“æŸäº† public static InputStream is; public static OutputStream os; private String receivedData=&quot;&quot;; private Thread thread; private volatile boolean running = true; // çº¿ç¨‹è¿è¡Œæ§åˆ¶æ ‡å¿— private TextView tv_1,tv_2; private static final int PERMISSION_REQUEST_CODE = 100; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ll_start = findViewById(R.id.ll_start); ll_stop = findViewById(R.id.ll_stop); tv_1 = findViewById(R.id.textView1); tv_2 = findViewById(R.id.textView2); ll_start.setOnClickListener(view -&gt; &#123; Toast.makeText(this, &quot;å¼€å§‹è¿æ¥&quot;, Toast.LENGTH_SHORT).show(); initè“ç‰™(); &#125;); ll_stop.setOnClickListener(view -&gt; &#123; running = false; // å®‰å…¨åœ°åœæ­¢çº¿ç¨‹ &#125;); // æ£€æŸ¥å¹¶ç”³è¯·æƒé™ if (!hasRequiredPermissions()) &#123; requestRequiredPermissions(); &#125; findViewById(R.id.open).setOnClickListener(v -&gt; &#123; if (os == null) &#123; Toast.makeText(this, &quot;è¯·å…ˆè¿æ¥&quot;, Toast.LENGTH_SHORT).show(); return; &#125; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; os.write(&quot;on&quot;.getBytes()); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;).start(); Toast.makeText(this, &quot;å‘é€æˆåŠŸ&quot;, Toast.LENGTH_SHORT).show(); &#125;); findViewById(R.id.close).setOnClickListener(v -&gt; &#123; if (os == null) &#123; Toast.makeText(this, &quot;è¯·å…ˆè¿æ¥&quot;, Toast.LENGTH_SHORT).show(); return; &#125; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; os.write(&quot;off&quot;.getBytes()); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;).start(); Toast.makeText(this, &quot;å‘é€æˆåŠŸ&quot;, Toast.LENGTH_SHORT).show(); &#125;); &#125; private boolean hasRequiredPermissions() &#123; return ContextCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH) == PackageManager.PERMISSION_GRANTED &amp;&amp; ContextCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH_CONNECT) == PackageManager.PERMISSION_GRANTED &amp;&amp; ContextCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH_SCAN) == PackageManager.PERMISSION_GRANTED &amp;&amp; ContextCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH_ADMIN) == PackageManager.PERMISSION_GRANTED &amp;&amp; ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED &amp;&amp; ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED; &#125; private void requestRequiredPermissions() &#123; ActivityCompat.requestPermissions(this, new String[] &#123; Manifest.permission.BLUETOOTH, Manifest.permission.BLUETOOTH_CONNECT, Manifest.permission.BLUETOOTH_SCAN, Manifest.permission.BLUETOOTH_ADMIN, Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION &#125;, PERMISSION_REQUEST_CODE); &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == PERMISSION_REQUEST_CODE) &#123; boolean allPermissionsGranted = true; for (int result : grantResults) &#123; if (result != PackageManager.PERMISSION_GRANTED) &#123; allPermissionsGranted = false; break; &#125; &#125; if (allPermissionsGranted) &#123; // æ‰€æœ‰æƒé™éƒ½å·²æˆäºˆï¼Œæ‰§è¡Œéœ€è¦æƒé™çš„æ“ä½œ &#125; else &#123; // æƒé™è¢«æ‹’ç»ï¼Œå¤„ç†æ‹’ç»æƒ…å†µ &#125; &#125; &#125; private void initè“ç‰™() &#123; // è·å–åˆ°è“ç‰™é»˜è®¤çš„é€‚é…å™¨ mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); // å¯¹å…¶è¿›è¡Œåˆ†å‰²ï¼Œè·å–åˆ°è¿™ä¸ªè®¾å¤‡çš„åœ°å€ String address = &quot;98:D3:61:F9:4F:B8&quot;; // åˆ¤æ–­å½“å‰æ˜¯å¦è¿˜æ˜¯æ­£åœ¨æœç´¢å‘¨è¾¹è®¾å¤‡ï¼Œå¦‚æœæ˜¯åˆ™æš‚åœæœç´¢ if (ActivityCompat.checkSelfPermission(MainActivity.this, android.Manifest.permission.BLUETOOTH_SCAN) != PackageManager.PERMISSION_GRANTED) &#123; //åˆ¤æ–­æ˜¯å¦æ­£åœ¨æœç´¢ &#125; if (mBluetoothAdapter.isDiscovering()) &#123; mBluetoothAdapter.cancelDiscovery(); &#125; // å¦‚æœé€‰æ‹©è®¾å¤‡ä¸ºç©ºåˆ™ä»£è¡¨è¿˜æ²¡æœ‰é€‰æ‹©è®¾å¤‡ if (selectDevice == null) &#123; //é€šè¿‡åœ°å€è·å–åˆ°è¯¥è®¾å¤‡ selectDevice = mBluetoothAdapter.getRemoteDevice(address); &#125; // è¿™é‡Œéœ€è¦try catchä¸€ä¸‹ï¼Œä»¥é˜²å¼‚å¸¸æŠ›å‡º try &#123; // åˆ¤æ–­å®¢æˆ·ç«¯æ¥å£æ˜¯å¦ä¸ºç©º if (clientSocket == null) &#123; clientSocket = selectDevice .createRfcommSocketToServiceRecord(MY_UUID); // å‘æœåŠ¡ç«¯å‘é€è¿æ¥ clientSocket.connect(); // è·å–åˆ°è¾“å‡ºæµï¼Œå‘å¤–å†™æ•°æ® os = clientSocket.getOutputStream(); // è·å–åˆ°è¾“å…¥æµï¼Œç”¨äºæ¥æ”¶æ•°æ® is = clientSocket.getInputStream(); &#125; // åå¸ä¸€ä¸‹ï¼Œå‘Šè¯‰ç”¨æˆ·æˆåŠŸ if (os != null)&#123; Toast.makeText(MainActivity.this, &quot;è¿æ¥æˆåŠŸ&quot;, Toast.LENGTH_SHORT).show(); running = true; // å®‰å…¨åœ°å¼€å§‹çº¿ç¨‹ thread = new GetData(); thread.start(); &#125;else &#123; Toast.makeText(MainActivity.this, &quot;å»ºç«‹è¿æ¥å¤±è´¥&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); // å¦‚æœå‘ç”Ÿå¼‚å¸¸åˆ™å‘Šè¯‰ç”¨æˆ·å‘é€å¤±è´¥ Toast.makeText(MainActivity.this, &quot;è¿æ¥å¤±è´¥&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; class GetData extends Thread &#123; @Override public void run() &#123; while (running) &#123; try &#123; byte[] buffer = new byte[1024]; int bytesRead; StringBuilder stringBuilder = new StringBuilder(); while ((bytesRead = is.read(buffer)) != -1) &#123; receivedData = new String(buffer, 0, bytesRead); stringBuilder.append(receivedData); //System.out.println(receivedData); if (!running)break; if(receivedData!=null)&#123; if (receivedData.contains(&quot;\\n&quot;)) receivedData = receivedData.split(&quot;\\n&quot;)[0]; if (receivedData.contains(&quot;on&quot;)||receivedData.contains(&quot;of&quot;))&#123; String[] a = receivedData.trim().split(&quot; &quot;); for (int i = 0; i &lt; a.length; i++) &#123; if (a[i].contains(&quot;on&quot;)||a[i].contains(&quot;of&quot;))&#123; tv_2.setText(&quot;è¿è¡ŒçŠ¶æ€: &quot;+a[1]); &#125;else &#123; if (!a[i].isEmpty())&#123; tv_1.setText(&quot;æ£€æµ‹è·ç¦»: &quot;+a[0]+&quot; cm&quot;); &#125; &#125; &#125; System.out.println(&quot;data:&quot;+receivedData); &#125; &#125; &#125; &#125; catch (IOException e) &#123; // e.printStackTrace(); if (!running) &#123; // å¦‚æœçº¿ç¨‹æ˜¯å› ä¸ºè°ƒç”¨ stopRunning è€Œä¸­æ–­çš„ï¼Œåˆ™é€€å‡ºå¾ªç¯ break; &#125; &#125; catch (Exception e) &#123; //e.printStackTrace(); &#125; &#125; &#125; &#125; public static String getCurrentTimeString() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; // è·å–å½“å‰æ—¥æœŸå’Œæ—¶é—´ LocalDateTime now = null; now = LocalDateTime.now(); // å®šä¹‰æ—¥æœŸæ—¶é—´æ ¼å¼ DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;); // å°†å½“å‰æ—¥æœŸæ—¶é—´æ ¼å¼åŒ–ä¸ºå­—ç¬¦ä¸² return now.format(formatter); &#125;else &#123; return &quot;2023-12-09 16:06:34&quot;; &#125; &#125; è¿™æ®µä»£ç å®ç°äº†é€šè¿‡è“ç‰™ä¸Arduinoè®¾å¤‡å»ºç«‹è¿æ¥å¹¶è¿›è¡Œäº¤äº’ã€‚ é¦–å…ˆåˆå§‹åŒ–åº”ç”¨ç•Œé¢ï¼ŒåŒ…æ‹¬è®¾ç½®æŒ‰é’®ç›‘å¬å™¨ï¼Œç”¨äºå¼€å§‹å’Œç»“æŸä¸è®¾å¤‡çš„è¿æ¥ã€‚ 2. ä¸ºäº†åœ¨Android 6.0åŠä»¥ä¸Šç‰ˆæœ¬ä¸Šæ­£å¸¸è¿ä½œï¼Œè¿˜è¦è¯·æ±‚ç”¨æˆ·æˆæƒè“ç‰™å’Œä½ç½®è®¿é—®æƒé™ã€‚å¾—åˆ°æƒé™åï¼Œåº”ç”¨é€šè¿‡è“ç‰™é€‚é…å™¨æŸ¥æ‰¾å¹¶è¿æ¥åˆ°æŒ‡å®šçš„Arduinoè®¾å¤‡ï¼Œä½¿ç”¨ä¸€ä¸ªé¢„å®šä¹‰çš„UUIDå»ºç«‹ä¸€ä¸ªå®‰å…¨çš„RFCommï¼ˆä¸²è¡Œç«¯å£æœåŠ¡ï¼‰è¿æ¥ã€‚ 3. è¿æ¥æˆåŠŸåï¼Œåº”ç”¨å¯ä»¥è·å–è¾“å‡ºæµå’Œè¾“å…¥æµï¼Œä»¥å‘è®¾å¤‡å‘é€æŒ‡ä»¤ï¼ˆæ¯”å¦‚â€œå¼€â€æˆ–â€œå…³â€æŒ‡ä»¤ï¼‰å¹¶è¯»å–è®¾å¤‡è¿”å›çš„æ•°æ®ã€‚å‘é€å’Œæ¥æ”¶æ•°æ®çš„åŠŸèƒ½åœ¨ä¸€ä¸ªå«åšGetDataçš„çº¿ç¨‹ä¸­å®ç°ï¼Œä»¥é¿å…ä¸»çº¿ç¨‹é˜»å¡ã€‚ 4. ä¹‹åç”¨æˆ·å¯ä»¥é€šè¿‡ç‚¹å‡»ç•Œé¢ä¸Šçš„æŒ‰é’®å‘é€ç‰¹å®šçš„æŒ‡ä»¤åˆ°Arduinoè®¾å¤‡ï¼Œåº”ç”¨å°†æ ¹æ®ä»Arduinoè®¾å¤‡æ¥æ”¶åˆ°çš„æ•°æ®æ›´æ–°ç•Œé¢ä¸Šçš„æ˜¾ç¤ºå†…å®¹ã€‚ è¿è¡Œç»“æœå¦‚ä¸‹ï¼š è·ç¦»æ£€æµ‹å’Œé£æ‰‡çŠ¶æ€æ˜¾ç¤ºï¼š Androidå®¢æˆ·ç«¯çš„æœ€ä¸Šæ–¹ä¸¤è¡Œåˆ†åˆ«æ˜¾ç¤ºå½“å‰è¶…å£°æ³¢æ£€æµ‹åˆ°çš„è·ç¦»ï¼ˆå•ä½ï¼šcmï¼‰å’Œé£æ‰‡çš„è¿è¡ŒçŠ¶æ€ï¼ˆonæˆ–offï¼‰ã€‚ é£æ‰‡æ§åˆ¶ï¼š åœ¨å®¢æˆ·ç«¯çš„ä¸­é—´åŒºåŸŸï¼Œæä¾›ä¸¤ä¸ªæŒ‰é’®ï¼Œåˆ†åˆ«ç”¨äºæ‰‹åŠ¨æ§åˆ¶é£æ‰‡çš„å¼€é—­çŠ¶æ€ã€‚ è“ç‰™è¿æ¥ç®¡ç†ï¼š å®¢æˆ·ç«¯çš„æœ€ä¸‹æ–¹ä¸¤è¡Œç”¨äºè“ç‰™åŠŸèƒ½ï¼Œå…¶ä¸­ä¸€ä¸ªæŒ‰é’®ç”¨äºè¿æ¥è“ç‰™æ¨¡å—ï¼Œå¦ä¸€ä¸ªæŒ‰é’®ç”¨äºæ–­å¼€è¿æ¥ã€‚ å…³é”®æŠ€æœ¯ å¤šæ¨¡å¼æ§åˆ¶æœºåˆ¶ï¼šArdiFanç³»ç»Ÿé›†æˆäº†è¶…å£°æ³¢æ„Ÿåº”ã€ç‰©ç†æŒ‰é’®æ“ä½œå’Œè“ç‰™è¿œç¨‹æ§åˆ¶ä¸‰ç§æ§åˆ¶æ¨¡å¼ï¼Œä¸ºç”¨æˆ·æä¾›äº†å¤šæ ·åŒ–çš„æ“ä½œé€‰æ‹©ã€‚è¿™ç§å¤šæ¨¡å¼çš„è®¾è®¡ä½¿å¾—ArdiFanèƒ½å¤Ÿåœ¨ä¸åŒæƒ…å¢ƒä¸‹çµæ´»ä½¿ç”¨ï¼Œä¾‹å¦‚è‡ªåŠ¨æ„Ÿåº”å¼€å…³åŠŸèƒ½é€‚ç”¨äºæ— æ‰‹è§¦æ§çš„ç¯å¢ƒï¼Œè€Œè“ç‰™æ§åˆ¶åˆ™ä¾¿äºç”¨æˆ·åœ¨è¿œè·ç¦»è¿›è¡Œæ“ä½œã€‚ æ™ºèƒ½èŠ‚èƒ½ç­–ç•¥ï¼šé€šè¿‡é›†æˆçš„è¶…å£°æ³¢ä¼ æ„Ÿå™¨è‡ªåŠ¨æ£€æµ‹ç”¨æˆ·çš„å­˜åœ¨ä¸å¦ï¼ŒArdiFanèƒ½åœ¨ç”¨æˆ·é è¿‘æ—¶è‡ªåŠ¨å¼€å¯é£æ‰‡ï¼Œåœ¨ç”¨æˆ·ç¦»å¼€ä¸€å®šæ—¶é—´åè‡ªåŠ¨å…³é—­é£æ‰‡ï¼Œä»è€Œå®ç°èŠ‚èƒ½å‡æ’çš„ç›®çš„ã€‚è¿™ç§è‡ªåŠ¨åŒ–æ§åˆ¶ç­–ç•¥æœ‰æ•ˆå‡å°‘äº†èƒ½æºæµªè´¹ã€‚ è·¨å¹³å°è¿œç¨‹æ§åˆ¶åº”ç”¨ï¼šArdiFané¡¹ç›®åŒ…å«äº†ä¸€ä¸ªAndroidå®¢æˆ·ç«¯ï¼Œä½¿å¾—ç”¨æˆ·å¯ä»¥é€šè¿‡æ™ºèƒ½æ‰‹æœºè¿œç¨‹æ§åˆ¶é£æ‰‡ã€‚è¿™ç§è·¨å¹³å°çš„åº”ç”¨å¼€å‘ä¸ºArduinoé¡¹ç›®æä¾›äº†æ›´å¹¿é˜”çš„ä½¿ç”¨åœºæ™¯ï¼Œå¢åŠ äº†ç”¨æˆ·äº¤äº’çš„ä¾¿æ·æ€§ã€‚ ä½æˆæœ¬å®ç°é«˜ä»·å€¼åŠŸèƒ½ï¼šæ•´ä¸ªArdiFanç³»ç»Ÿçš„å®ç°åŸºäºæˆæœ¬ç›¸å¯¹ä½å»‰çš„Arduinoæ¿å’Œä¼ æ„Ÿå…ƒä»¶ï¼Œä½†å´å®ç°äº†å¸‚é¢ä¸Šé«˜ç«¯æ™ºèƒ½é£æ‰‡æ‰å…·å¤‡çš„åŠŸèƒ½ï¼Œå±•ç°äº†åˆ©ç”¨å¼€æºç¡¬ä»¶å’Œè½¯ä»¶å¹³å°è¿›è¡Œæ™ºèƒ½å®¶å±…é¡¹ç›®å¼€å‘çš„å·¨å¤§æ½œåŠ›ã€‚","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"C","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"Arduino","slug":"Arduino","permalink":"http://example.com/tags/Arduino/"}],"author":"tugumineko"},{"title":"cppå¤šçº¿ç¨‹ä½¿ç”¨æ–¹æ³•","slug":"cpp-thread","date":"2024-08-18T11:25:55.000Z","updated":"2024-08-18T13:01:49.450Z","comments":true,"path":"2024/08/18/cpp-thread/","permalink":"http://example.com/2024/08/18/cpp-thread/","excerpt":"","text":"C++11çš„std::thread å¼€é—¨è§å±±ï¼Œcppå¤šçº¿ç¨‹ä½¿ç”¨æ–¹æ³•å°±æ˜¯ä½¿ç”¨C++11çš„threadè¿›è¡Œå¤šçº¿ç¨‹ç¼–ç¨‹ã€‚ std::threadå¸¸ç”¨æˆå‘˜å‡½æ•° æ„é€ &amp;ææ„å‡½æ•° å‡½æ•° ç±»åˆ« ä½œç”¨ thread() é»˜è®¤æ„é€ å‡½æ•° åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ thread(thread&amp;&amp; x) ç§»åŠ¨æ„é€ å‡½æ•° æ„é€ ä¸€ä¸ªä¸xç›¸åŒçš„å¯¹è±¡ï¼Œä¼šç ´ç¯xå¯¹è±¡ ~thread() ææ„å‡½æ•° ææ„å¯¹è±¡ å¸¸ç”¨æˆå‘˜å‡½æ•° å‡½æ•° ä½œç”¨ void join() ç­‰å¾…çº¿ç¨‹ç»“æŸå¹¶æ¸…ç†èµ„æº(ä¼šé˜»å¡) bool joinable() è¿”å›çº¿ç¨‹æ˜¯å¦å¯ä»¥æ‰§è¡Œjoinå‡½æ•° void detach() å°†çº¿ç¨‹ä¸è°ƒç”¨å…¶çš„çº¿ç¨‹åˆ†ç¦»ï¼Œå½¼æ­¤ç‹¬ç«‹æ‰§è¡Œ(æ­¤å‡½æ•°å¿…é¡»åœ¨çº¿ç¨‹åˆ›å»ºæ—¶ç«‹å³è°ƒç”¨ï¼Œä¸”è°ƒç”¨æ­¤å‡½æ•°ä¼šä½¿å…¶ä¸èƒ½è¢«join) std::thread::id_get_id è·å–çº¿ç¨‹id thread&amp; operator=(thread &amp;&amp;rhs) ç§»åŠ¨æ„é€ å‡½æ•°(å¦‚æœå¯¹è±¡æ˜¯joinableçš„ï¼Œé‚£ä¹ˆä¼šè°ƒç”¨std::terminate) æ³¨æ„äº‹é¡¹ çº¿ç¨‹æ˜¯åœ¨threadå¯¹è±¡è¢«å®šä¹‰çš„æ—¶å€™å¼€å§‹æ‰§è¡Œçš„ï¼Œè€Œä¸æ˜¯åœ¨è°ƒç”¨joinå‡½æ•°æ—¶æ‰æ‰§è¡Œçš„ï¼Œè°ƒç”¨joinå‡½æ•°åªæ˜¯é˜»å¡ç­‰å¾…çº¿ç¨‹ç»“æŸå¹¶å›æ”¶èµ„æº åˆ†ç¦»çš„çº¿ç¨‹ï¼ˆæ‰§è¡Œè¿‡detachçš„çº¿ç¨‹ï¼‰ä¼šåœ¨è°ƒç”¨å®ƒçš„çº¿ç¨‹ç»“æŸæˆ–è‡ªå·±ç»“æŸæ—¶é‡Šæ”¾èµ„æº çº¿ç¨‹ä¼šåœ¨å‡½æ•°è¿è¡Œåè‡ªåŠ¨é‡Šæ”¾ï¼Œä¸æ¨èåˆ©ç”¨å…¶ä»–æ–¹æ³•å¼ºåˆ¶ç»“æŸçº¿ç¨‹ï¼Œå¯èƒ½ä¼šå› èµ„æºæœªé‡Šæ”¾è€Œå¯¼è‡´å†…å­˜æ³„éœ²ã€‚ æ²¡æœ‰æ‰§è¡Œjoinæˆ–detachçš„çº¿ç¨‹åœ¨ç¨‹åºç»“æŸæ—¶ä¼šå¼•å‘å¼‚å¸¸ std::atomicå’Œstd::mutex ä½œç”¨ï¼šå¤šä¸ªçº¿ç¨‹éœ€è¦æ“ä½œåŒä¸€ä¸ªå˜é‡æ—¶ï¼Œé˜²æ­¢äº§ç”Ÿç«äº‰ä¸å†²çª std::mutex std::mutexæ˜¯C++ä¸­æœ€åŸºæœ¬çš„äº’æ–¥é‡ï¼Œä¸€ä¸ªçº¿ç¨‹å°†mutexé”ä½æ—¶ï¼Œå…¶ä»–çš„çº¿ç¨‹å°±ä¸èƒ½æ“ä½œmutexï¼Œç›´åˆ°è¿™ä¸ªçº¿ç¨‹å°†mutexè§£é”ã€‚ 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;int n = 0;mutex mtx;void count10000() &#123; for (int i = 1; i &lt;= 10000; i++) &#123; mtx.lock(); n++; mtx.unlock(); &#125;&#125;int main() &#123; thread th[100]; for (thread &amp;x : th) x = thread(count10000); for (thread &amp;x : th) x.join(); cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; mutexçš„å¸¸ç”¨æˆå‘˜å‡½æ•° å‡½æ•° ä½œç”¨ void lock() å°†mutexä¸Šé”ã€‚å¦‚æœmutexå·²ç»è¢«å…¶ä»–çº¿ç¨‹ä¸Šé”,é‚£ä¹ˆmutexå·²ç»è¢«åŒä¸€ä¸ªçº¿ç¨‹é”ä½ï¼Œé‚£ä¹ˆä¼šäº§ç”Ÿæ­»é”ã€‚ void unlock() è§£é”mutex,é‡Šæ”¾å…¶æ‰€æœ‰æƒã€‚å¦‚æœæœ‰çº¿ç¨‹å› ä¸ºè°ƒç”¨lock()ä¸èƒ½ä¸Šé”è€Œè¢«é˜»å¡ï¼Œåˆ™è°ƒç”¨æ­¤å‡½æ•°ä¼šå°†mutexçš„ä¸»åŠ¨æƒéšæœºäº¤ç»™å…¶ä¸­ä¸€ä¸ªçº¿ç¨‹;å¦‚æœmutexä¸æ˜¯è¢«æ­¤çº¿ç¨‹ä¸Šé”ï¼Œé‚£ä¹ˆä¼šå¼•å‘æœªå®šä¹‰çš„å¼‚å¸¸ã€‚ bool try_lock() å°è¯•å°†mutexä¸Šé”ã€‚å¦‚æœmutexæœªè¢«ä¸Šé”ï¼Œåˆ™å°†å…¶ä¸Šé”å¹¶è¿”å›true;å¦‚æœmutexå·²è¢«é”åˆ™è¿”å›false. std::atomic ç”±äºæ¯ä¸ªthreadéƒ½è¦å¾ªç¯åœ°åŠ é”ã€è§£é”ï¼Œæˆ‘ä»¬ä½¿ç”¨std::atomicæ¥æé«˜æ•ˆç‡ã€‚ 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;atomic&gt;using namespace std;//atomic&lt;int&gt; n = 0;åŸå­å˜é‡ä¸èƒ½ä½¿ç”¨æ‹·è´æ„é€ atomic&lt;int&gt; n;void count10000() &#123; for (int i = 1; i &lt;= 10000; i++) &#123; n++; &#125;&#125;int main() &#123; thread th[100]; for (thread &amp;x : th) x = thread(count10000); for (thread &amp;x : th) x.join(); cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; åŸå­æ“ä½œ æ˜¯æœ€å°çš„ä¸”ä¸å¯å¹¶è¡ŒåŒ–çš„æ“ä½œã€‚ è¿™å°±æ„å‘³ç€å³ä½¿æ˜¯å¤šçº¿ç¨‹ï¼Œä¹Ÿè¦åƒåŒæ­¥è¿›è¡Œä¸€æ ·åŒæ­¥æ“ä½œatomicå¯¹è±¡ï¼Œä»è€Œçœå»äº†mutexä¸Šé”ã€è§£é”çš„æ—¶é—´æ¶ˆè€—ã€‚ std::async std::future std::promise std::this_thread","categories":[{"name":"cpp","slug":"cpp","permalink":"http://example.com/categories/cpp/"}],"tags":[{"name":"å¤šçº¿ç¨‹","slug":"å¤šçº¿ç¨‹","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"author":"tugumineko"},{"title":"GAMES101ä½œä¸š7 è·¯å¾„è¿½è¸ª(Path Tracing) é—®é¢˜ä¸æ€è·¯è¯¦è§£å…¨è§£","slug":"GAMES101-Assignment7","date":"2024-08-17T09:25:57.000Z","updated":"2024-11-14T04:10:30.605Z","comments":true,"path":"2024/08/17/GAMES101-Assignment7/","permalink":"http://example.com/2024/08/17/GAMES101-Assignment7/","excerpt":"","text":"å‰è¨€ æœ¬æ¬¡ä½œä¸šçš„å†…å®¹æ˜¯å¯¹ä¸Šä¸€æ¬¡ä½œä¸šä¸­çš„BVHéå†ã€å°„çº¿ä¸‰è§’å½¢æ±‚äº¤MÃ¶ller-Trumboreç®—æ³•è¿›è¡Œè¿ç§»ï¼Œä»¥åŠåœ¨æ­¤åŸºç¡€ä¸Šå®ç°å®Œæ•´çš„ Path Tracing ç®—æ³•ã€‚ è¯·æ³¨æ„ï¼š æœ¬æ¬¡ä½œä¸šåŸºäºdalaoçš„GAMES101ä½œä¸šæ¡†æ¶ï¼Œåœ¨Windowsç³»ç»Ÿä¸Šå®ç°ã€‚ å‡½æ•°è¿ç§» Bounds3::IntersectP in Bounds3.hpp æœ¬æ¬¡ä½œä¸šä¸­ cornell box æ¨¡å‹çš„å¢™å£å’Œç®±å­æŸäº›ä¸‰è§’å½¢æ˜¯å¹³è¡Œäºåæ ‡å¹³é¢çš„ï¼Œä¼šå‡ºç°åŒ…å›´ç›’åšåº¦ä¸º0çš„æƒ…å†µï¼Œå› æ­¤æ±‚äº¤è¦åŒ…å«t_enter = t_exit çš„æƒ…å†µã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940// in Bounds3.hppinline bool Bounds3::IntersectP(const Ray&amp; ray, const Vector3f&amp; invDir, const std::array&lt;int, 3&gt;&amp; dirIsNeg) const&#123; // invDir: ray direction(x,y,z), invDir=(1.0/x,1.0/y,1.0/z), use this because Multiply is faster that Division // dirIsNeg: ray direction(x,y,z), dirIsNeg=[int(x&gt;0),int(y&gt;0),int(z&gt;0)], use this to simplify your logic // TODO test if ray bound intersects float min_x = (pMin.x - ray.origin.x) * invDir[0]; float max_x = (pMax.x - ray.origin.x) * invDir[0]; float min_y = (pMin.y - ray.origin.y) * invDir[1]; float max_y = (pMax.y - ray.origin.y) * invDir[1]; float min_z = (pMin.z - ray.origin.z) * invDir[2]; float max_z = (pMax.z - ray.origin.z) * invDir[2]; if (dirIsNeg[0]) &#123; std::swap(min_x, max_x); &#125; if (dirIsNeg[1]) &#123; std::swap(min_y, max_y); &#125; if (dirIsNeg[2]) &#123; std::swap(min_z, max_z); &#125; float t_enter = std::max(min_x, std::max(min_y, min_z)); float t_exit = std::min(max_x, std::min(max_y, max_z)); //åŒ…å›´ç›’åšåº¦ä¸º0æ—¶ï¼Œt_enter = t_exit if (t_enter &lt;= t_exit &amp;&amp; t_exit &gt;= 0) &#123; return true; &#125; else return false;&#125; BVHAccel::getIntersection in BVH.cpp 1234567891011121314151617181920// in BVH.cppIntersection BVHAccel::getIntersection(BVHBuildNode* node, const Ray&amp; ray) const&#123; // TODO Traverse the BVH to find intersection std::array&lt;int, 3Ui64&gt; dirIsNeg = &#123; static_cast&lt;int&gt;(ray.direction.x &lt; 0),static_cast&lt;int&gt;(ray.direction.y &lt; 0),static_cast&lt;int&gt;(ray.direction.z &lt; 0) &#125;;; if (node-&gt;bounds.IntersectP(ray, ray.direction_inv, dirIsNeg) == false) &#123; return Intersection&#123;&#125;; &#125; if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123; return node-&gt;object-&gt;getIntersection(ray); &#125; Intersection hit1 = getIntersection(node-&gt;left, ray); Intersection hit2 = getIntersection(node-&gt;right, ray); return hit1.distance &lt; hit2.distance ? hit1 : hit2;&#125; Triangle::getIntersection in Triangle.hpp 123456789101112131415161718192021222324252627282930313233343536373839404142inline Intersection Triangle::getIntersection(Ray ray)&#123; if (dotProduct(ray.direction, normal) &gt; 0) &#123; return Intersection&#123;&#125;; &#125; Vector3f s = ray.origin - v0; Vector3f s1 = crossProduct(ray.direction, e2); Vector3f s2 = crossProduct(s, e1); float de = dotProduct(s1, e1); if (fabs(denominator) &lt; EPSILON) &#123; return Intersection&#123;&#125;; &#125; float coefficient = 1.0f / denominator; float t = coefficient * dotProduct(s2, e2); float b1 = coefficient * dotProduct(s1, s); float b2 = coefficient * dotProduct(s2, ray.direction); float b0 = 1.0f - b1 - b2; if (t &gt;= 0.0f &amp;&amp; b0 &gt;= 0.0f &amp;&amp; b0 &lt;= 1.0f &amp;&amp; b1 &gt;= 0.0f &amp;&amp; b1 &lt;= 1.0f &amp;&amp; b2 &gt;= 0.0f &amp;&amp; b2 &lt;= 1.0f ) &#123; Intersection inter; inter.distance = t; inter.normal = normal; inter.coords = ray(t); inter.happened = true; inter.m = m; inter.obj = this; return inter; &#125; else return Intersection&#123;&#125;;&#125; Path Tracing æ¸²æŸ“æ–¹ç¨‹ Render Equation: Lo(p,Ï‰0) = Le(p,Ï‰0) + âˆ«Î©+Li(p,Ï‰i)fr(p,wi,w0)(nâ‹…Ï‰i)dwi\\Large _{Lo\\left( p,\\omega _0 \\right) \\ =\\ L_e\\left( p,\\omega _0 \\right) \\ +\\ \\int\\limits_{\\varOmega +}^{}{L_i\\left( p,\\omega _i \\right) f_r\\left( p,w_i,w_0 \\right) \\left( n\\cdot \\omega _i \\right) dw_i}} Lo(p,Ï‰0â€‹) = Leâ€‹(p,Ï‰0â€‹) + Î©+âˆ«â€‹Liâ€‹(p,Ï‰iâ€‹)frâ€‹(p,wiâ€‹,w0â€‹)(nâ‹…Ï‰iâ€‹)dwiâ€‹â€‹ å…¶ä¸­ç¬¬ä¸€é¡¹è¡¨ç¤ºç‰©ä½“æœ¬èº«çš„å‘å‡ºçš„å…‰ç…§å¼ºåº¦ï¼Œç¬¬äºŒé¡¹çš„ç§¯åˆ†æ‰€åŒ…æ‹¬çš„å†…å®¹å°±æ˜¯åå°„å‡½æ•° Reflection Equation,å³ Lo(p,Ï‰0) = âˆ«Î©+Li(p,Ï‰i)fr(p,wi,w0)cosâ¡Î¸idwi\\Large_{Lo\\left( p,\\omega _0 \\right) \\,\\,=\\,\\,\\int\\limits_{\\varOmega +}^{}{L_i\\left( p,\\omega _i \\right) f_r\\left( p,w_i,w_0 \\right) \\cos \\theta _idw_i}} Lo(p,Ï‰0â€‹)=Î©+âˆ«â€‹Liâ€‹(p,Ï‰iâ€‹)frâ€‹(p,wiâ€‹,w0â€‹)cosÎ¸iâ€‹dwiâ€‹â€‹ Lo(p,Ï‰0) =âˆ«ALi(p,Ï‰i)fr(p,wi,w0)cosâ¡Î¸icosâ¡Î¸iâ€²âˆ¥xâ€²âˆ’xâˆ¥2dA(ä»å…‰æºå¤„é‡‡æ ·)\\Large _{Lo\\left( p,\\omega _0 \\right) \\,\\, =\\int\\limits_A^{}{L_i\\left( p,\\omega _i \\right) f_r\\left( p,w_i,w_0 \\right) \\frac{\\cos \\theta _i\\cos \\theta _{i}^{\\prime}}{\\lVert x^{\\prime}-x \\rVert ^2}dA\\left( \\text{ä»å…‰æºå¤„é‡‡æ ·} \\right)}} Lo(p,Ï‰0â€‹)=Aâˆ«â€‹Liâ€‹(p,Ï‰iâ€‹)frâ€‹(p,wiâ€‹,w0â€‹)âˆ¥xâ€²âˆ’xâˆ¥2cosÎ¸iâ€‹cosÎ¸iâ€²â€‹â€‹dA(ä»å…‰æºå¤„é‡‡æ ·)â€‹ å…¶ä¸­ç¬¬ä¸€é¡¹æ˜¯å…¥å°„æ–¹å‘çš„Radianceï¼Œä»£è¡¨ä»å•ä½ç«‹ä½“è§’å…¥å°„åˆ°å•ä½é¢ç§¯ä¸Šçš„å…‰ç…§å¼ºåº¦ã€‚ç¬¬äºŒé¡¹å°±æ˜¯åŒå‘åå°„åˆ†å¸ƒå‡½æ•°BRDF(Bidirectional Reflectance Distribution Function) (åªä¸æè´¨æœ‰å…³ BRDF=MaterialBRDF = MaterialBRDF=Material ) ï¼Œä»–è¡¨ç¤ºä»¥ä¸‹æ¯”å€¼ï¼š fr(Ï‰iâ†’Ï‰r)=dLr(Ï‰r)dEi(Ï‰i)=dLr(Ï‰r)Li(Ï‰i)cosâ¡Î¸idÏ‰i[1sr]f_r\\left( \\omega _i\\rightarrow \\omega _r \\right) =\\frac{dL_r\\left( \\omega _r \\right)}{dE_i\\left( \\omega _i \\right)}=\\frac{dL_r\\left( \\omega _r \\right)}{L_i\\left( \\omega _i \\right) \\cos \\theta _id\\omega _i}\\left[ \\frac{1}{sr} \\right] frâ€‹(Ï‰iâ€‹â†’Ï‰râ€‹)=dEiâ€‹(Ï‰iâ€‹)dLrâ€‹(Ï‰râ€‹)â€‹=Liâ€‹(Ï‰iâ€‹)cosÎ¸iâ€‹dÏ‰iâ€‹dLrâ€‹(Ï‰râ€‹)â€‹[sr1â€‹] è’™ç‰¹å¡æ´›ç§¯åˆ† Monte Carlo Intergration: âˆ«f(x)dx=âˆ«f(x)p(x)p(x)dx=E(f(x))p(x)=1Nâˆ‘i=1Nf(xi)p(xi)(å¤§æ•°å®šå¾‹) \\begin{aligned} \\int{f\\left( x \\right) dx=\\int{\\frac{f\\left( x \\right)}{p\\left( x \\right)}p\\left( x \\right) dx}} =\\frac{E\\left( f\\left( x \\right) \\right)}{p\\left( x \\right)} =\\frac{1}{N}\\sum_{i=1}^N{\\frac{f\\left( x_i \\right)}{p\\left( x_i \\right)}\\left( \\text{å¤§æ•°å®šå¾‹} \\right)}\\text{ } \\end{aligned} âˆ«f(x)dx=âˆ«p(x)f(x)â€‹p(x)dx=p(x)E(f(x))â€‹=N1â€‹i=1âˆ‘Nâ€‹p(xiâ€‹)f(xiâ€‹)â€‹(å¤§æ•°å®šå¾‹) â€‹ é‡‡æ ·è¶Šå¤šï¼Œæ–¹å·®è¶Šå° åœ¨è¿™é‡Œçš„è·¯å¾„è¿½è¸ªä¸­ï¼Œæˆ‘ä»¬æ ¹æ®æ¸²æŸ“æ–¹ç¨‹ç€è‰²ã€åˆ©ç”¨è’™ç‰¹å¡æ´›ä¼°è®¡ç¦»æ•£åŒ–ã€ ä¿„ç½—æ–¯è½®ç›˜èµŒæ§åˆ¶æ·±åº¦ã€ é‡å¤å•æ¬¡é‡‡æ ·æ¥é™ä½æ–¹å·®å’Œå‡å°‘è®¡ç®—é‡ã€ ä»å…‰æºå¤„é‡‡æ ·æ¥æé«˜æ•ˆç‡ã€‚ ç®€è¦åœ°è¯´ï¼Œå°±æ˜¯æ ¹æ®å…‰è·¯å¯é€†åŸç†ï¼Œä»è§†çº¿(viewpoint)å‘å‡ºä¸€æ¡å…‰çº¿åˆ°ç‰©ä½“ï¼Œå†â‘ ä»å…‰æºå¤„é‡‡æ ·ï¼Œå†è¿½è¸ªè¿™ä¸ªæ–¹å‘åˆ°ç‰©ä½“çš„å…‰çº¿ï¼Œå¦‚æœæ²¡æœ‰é®æŒ¡å°±è®¡ç®—ç›´æ¥å…‰ç…§ï¼›â‘¡æ ¹æ®æè´¨ç”Ÿæˆä¸€æ¡ä»»æ„çš„wiï¼Œæœ‰ç‰©ä½“ç›¸äº¤å°±æ˜¯é—´æ¥å…‰ç…§ï¼Œé€’å½’è®¡ç®—å³å¯ï¼Œæ— ç›¸äº¤ç‰©ä½“æˆ–åˆ°è¾¾å…‰æºæ—¶åœæ­¢ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// in Scene.cppVector3f Scene::castRay(const Ray&amp; ray, int depth) const&#123; // TO DO Implement Path Tracing Algorithm here //ä»è§†çº¿å‘å‡ºå…‰çº¿ Intersection inter = intersect(ray); //æ²¡æœ‰ç›¸äº¤åˆ™ä¸éœ€è¦ç€è‰² if(!inter.happened) &#123; return Vector3f&#123; 0.0f, 0.0f, 0.0f &#125;; &#125; //ç›´æ¥è¿”å›å…‰æº if (inter.m-&gt;hasEmission()) &#123; if (depth == 0) &#123; return inter.m-&gt;getEmission(); &#125; else return Vector3f&#123; 0.0f, 0.0f, 0.0f &#125;; &#125; Vector3f view_dir = ray.direction; Vector3f normal = inter.normal.normalized(); Vector3f position = inter.coords; //ç›´æ¥å…‰ç…§å’Œé—´æ¥å…‰ç…§ Vector3f L_dir = &#123; 0.0f,0.0f,0.0f &#125;, L_indir = &#123;0.0f, 0.0f, 0.0f&#125;; //1. ç›´æ¥å…‰ç…§ Intersection inter_light; float pdf_light; //ä»å…‰æºå¤„é‡‡æ · sampleLight(inter_light, pdf_light); Vector3f normal_light = normalize(inter_light.normal);// NN Vector3f position_light = inter_light.coords;// x Vector3f light_dir = (position - position_light).normalized();// ws float distanceToLight = (position-position_light).norm(); float distanceToLight2 = dotProduct(position - position_light, position - position_light);// |x - x&#x27;|^2 Ray lightToObj(position_light, light_dir);// Ray(ori,dir) Intersection inter_lightToObj = intersect(lightToObj); float distanceToObj = inter_lightToObj.distance; //åˆ©ç”¨æ·±åº¦åˆ¤æ–­æ˜¯å¦ç›¸äº¤ //ä¸èƒ½ç”¨Intersection.happened, å› ä¸ºä¸€å®šä¼šå’Œç‰©ä½“ç›¸äº¤ if(inter_lightToObj.happened &amp;&amp; distanceToObj - distanceToLight &gt; -EPSILON) &#123; Vector3f f_r = inter.m-&gt;eval(view_dir, -light_dir, normal); float cos_theta = dotProduct(-light_dir, normal);// ç‰©ä½“å¤¹è§’ float cos_theta_l = dotProduct(light_dir, normal_light); //å…‰æºå¤¹è§’ L_dir = inter_light.emit*f_r * cos_theta * cos_theta_l / (pdf_light * distanceToLight2); &#125; //2. é—´æ¥å…‰ç…§ float ksi = get_random_float(); if(ksi &lt; RussianRoulette) &#123; //æ ¹æ®æè´¨éšæœºé‡‡æ ·ä¸€ä¸ªwiæ–¹å‘ Vector3f obj_dir = inter.m-&gt;sample(view_dir, normal); Ray ObjToScene(position, obj_dir); Intersection inter_ObjToScene = intersect(ObjToScene); if (inter_ObjToScene.happened &amp;&amp; !inter_ObjToScene.m-&gt;hasEmission()) &#123; Vector3f f_r = inter.m-&gt;eval(view_dir, obj_dir, normal); float cos_theta = dotProduct(obj_dir, normal); float pdf_hemi = inter.m-&gt;pdf(view_dir, obj_dir, normal); if (pdf_hemi &gt; EPSILON) &#123;//å‡å°‘ç™½è‰²å™ªç‚¹ L_indir = f_r * castRay(ObjToScene, depth + 1) * cos_theta / (pdf_hemi * RussianRoulette); &#125; &#125; &#125; return L_dir + L_indir;&#125; å¤šçº¿ç¨‹ åœ¨è¿™é‡Œè¿ç”¨C++11ä¸­çš„threadå¯ä»¥è½»æ¾åœ°åˆ†åƒç´ è¿›è¡Œå¹¶è¡Œæ¸²æŸ“ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940// change the spp value to change sample ammountint spp = 256; // default:16std::cout &lt;&lt; &quot;SPP: &quot; &lt;&lt; spp &lt;&lt; &quot;\\n&quot;;const int thread_cnt = 8;int finished_thread = 0;int finished_width = 0;std::mutex mtx;printf(&quot;%d %d\\n&quot;, scene.height, scene.width);auto multiThreadCastRay = [&amp;](uint32_t y_min, uint32_t y_max)&#123; printf(&quot;start %d %d\\n&quot;, y_min, y_max); for (uint32_t j = y_min; j &lt;= y_max; ++j) &#123; for (uint32_t i = 0; i &lt; scene.width; ++i) &#123; // generate primary ray direction float x = (2 * (i + 0.5) / (float)scene.width - 1) * imageAspectRatio * scale; float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale; Vector3f dir = normalize(Vector3f(-x, y, 1)); for (int k = 0; k &lt; spp; k++) &#123; framebuffer[scene.width * j + i] += scene.castRay(Ray(eye_pos, dir), 0) / spp; &#125; &#125; //printf(&quot;%d\\n&quot;, j); //UpdateProgress(j / (float)scene.height); mtx.lock(); UpdateProgress(++finished_width * 1.0 / scene.width); mtx.unlock(); &#125; printf(&quot;ok %d %d\\n&quot;, y_min, y_max);&#125;;int block = scene.height / thread_cnt + (scene.height % thread_cnt != 0);std::thread th[thread_cnt];for (int i = 0; i &lt; thread_cnt; i++) &#123; th[i] = std::thread(multiThreadCastRay, i * block, std::min((i + 1) * block - 1, scene.height));&#125;for (int i = 0; i &lt; thread_cnt; i++) th[i].join();UpdateProgress(1.0); åŠ é€ŸåŠä¼˜åŒ– å°†Debugæ›´æ¢ä¸ºRelease Debug æ˜¯è°ƒè¯•ç‰ˆæœ¬ï¼ŒåŒ…å«è°ƒè¯•ä¿¡æ¯ï¼Œä¸ä¼˜åŒ–ä»£ç ï¼Œä¾¿äºç¨‹åºå‘˜è°ƒè¯•ï¼› Release æ˜¯å‘å¸ƒç‰ˆæœ¬ï¼Œä¸åŒ…å«è°ƒè¯•ä¿¡æ¯ï¼Œå¯¹ä»£ç è¿›è¡Œä¼˜åŒ–ï¼Œä¾¿äºç”¨æˆ·ä½¿ç”¨ã€‚ åœ¨å›¾å½¢å­¦ä¸­ï¼Œå¸¸å¸¸éœ€è¦è¿›è¡Œå¤§é‡çš„è®¡ç®—å’Œåƒç´ çš„å¤„ç†ã€‚æ›´æ¢ä¸ºReleaseå¯ä»¥å¤§å¹…æé«˜ç¼–è¯‘æ•ˆç‡ï¼Œè¿›è¡Œæ›´åŠ é¡ºåˆ©çš„æµ‹è¯•ã€‚ get_random_float() in global.hpp global.hppä¸‹çš„get_random_float()éšæœºæ•°ç”Ÿæˆå‡½æ•°å­˜åœ¨é—®é¢˜ï¼Œå®ƒä¼šå¯¼è‡´åœ¨é‡å¤è°ƒç”¨è¯¥å‡½æ•°æ—¶ï¼Œè¿”å›åŒä¸€ä¸ªå€¼ã€‚ 123456789// in global.hppstatic std::random_device dev;static std::mt19937 rng(dev());static std::uniform_real_distribution&lt;float&gt; dist(0.f, 1.f); // distribution in range [1, 6]inline float get_random_float()&#123; return dist(rng);&#125; ç™½è‰²å™ªç‚¹ åŸå› åº”è¯¥æ˜¯pdfæ¥è¿‘äº0æ—¶ï¼Œé™¤ä»¥å®ƒè®¡ç®—å¾—åˆ°çš„é¢œè‰²ä¼šåå‘æé™å€¼ï¼Œä½“ç°åœ¨å›¾ä¸Šä¹Ÿå°±æ˜¯ç™½è‰² è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¯¹äºpdfæ¥è¿‘äº0çš„æƒ…å†µç›´æ¥å°†å®ƒçš„radienceç®—ä½œ0å°±è¡Œï¼š Microfacetå¾®å¹³é¢ç†è®º è¿™éƒ¨åˆ†å†…å®¹å¯ä»¥å‚è€ƒLearnOpenGL BRDF = Material fr=kdflambert+ksfcookâˆ’torrance\\large f_r=k_df_{lambert}+k_sf_{cook-torrance} frâ€‹=kdâ€‹flambertâ€‹+ksâ€‹fcookâˆ’torranceâ€‹ å…¶ä¸­ï¼š kdkdkdæ˜¯å…¥å°„å…‰çº¿ä¸­è¢«æŠ˜å°„éƒ¨åˆ†çš„èƒ½é‡å æ¯”ï¼Œksksksæ˜¯è¢«åå°„éƒ¨åˆ†çš„èƒ½é‡å æ¯”ï¼Œå³è²æ¶…å°”é¡¹ã€‚æ ¹æ®èƒ½é‡å®ˆæ’å®šå¾‹ï¼Œkd+ks=1kd+ks=1kd+ks=1. flambertf_{lambert}flambertâ€‹æ˜¯Lambertianæ¼«åå°„ï¼ˆç†æƒ³æ•£å°„-éƒä¼¯æ•£å°„ï¼‰BRDFéƒ¨åˆ†ï¼Œfcookâˆ’torrancef_{cook-torrance}fcookâˆ’torranceâ€‹æ˜¯é•œé¢éƒ¨åˆ†BRDFéƒ¨åˆ†ã€‚ Lambertianæ¼«åå°„ å‡è®¾ç‰©ä½“ä¸å¸æ”¶èƒ½é‡ï¼Œç”±èƒ½é‡å®ˆæ’å¾—åˆ°irradianceå…¥å°„å’Œå‡ºå°„ä¸€å®šæ˜¯ä¸€æ ·çš„ï¼ˆLi=LoL_{i}=L_{o}Liâ€‹=Loâ€‹ï¼‰,å› æ­¤å¾—åˆ°fr=1Ï€f_r=\\frac{1}{\\pi}frâ€‹=Ï€1â€‹;è€ƒè™‘åˆ°ç‰©ä½“å¸æ”¶èƒ½é‡çš„æŸå¤±åï¼Œæœ‰ï¼š flambert=ÏÏ€\\large f_{lambert}=\\frac{\\rho}{\\pi} flambertâ€‹=Ï€Ïâ€‹ å…¶ä¸­Ï{\\rho}Ïä¸ºåå°„ç‡æˆ–rgbå…‰è°± Cook-Torrance BRDF f(l,v)=D(h)F(v,h)G(l,v,h)4(nâ‹…l)(nâ‹…v)\\large f\\left( l,v \\right) =\\frac{D\\left( h \\right) F\\left( v,h \\right) G\\left( l,v,h \\right)}{4\\left( n\\cdot l \\right) \\left( n\\cdot v \\right)} f(l,v)=4(nâ‹…l)(nâ‹…v)D(h)F(v,h)G(l,v,h)â€‹ å…¶ä¸­: å…‰ç…§æ–¹å‘L,è§‚å¯Ÿæ–¹å‘V, å¾®è§‚æ³•çº¿/ä¸­é—´å‘é‡H,å®è§‚å‘é‡N D(h):æ³•çº¿åˆ†å¸ƒå‡½æ•°(Normal Distribution Function),æè¿°å¾®é¢å…ƒæ³•çº¿åˆ†å¸ƒçš„æ¦‚ç‡ï¼Œå³æ­£ç¡®æœå‘çš„æ³•çº¿çš„æµ“åº¦ã€‚å³å…·æœ‰æ­£ç¡®æœå‘ï¼Œèƒ½å¤Ÿå°†æ¥è‡ªlçš„å…‰åå°„åˆ°vçš„è¡¨é¢ç‚¹çš„ç›¸å¯¹äºè¡¨é¢é¢ç§¯çš„æµ“åº¦ã€‚ F(v,h):è²æ¶…å°”æ–¹ç¨‹(Fresnel Equation),æè¿°ä¸åŒçš„è¡¨é¢è§’ä¸‹è¡¨é¢æ‰€å‘å°„çš„å…‰çº¿æ‰€å çš„æ¯”ç‡ã€‚ G(l,v,h):å‡ ä½•å‡½æ•°(Geometry Function),æè¿°å¾®å¹³é¢è‡ªæˆé˜´å½±çš„å±æ€§ï¼Œå³m=hçš„æœªè¢«é®è”½çš„è¡¨é¢ç‚¹çš„ç™¾åˆ†æ¯”ã€‚ 4(n*l)(n*v):æ ¡æ­£å› å­(Correctionfactor),ä½œä¸ºå¾®è§‚å‡ ä½•çš„å±€éƒ¨ç©ºé—´å’Œæ•´ä¸ªå®è§‚è¡¨é¢çš„å±€éƒ¨ç©ºé—´ä¹‹é—´å˜æ¢çš„å¾®å¹³é¢é‡çš„æ ¡æ­£ã€‚ ä¸€èˆ¬æˆ‘ä»¬ç”¨å®è§‚è¡¨é¢çš„åŠçŸ¢é‡hæ¥è¡¨ç¤ºå¾®è§‚è¡¨é¢æ³•çº¿mï¼Œå› ä¸ºä»…m = hçš„è¡¨é¢ç‚¹çš„æœå‘æ‰ä¼šå°†å…‰çº¿låå°„åˆ°è§†çº¿vçš„æ–¹å‘ï¼Œå…¶ä»–æœå‘çš„è¡¨é¢ç‚¹å¯¹BRDFæ²¡æœ‰è´¡çŒ®ï¼ˆæ­£è´Ÿç›¸äº’æŠµæ¶ˆï¼‰ã€‚ å¾®è¡¨é¢æ¨¡å‹éœ€è¦ç”¨åˆ°çš„å‚æ•°ï¼š VVV:å…‰çº¿çš„åå°„æ–¹å‘(å•ä½å‘é‡) III:å…‰çº¿çš„å…¥å°„æ–¹å‘çš„åæ–¹å‘(å•ä½å‘é‡) m=hm=hm=h:VVVå’ŒIIIçš„ä¸­é—´å‘é‡(å•ä½å‘é‡) NNN:ä¸ºå®è§‚å¹³é¢æ³•çº¿(å•ä½å‘é‡) Î±{\\alpha}Î±:ä¸ºç²—ç³™åº¦âˆˆ[0,1] D(h):æ³•çº¿åˆ†å¸ƒå‡½æ•°(Normal Distribution Function) å„é¡¹åŒæ€§NDF GGX(Trowbridge-Reitz)åˆ†å¸ƒ GGXTå‘å…‰çš„å°¾éƒ¨è¾ƒé•¿ï¼Œä¸”å…·å¤‡å½¢çŠ¶ä¸å˜æ€§ã€‚ Î±=Roughness2\\alpha =Roughness^2 Î±=Roughness2 DGGX(m)=Î±2Ï€((nâ‹…m)2(Î±2âˆ’1)+1)2D_{GGX}\\left( \\mathbf{m} \\right) =\\frac{\\alpha ^2}{\\pi \\left( \\left( \\mathbf{n}\\cdot \\mathbf{m} \\right) ^2\\left( \\alpha ^2-1 \\right) +1 \\right) ^2} DGGXâ€‹(m)=Ï€((nâ‹…m)2(Î±2âˆ’1)+1)2Î±2â€‹ 123456789101112Vector3f D_GGXT(Vector3f N,Vector3f H,float rough)&#123; float a = rough * rough; float a2 = a * a; float NdotH = std::max(dotProduct(N, H), 0.0f); float NdotH2 = NdotH * NdotH; float denom = (NdotH2 * (a2 - 1.0f) + 1.0f); denom = denom * denom; return a2 * MY_INV_PI * std::max(denom,0.0000001f);&#125; å„é¡¹å¼‚æ€§NDF åˆ›å»ºå„å‘å¼‚æ€§NDFçš„å¸¸ç”¨æ–¹æ³•æ˜¯åŸºäºç°æœ‰å„å‘åŒæ€§NDFè¿›è¡Œæ¨å¯¼ã€‚è€Œæ¨å¯¼æ‰€ä½¿ç”¨çš„æ–¹æ³•æ˜¯é€šç”¨çš„ï¼Œå¯ä»¥åº”ç”¨äºä»»ä½•å½¢çŠ¶ä¸å˜çš„å„å‘åŒæ€§NDFï¼Œè¿™ä¾¿æ˜¯GGXç­‰å½¢çŠ¶ä¸å˜çš„NDFèƒ½æ›´åŠ æ™®åŠçš„å¦ä¸€ä¸ªåŸå› ã€‚ Anisotropic GGXåˆ†å¸ƒ DGGXaniso(m)=1Ï€Î±xÎ±y1((tâ‹…m)Î±x2+(bâ‹…m)Î±y2+(nâ‹…m)2)2D_{GGXaniso}\\left( \\mathbf{m} \\right) =\\frac{1}{\\pi \\alpha _x\\alpha _y}\\frac{1}{\\left( \\frac{\\left( \\mathbf{t}\\cdot \\mathbf{m} \\right)}{\\alpha _{x}^{2}}+\\frac{\\left( \\mathbf{b}\\cdot \\mathbf{m} \\right)}{\\alpha _{y}^{2}}+\\left( \\mathbf{n}\\cdot \\mathbf{m} \\right) ^2 \\right) ^2} DGGXanisoâ€‹(m)=Ï€Î±xâ€‹Î±yâ€‹1â€‹(Î±x2â€‹(tâ‹…m)â€‹+Î±y2â€‹(bâ‹…m)â€‹+(nâ‹…m)2)21â€‹ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå°†æ³•çº¿è´´å›¾ä¸å„å‘å¼‚æ€§BRDFç»„åˆæ—¶ï¼Œé‡è¦çš„æ˜¯è¦ç¡®ä¿æ³•çº¿è´´å›¾æ‰°åŠ¨ï¼ˆperturbsï¼‰åˆ‡çº¿å’Œå‰¯åˆ‡çº¿çŸ¢é‡ä»¥åŠæ³•çº¿ã€‚ F(v,h):è²æ¶…å°”æ–¹ç¨‹(Fresnel Equation) vvvæ˜¯å‡ºå°„å‘é‡ï¼Œhæ˜¯ä¸­é—´å‘é‡ Schlick Fresnelè¿‘ä¼¼ FSchlick(v,h)=F0+(1âˆ’F0)(1âˆ’(vâ‹…h))5F_{Schlick}\\left( \\mathbf{v,h} \\right) =F_0+\\left( 1-F_0 \\right) \\left( 1-\\left( v\\cdot h \\right) \\right) ^5 FSchlickâ€‹(v,h)=F0â€‹+(1âˆ’F0â€‹)(1âˆ’(vâ‹…h))5 12345float F_Schlick(Vector3f V, Vector3f H,Vector3f F0)&#123; float cos_theta = std::max(dotProduct(V, H), 0.0f); return F0 + (1.0f - F0) * std::pow((1 - cos_theta), 5);&#125; G(l,v,h):å‡ ä½•å‡½æ•°(Geometry Function) é€šå¸¸ï¼Œé™¤äº†è¿‘æ å°„è§’æˆ–éå¸¸ç²—ç³™çš„è¡¨é¢ï¼Œå‡ ä½•å‡½æ•°å¯¹BRDFçš„å½¢çŠ¶å½±å“ç›¸å¯¹è¾ƒå°ï¼Œä½†å¯¹äºBRDFä¿æŒèƒ½é‡å®ˆæ’è€Œè¨€ï¼Œå‡ ä½•å‡½æ•°è‡³å…³é‡è¦ã€‚ åœ¨éƒ¨åˆ†æ¸¸æˆå¼•æ“å’Œæ–‡çŒ®ä¸­ï¼Œå‡ ä½•å‡½æ•°G(l,v,h)å’Œåˆ†æ¯ä¸­çš„æ ¡æ­£å› å­4ï¼ˆnÂ·lï¼‰ï¼ˆnÂ·vï¼‰ä¼šåˆå¹¶ä¸ºå¯è§æ€§é¡¹ï¼ˆThe Visibility Termï¼‰ï¼ŒVisé¡¹ï¼Œç®€ç§°Vé¡¹ã€‚å…¶ä¹Ÿç»å¸¸ä½œä¸ºå‡ ä½•å‡½æ•°çš„ä»£æŒ‡ï¼š å‡ ä½•å‡½æ•°ä¸æ³•çº¿åˆ†å¸ƒå‡½æ•°ä½œä¸ºMicrofacet Specular BRDFä¸­çš„é‡è¦ä¸¤é¡¹ï¼Œä¸¤è€…ä¹‹é—´å…·æœ‰ç´§å¯†çš„è”ç³» V(v,l)=G(l,v,h)4(nâ‹…l)(nâ‹…v)\\large V\\left( \\mathbf{v,l} \\right) =\\frac{G\\left( \\mathbf{l,v,h} \\right)}{4\\left( \\mathbf{n}\\cdot \\mathbf{l} \\right) \\left( \\mathbf{n}\\cdot \\mathbf{v} \\right)} V(v,l)=4(nâ‹…l)(nâ‹…v)G(l,v,h)â€‹ å‡ ä½•å‡½æ•°å…·æœ‰ä¸¤ç§ä¸»è¦å½¢å¼ï¼šG1å’ŒG2ï¼Œå…¶ä¸­ï¼š G1ä¸ºå¾®å¹³é¢åœ¨å•ä¸ªæ–¹å‘ï¼ˆå…‰ç…§æ–¹å‘Læˆ–è§‚å¯Ÿæ–¹å‘Vï¼‰ä¸Šå¯è§æ¯”ä¾‹ï¼Œä¸€èˆ¬ä»£è¡¨é®è”½å‡½æ•°ï¼ˆmasking functionï¼‰æˆ–é˜´å½±å‡½æ•°ï¼ˆshadowing functionï¼‰ G2ä¸ºå¾®å¹³é¢åœ¨å…‰ç…§æ–¹å‘Lå’Œè§‚å¯Ÿæ–¹å‘Vä¸¤ä¸ªæ–¹å‘ä¸Šå¯è§æ¯”ä¾‹ï¼Œä¸€èˆ¬ä»£è¡¨è”åˆé®è”½é˜´å½±å‡½æ•°ï¼ˆjoint masking-shadowing functionï¼‰ åœ¨å®è·µä¸­ï¼ŒG2ç”±G1æ¨å¯¼è€Œæ¥ é»˜è®¤æƒ…å†µä¸‹ï¼Œmicrofacet BRDFä¸­ä½¿ç”¨çš„å‡ ä½•å‡½æ•°ä»£æŒ‡G2 G2(l,v)4âˆ£nâ‹…lâˆ£âˆ£nâ‹…vâˆ£â‰ˆ0.5lerp(2âˆ£nâ‹…lâˆ£âˆ£nâ‹…vâˆ£,âˆ£nâ‹…lâˆ£+âˆ£nâ‹…vâˆ£,Î±)\\frac{G_2\\left( \\mathbf{l,v} \\right)}{4\\left| \\mathbf{n}\\cdot \\left. \\mathbf{l} \\right|\\left| \\left. \\mathbf{n}\\cdot \\mathbf{v} \\right| \\right. \\right.}\\approx \\frac{0.5}{lerp\\left( 2\\left| \\left. \\mathbf{n}\\cdot \\mathbf{l} \\right|\\left| \\right. \\left. \\mathbf{n}\\cdot \\mathbf{v} \\right|,\\left| \\left. \\mathbf{n}\\cdot \\mathbf{l} \\right|+\\left| \\left. \\mathbf{n}\\cdot \\mathbf{v} \\right|,\\alpha \\right. \\right. \\right. \\right)} 4âˆ£nâ‹…lâˆ£âˆ£nâ‹…vâˆ£G2â€‹(l,v)â€‹â‰ˆlerp(2âˆ£nâ‹…lâˆ£âˆ£nâ‹…vâˆ£,âˆ£nâ‹…lâˆ£+âˆ£nâ‹…vâˆ£,Î±)0.5â€‹ 123456789101112//G_SchlicksmithGGX_Visibilityfloat Visibility(Vector3f V,Vector3f L,Vector3f N, float rough)&#123; float NdotV = std::max(dotProduct(N, V), 0.0f); float NdotL = std::max(dotProduct(N, L), 0.0f); float f = rough + 1.0; float k = f * f * 0.125; float ggxV = 1.0 / (NdotV * (1.0 - k) + k); float ggxL = 1.0 / (NdotL * (1.0 - k) + k); return ggxV * ggxL * 0.25;&#125; è®¡ç®—è¯¯å·®å¯¼è‡´çš„äº¤ç‚¹åç¦»é—®é¢˜ åœ¨Intersection getIntersection(Ray ray)å‡½æ•°ä¸­ä¿®æ”¹åœ†çš„ç›¸äº¤åˆ¤å®šï¼Œå› ä¸ºåœ†çš„ç›¸äº¤åˆ¤å®šç²¾åº¦ä¸å¤Ÿã€‚ è‹¥ä¸ä¿®æ”¹ï¼Œç¨‹åºåœ¨è¿è¡Œä¸­ä¼šæŠ¥é”™ï¼Œå› ä¸ºå½“ t0 = 0 æ—¶ï¼Œæœ‰å¯èƒ½ä¼šé€ æˆé™¤0é”™è¯¯ã€‚ 1234567891011121314151617181920212223// in sphere.hppIntersection getIntersection(Ray ray) &#123; Intersection result; result.happened = false; Vector3f L = ray.origin - center; float a = dotProduct(ray.direction, ray.direction); float b = 2 * dotProduct(ray.direction, L); float c = dotProduct(L, L) - radius2; float t0, t1; if (!solveQuadratic(a, b, c, t0, t1)) return result; if (t0 &lt; 0) t0 = t1; if (t0 &lt; 0) return result; if (t0 &gt; 0.5) &#123;//ç²¾åº¦ä¸å¤Ÿ result.happened = true; result.coords = Vector3f(ray.origin + ray.direction * t0); result.normal = normalize(Vector3f(result.coords - center)); result.m = this-&gt;m; result.obj = this; result.distance = t0; &#125; return result;&#125; æ€»ç»“ï¼š è¿™ä¸ªä½œä¸šè¿˜æ˜¯éå¸¸æœ‰è¶£çš„ï¼Œè®©æˆ‘æ­¥å…¥äº†PBRçš„å¤§é—¨ã€‚ä½†æ˜¯è¿˜æœ‰å®Œç¾é•œé¢åå°„æ²¡æœ‰å®Œæˆï¼Œçœ‹èµ·æ¥å’Œè²æ¶…å°”é¡¹ã€é‡è¦æ€§é‡‡æ ·æœ‰å…³ç³»ï¼Œä»¥åŠä¼½é©¬æ ¡æ­£ç­‰è§†è§‰æ•ˆæœå¯ä»¥å®ç°ï¼Œè¿™ä¸ªä»¥åå†è¯´å§ã€‚ å‚è€ƒèµ„æ–™ï¼š GAMES101ä½œä¸š7-è·¯å¾„è¿½è¸ªå®ç°è¿‡ç¨‹&amp;ä»£ç æ¡†æ¶è¶…å…¨è§£è¯» å›¾å½¢å­¦å…¥é—¨ç¬”è®°3:Path Tracing-Games101ä½œä¸š7 Games101 ä½œä¸š7 ç»•å‘å¼•è·¯ (Windows) ã€GAMES101ã€‘ä½œä¸š7 å¸¸è§é—®é¢˜é¿å‘","categories":[{"name":"CG","slug":"CG","permalink":"http://example.com/categories/CG/"}],"tags":[{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¸²æŸ“","slug":"æ¸²æŸ“","permalink":"http://example.com/tags/%E6%B8%B2%E6%9F%93/"}],"author":"tugumineko"},{"title":"å›¾ç‰‡çš„æ ¼å¼ä¸ç§ç±»","slug":"picture-format","date":"2024-06-30T04:40:40.000Z","updated":"2024-06-30T08:17:04.136Z","comments":true,"path":"2024/06/30/picture-format/","permalink":"http://example.com/2024/06/30/picture-format/","excerpt":"","text":"ç§ç±» åƒç´ å›¾ ä¹Ÿå«ä½å›¾ï¼Œæ˜¯ç”¨åƒç´ ç‚¹é˜µåˆ—æ‹¼åˆçš„å›¾åƒã€‚ é€šè¿‡æ•æ‰å¾—åˆ°çš„å›¾åƒï¼ˆå¦‚æ‹æ‘„ã€æˆªå›¾ï¼‰éƒ½æ˜¯åƒç´ å›¾ã€‚ åƒç´ å›¾åœ¨æ”¾å¤§ä¸€å®šç¨‹åº¦åéƒ½ä¼šå‡ºç°æ¨¡ç³Šã€‚ å¸¸è§çš„åƒç´ å›¾æ ¼å¼åŒ…æ‹¬ï¼šJPEGã€PSDã€PNGã€TIFF çŸ¢é‡å›¾ æ˜¯ä½¿ç”¨ç‚¹çº¿é¢æ„æˆçš„å›¾åƒã€‚ çŸ¢é‡å›¾å¾€å¾€æ˜¯ä½¿ç”¨çŸ¢é‡è½¯ä»¶ç»˜åˆ¶å¾—åˆ°çš„ã€‚ ç‚¹çº¿é¢éƒ½æ˜¯æ•°å­¦åŒ–çš„ï¼Œå› æ­¤æ”¾å¤§åä¸ä¼šæ¨¡ç³Šã€‚ å¸¸è§çš„çŸ¢é‡å›¾æ ¼å¼åŒ…æ‹¬ï¼šAIã€EPSã€SVG æ ¼å¼ JPEG(JPG) Joint Photographic Experts Group ç”¨é€”ï¼šç›¸æœºæ‹æ‘„ç…§ç‰‡ã€ç½‘ç»œå›¾ç‰‡ç­‰ã€‚ç»å¸¸è¢«ç”¨ä½œå›¾ç‰‡å¤„ç†çš„æœ€ç»ˆè¾“å‡ºæ ¼å¼ã€‚ ä¼˜åŠ¿ï¼šç”¨é€”å¹¿æ³›ï¼Œå—åˆ°å‡ ä¹æ‰€æœ‰å¹³å°å’Œç³»ç»Ÿçš„æ”¯æŒã€‚æ”¯æŒåº”ç”¨ä¸åŒçº§åˆ«çš„å‹ç¼©ã€‚å‹ç¼©åçš„æ–‡ä»¶å°ºå¯¸è¾ƒå°ï¼Œé€‚åˆæºå¸¦å’Œå‘é€ã€‚ åŠ£åŠ¿ï¼šæœ‰æŸå‹ç¼©ï¼ˆ24ä½è¾“å…¥RGBï¼‰ã€‚ä¸æ”¯æŒå›¾å±‚ã€‚ä¸æ”¯æŒé€æ˜åº¦ã€‚ JPEGå¯ä»¥åœ¨è‰²è°ƒåŠé¢œè‰²å¹³æ»‘å˜åŒ–çš„ç…§ç‰‡æˆ–æ˜¯å†™å®ç»˜ç”»(painting)ä¸Šè¾¾åˆ°å®ƒçš„æœ€ä½³æ•ˆæœã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒé€šå¸¸æ¯”å®Œå…¨æ— æŸæ–¹æ³•åšå¾—æ›´å¥½ï¼Œä»ç„¶å¯ä»¥äº§ç”Ÿéå¸¸å¥½çœ‹çš„å½±åƒ ï¼ˆäº‹å®ä¸Šå®ƒä¼šæ¯”å…¶ä»–ä¸€èˆ¬çš„æ–¹æ³•åƒæ˜¯GIFäº§ç”Ÿæ›´é«˜çš„å½±åƒï¼Œå› ä¸ºGIFå¯¹äºçº¿æ¡ç»˜ç”»(drawing)å’Œå›¾æ ‡çš„å›¾å½¢æ˜¯æ— æŸï¼Œä½†é’ˆå¯¹å…¨å½©å½±åƒåˆ™éœ€è¦æå›°éš¾çš„é‡åŒ–ï¼‰ æ ¹æ®æ•°æ®ç‡å¤±çœŸç†è®º(Rate distortion theory),ä¸­ç­‰è´¨é‡çš„ç…§ç‰‡åªæœ‰1/6çš„å­˜å‚¨ç©ºé—´ï¼Œä½†æ˜¯å‡ ä¹æ²¡æœ‰æ˜æ˜¾çš„ç»†èŠ‚æŸå¤±æˆ–æ˜¯çœ‹å¾—åˆ°çš„äººä¸ºæ•ˆæœã€‚ PNG Portable Network Graphics PNG is Not GIF ç”¨é€”ï¼šåœ¨ç½‘ç»œä¸Šæœ€å¸¸ç”¨ï¼Œå¯¹æ˜¾ç¤ºå™¨æœ‰ä¼˜åŒ–ï¼ˆç›¸å¯¹äºå°åˆ·æ¥è¯´ï¼‰ã€‚ ä¼˜åŠ¿ï¼šæ”¯æŒæ¯”GIFæ›´å¤šçš„é¢œè‰²ã€‚æ— æŸå‹ç¼©ã€‚æ”¯æŒé€æ˜åº¦ åŠ£åŠ¿ï¼šå°ºå¯¸æ¯”JPEGæ›´å¤§ã€‚ å­˜å‚¨ç±»å‹ï¼š PNG 8ï¼š256ç§é¢œè‰²ï¼Œé»‘ç™½ï¼ŒèŠ‚çœç©ºé—´ã€‚ PNG 24ï¼šRGB PNG 32ï¼šRGBA Alphaé€šé“(Î±/Alpha Channel)æ˜¯æŒ‡ä¸€å¼ å›¾ç‰‡çš„é€æ˜å’ŒåŠé€æ˜åº¦ã€‚ ä¸€ä¸ªä½¿ç”¨32ä¸ªæ¯”ç‰¹å­˜å‚¨çš„ä½å›¾ï¼Œçº¢ç»¿è“åŠAlphaé€šé“å„ä»¥8ä¸ªæ¯”ç‰¹è¡¨ç¤ºã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå°±ä¸å…‰å¯ä»¥è¡¨ç¤ºé€æ˜è¿˜æ˜¯ä¸é€æ˜ï¼ŒAlphaé€šé“è¿˜å¯ä»¥è¡¨ç¤º256çº§çš„åŠé€æ˜åº¦ã€‚ å¦‚æœä¿å­˜æ–‡æœ¬ï¼Œçº¿æ¡æˆ–ç±»ä¼¼çš„è¾¹ç¼˜æ¸…æ™°ï¼Œæœ‰å¤§å—ç›¸åŒé¢œè‰²åŒºåŸŸçš„å›¾åƒï¼ŒPNGæ ¼å¼çš„å‹ç¼©æ•ˆæœå°±è¦æ¯”JPEGå¥½å¾ˆå¤šï¼Œå¹¶ä¸”ä¸ä¼šå‡ºç°JPEGé‚£æ ·çš„é«˜å¯¹æ¯”åº¦åŒºåŸŸçš„å›¾åƒå¤±çœŸã€‚ ç”±äºJPEGæ˜¯æœ‰æŸå‹ç¼©ï¼Œä¼šäº§ç”Ÿè¿­ä»£å¤±çœŸï¼Œåœ¨é‡å¤å‹ç¼©å’Œè§£ç çš„è¿‡ç¨‹ä¸­ä¼šä¸æ–­ä¸¢å¤±ä¿¡æ¯ä½¿å›¾åƒè´¨é‡ä¸‹é™ã€‚ ç”±äºPNGæ˜¯æ— æŸçš„ï¼Œä¿å­˜å°†è¦ç¼–è¾‘çš„å›¾åƒæ¥è¯´æ›´åˆé€‚ã€‚ è¡¥å……ç‰¹æ€§è¯´æ˜ï¼š æ”¯æŒ256è‰²è°ƒè‰²æ¿æŠ€æœ¯ä»¥äº§ç”Ÿå°ä½“ç§¯æ–‡ä»¶ã€‚ æœ€é«˜æ”¯æŒ24ä½çœŸå½©è‰²ï¼ˆæ™®éè®¤ä¸ºäººçœ¼å¯¹è‰²å½©çš„åˆ†è¾¨èƒ½åŠ›å¤§è‡´æ˜¯ä¸€åƒä¸‡è‰²ï¼Œå› æ­¤æœ‰RGBç”Ÿæˆçš„å›¾åƒå‡ç§°ä¸ºçœŸå½©è‰²ï¼‰å›¾åƒä»¥åŠ8ä½ç°åº¦å›¾åƒã€‚ æ”¯æŒAlphaé€šé“çš„é€æ˜/åŠé€æ˜ç‰¹æ€§ã€‚ æ”¯æŒå›¾åƒäº®åº¦çš„Gammaæ ¡å‡†ä¿¡æ¯ã€‚ æ”¯æŒå­˜å‚¨é™„åŠ æ–‡æœ¬ä¿¡æ¯ï¼Œä»¥ä¿ç•™å›¾åƒåç§°ã€ä½œè€…ã€è‘—ä½œæƒã€åˆ›ä½œæ—¶é—´ã€æ³¨é‡Šç­‰ä¿¡æ¯ã€‚ æ”¯æŒæ— æŸå‹ç¼©ã€‚ æ¸è¿‘æ˜¾ç¤ºå’Œæµå¼è¯»å†™ï¼Œé€‚åˆåœ¨ç½‘ç»œä¼ è¾“ä¸­å¿«é€Ÿæ˜¾ç¤ºé¢„è§ˆæ•ˆæœåå†å±•ç¤ºå…¨è²Œã€‚ ä½¿ç”¨CRC(å¾ªç¯å†—ä½™æ ¡éªŒ)é˜²æ­¢æ–‡ä»¶å‡ºé”™ã€‚ æœ€æ–°çš„PNGæ ‡å‡†å…è®¸åœ¨ä¸€ä¸ªæ–‡ä»¶å†…å­˜å‚¨å¤šå¹…å›¾åƒã€‚ GIF Graphics Interchange Format ç”¨é€”ï¼šç½‘ç»œå›¾ç‰‡ï¼Œå°¤å…¶æ˜¯åŠ¨å›¾ã€‚ ä¼˜åŠ¿ï¼šåŠ è½½è¿…é€Ÿï¼Œæ”¯æŒåŠ¨ç”»ï¼Œæ— æŸå‹ç¼©ï¼Œå°ºå¯¸è¾ƒå°ï¼Œæ”¯æŒé€æ˜åº¦ã€‚ åŠ£åŠ¿ï¼šæœ€å¤§ä»…æ”¯æŒ256è‰²ï¼Œä¸æ”¯æŒCMYK å®ƒå®é™…ä¸Šæ˜¯ä¸€ç§å‹ç¼©æ–‡æ¡£ï¼Œé‡‡ç”¨LZWå‹ç¼©ç®—æ³•è¿›è¡Œç¼–ç (å­—å…¸HASH)ã€‚æœ‰æ•ˆåœ°å‡å°‘äº†å›¾åƒæ–‡ä»¶åœ¨ç½‘ç»œä¼ è¾“çš„æ—¶é—´ã€‚ EPS Encapsulated PostScript ç”¨é€”ï¼šç”¨äºä¿å­˜çŸ¢é‡å›¾ï¼Œå¦‚æ’ç”»ã€Logoå’Œå›¾æ ‡ã€‚ ä¼˜åŠ¿ï¼šæ”¯æŒä»»ä½•å°ºå¯¸çš„å›¾åƒã€‚æœ‰å¤§é‡è½¯ä»¶æ”¯æŒæŸ¥çœ‹ã€‚å¯ä»¥è½»æ¾åœ°è¢«è½¬æ¢ä¸ºåƒç´ å›¾ã€‚ åŠ£åŠ¿ï¼šç”¨äºç¼–è¾‘çš„è½¯ä»¶æœ‰é™ï¼Œæ‰“å°æœºæ”¯æŒæ€§äº¤å‰ã€‚æœ‰äº›EPSæ–‡ä»¶å†…éƒ¨æ˜¯åƒç´ å›¾ï¼Œåªæ˜¯è¢«ä¼ªè£…æˆäº†çŸ¢é‡å›¾ã€‚ EPSæ˜¯çŸ¢é‡å›¾é€šç”¨æ–‡ä»¶ï¼Œå¤§å¤šæ•°çŸ¢é‡ç¼–è¾‘è½¯ä»¶éƒ½æ”¯æŒEPSã€‚EPSæ ¼å¼æ–‡ä»¶ä¹Ÿå¯ä»¥åŒ…å«åƒç´ å›¾ã€‚ SVG Scalable Vector Graphics ç”¨é€”ï¼šç”¨äºç½‘ç»œçŸ¢é‡å›¾ï¼Œä»¥åŠå¯¼å…¥3Dè½¯ä»¶ã€‚ ä¼˜åŠ¿ï¼šæ”¯æŒçŸ¢é‡å†…å®¹ï¼Œä¹Ÿæ”¯æŒæ–‡æœ¬å’Œåƒç´ å›¾ï¼Œå¯ä»¥æ·»åŠ åŠ¨ç”»ï¼ˆé€šè¿‡å¤–éƒ¨ä»£ç äº¤äº’ï¼‰ã€‚æ”¾å¤§ç¼©å°ä¸ä¼šæ¨¡ç³Šã€‚å°ºå¯¸è¾ƒå°ã€‚å¯ç›´æ¥ä½œä¸ºä»£ç æ”¾åœ¨HTMLé‡Œã€‚å¯ä»¥è¢«æœç´¢å¼•æ“æ£€ç´¢ã€‚ åŠ£åŠ¿ï¼šæ”¯æŒçš„é¢œè‰²æ·±åº¦æœ‰é™ã€‚ä¸é€‚åˆç”¨ä½œå°åˆ·ã€‚ SVGåŸºäºXMLæ ¼å¼ï¼Œé€‚åˆå°†çŸ¢é‡å›¾ç”¨äºç½‘ç»œå‘å¸ƒã€‚åŒæ—¶ï¼ŒSVGä¹Ÿéå¸¸é€‚åˆç”¨äºå¯¼å‡º2Dè·¯å¾„åˆ°3Dè½¯ä»¶ä¸­ã€‚ PDF Portable Document Format ç”¨é€”ï¼šå­˜å‚¨æ–‡æ¡£ï¼Œç”¨äºæ‰“å°ã€‚ ä¼˜åŠ¿ï¼šå¯ä»¥åŒæ—¶å­˜å‚¨åƒç´ å›¾ã€çŸ¢é‡å›¾å’Œæ–‡æœ¬ã€‚å¾ˆå¤šè½¯ä»¶å¯ä»¥è¾“å‡ºPDFï¼Œæ”¯æŒå¤šé¡µã€‚ åŠ£åŠ¿ï¼šé™åˆ¶ç”¨äºWindowså’ŒMac OSï¼Œå¾ˆéš¾ç¼–è¾‘ã€‚ PDFæ ¼å¼æ˜¯å°è£…æ–‡æ¡£ç”¨äºå°åˆ·çš„é€šç”¨æ ‡å‡†ä¹‹ä¸€ã€‚ BMP BMPå–è‡ªä½å›¾Bitmapçš„ç¼©å†™ï¼Œä¹Ÿç§°ä¸ºDIBï¼ˆä¸è®¾å¤‡æ— å…³çš„ä½å›¾ï¼‰ ç”¨é€”ï¼šï¼Œæ˜¯ä¸€ç§ç‹¬ç«‹äºæ˜¾ç¤ºå™¨çš„ä½å›¾æ•°å­—å›¾åƒæ–‡ä»¶æ ¼å¼ã€‚å¸¸è§äºå¾®è½¯è§†çª—å’ŒOS/2æ“ä½œç³»ç»Ÿ. ä¼˜åŠ¿ï¼šæ— å‹ç¼©ï¼Œå¤§å¤šæ•°ç³»ç»Ÿéƒ½æ”¯æŒã€‚ åŠ£åŠ¿ï¼šç›¸å¯¹æ¥è¯´æ–‡ä»¶å°ºå¯¸å¤§ï¼Œä¸æ”¯æŒCMYKã€‚","categories":[],"tags":[{"name":"æ•°å­—å›¾åƒå¤„ç†","slug":"æ•°å­—å›¾åƒå¤„ç†","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"author":"tugumineko"},{"title":"STLè¯­æ³•","slug":"STL","date":"2024-06-10T14:37:44.000Z","updated":"2024-06-10T15:03:51.642Z","comments":true,"path":"2024/06/10/STL/","permalink":"http://example.com/2024/06/10/STL/","excerpt":"","text":"vector å¯ä»¥ç”¨ä¸‹æ ‡[]ç›´æ¥è®¿é—® åˆå§‹åŒ–å¤§å°åä¸ºéåŠ¨æ€æ•°ç»„ 12vector&lt;int&gt; v(n, 1);// v[0] åˆ° v[n - 1]æ‰€æœ‰çš„å…ƒç´ åˆå§‹å€¼å‡ä¸º1 //æ³¨æ„ï¼šæŒ‡å®šæ•°ç»„é•¿åº¦ä¹‹åï¼ˆæŒ‡å®šé•¿åº¦åçš„æ•°ç»„å°±ç›¸å½“äºæ­£å¸¸çš„æ•°ç»„äº†ï¼‰ æ–¹æ³•å‡½æ•° æ–¹æ³• æ—¶é—´å¤æ‚åº¦ v.front() O(1ï¼‰ v.back() O(1) v.pop_back() O(1) v.push_back(ele) O(1) v.size() O(1) v.empty() O(1) v.clear() O(N) æ’åºï¼šsort(v.begin(),v.end()) stack æ–¹æ³•å‡½æ•° æ–¹æ³• æ—¶é—´å¤æ‚åº¦ s.top() O(1ï¼‰ s.pop() O(1) s.push(ele) O(1) s.empty() O(1) s.size() O(1) æ ˆéå† 123456stack&lt;int&gt; st;for (int i = 0; i &lt; 10; ++i) st.push(i);while (!st.empty()) &#123; int tp = st.top(); // æ ˆé¡¶å…ƒç´  st.pop();&#125; queue æ–¹æ³•å‡½æ•° æ–¹æ³• æ—¶é—´å¤æ‚åº¦ q.front() O(1ï¼‰ q.back() O(1) q.pop() O(1) q.push(ele) O(1) v.size() O(1) v.empty() O(1) deque æ²¡ç”¨ priority_queue æ²¡æœ‰empty() æ–¹æ³•å‡½æ•° æ–¹æ³• æ—¶é—´å¤æ‚åº¦ pq.top() O(1ï¼‰ pq.push(ele) O(logN) pq.pop() O(logN) v.size() O(1) v.empty() O(1) 12priority_queue&lt;int&gt; pq; //é»˜è®¤å¤§æ ¹å †priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq; //å°æ ¹å † è‡ªå®šä¹‰æ’åºå°†greater&lt;int&gt;æ¢æˆcmpå³å¯ å¯¹pairç±»å‹å…ˆå¯¹firstæ’åºï¼Œå†å¯¹secondæ’åº","categories":[{"name":"cpp","slug":"cpp","permalink":"http://example.com/categories/cpp/"}],"tags":[{"name":"è¯­æ³•","slug":"è¯­æ³•","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"}],"author":"tugumineko"},{"title":"çŠ¶æ€å‹ç¼©dp","slug":"çŠ¶æ€å‹ç¼©dp","date":"2024-06-05T14:31:09.000Z","updated":"2024-06-05T14:37:01.758Z","comments":true,"path":"2024/06/05/çŠ¶æ€å‹ç¼©dp/","permalink":"http://example.com/2024/06/05/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/","excerpt":"","text":"ä»¥ä¸‹ä¸ºgpt4oçš„è§£ç­”ï¼š çŒæº‰æœºå™¨äºº å¥½çš„ï¼Œæˆ‘æ¥å¸®ä½ è§£æä¸€ä¸‹è¿™æ®µä»£ç ä¸­çš„å››é‡å¾ªç¯ã€‚ è¿™æ®µä»£ç çš„ç›®çš„æ˜¯åœ¨ç½‘æ ¼ä¸­æ”¾ç½®å¤§ç‚®ï¼Œè¦æ±‚å¤§ç‚®ä¸èƒ½æ”¾ç½®åœ¨ä¸¤ä¸ªç›¸é‚»çš„æ ¼å­é‡Œï¼ˆåŒ…æ‹¬å¯¹è§’çº¿ç›¸é‚»ï¼‰ã€‚ä»£ç ä½¿ç”¨äº†å‹ç¼©çŠ¶æ€åŠ¨æ€è§„åˆ’ï¼ˆDPï¼‰çš„æ–¹æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ æ ¸å¿ƒéƒ¨åˆ†è§£æ æ•°æ®ç»“æ„å’Œå‰ç½®å¤„ç† mp[105]: ç”¨æ¥å­˜å‚¨æ¯ä¸€è¡Œæ ¼å­çš„çŠ¶æ€ï¼Œè‹¥æŸæ ¼å­ä¸ºéšœç¢ï¼ˆâ€˜Hâ€™ï¼‰ï¼Œåˆ™å¯¹åº”ä½ç½®ä¸º1ã€‚ state[105]: ç”¨æ¥å­˜å‚¨æ‰€æœ‰åˆæ³•çš„çŠ¶æ€ï¼ˆå³ç›¸é‚»ä½ç½®æ²¡æœ‰æ”¾ç½®å¤§ç‚®çš„çŠ¶æ€ï¼‰ã€‚ sum[105]: æ¯ä¸ªçŠ¶æ€ä¸‹å¤§ç‚®çš„æ•°é‡ã€‚ dp[105][65][65]: åŠ¨æ€è§„åˆ’æ•°ç»„ï¼Œdp[r][j][i]è¡¨ç¤ºç¬¬rè¡ŒçŠ¶æ€ä¸ºstate[i]ä¸”ç¬¬(r-1)è¡ŒçŠ¶æ€ä¸ºstate[j]æ—¶çš„æœ€å¤§å¤§ç‚®æ•°é‡ã€‚ å‡½æ•°åŠŸèƒ½ ok(int x): æ£€æŸ¥çŠ¶æ€xæ˜¯å¦åˆæ³•ï¼Œå³ç›¸é‚»ä½ç½®æ²¡æœ‰æ”¾ç½®å¤§ç‚®ã€‚ getsum(int x): è®¡ç®—çŠ¶æ€xä¸­å¤§ç‚®çš„æ•°é‡ã€‚ findstate(int n): é¢„å¤„ç†ï¼Œæ±‚å‡ºæ‰€æœ‰åˆæ³•çš„çŠ¶æ€ã€‚ ä¸»é€»è¾‘ 12345678910111213141516171819202122232425262728293031323334void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; char ch; cin &gt;&gt; ch; if (ch == &#x27;H&#x27;) mp[i] |= (1 &lt;&lt; (j - 1)); &#125; &#125; findstate(m); for (int i = 1; i &lt;= cnt; i++) &#123; if (!(state[i] &amp; mp[1])) dp[1][1][i] = sum[i]; &#125; for (int r = 2; r &lt;= n; r++) &#123; for (int i = 1; i &lt;= cnt; i++) &#123; // æšä¸¾ç¬¬rè¡Œçš„çŠ¶æ€ if (state[i] &amp; mp[r]) continue; // å¦‚æœç¬¬rè¡ŒçŠ¶æ€ä¸éšœç¢å†²çªï¼Œè·³è¿‡ for (int j = 1; j &lt;= cnt; j++) &#123; // æšä¸¾ç¬¬(r-1)è¡ŒçŠ¶æ€ if (state[i] &amp; state[j]) continue; // å¦‚æœç¬¬rè¡Œå’Œç¬¬(r-1)è¡ŒçŠ¶æ€å†²çªï¼Œè·³è¿‡ for (int k = 1; k &lt;= cnt; k++) &#123; // æšä¸¾ç¬¬(r-2)è¡ŒçŠ¶æ€ if (state[i] &amp; state[k]) continue; // å¦‚æœç¬¬rè¡Œå’Œç¬¬(r-2)è¡ŒçŠ¶æ€å†²çªï¼Œè·³è¿‡ dp[r][j][i] = max(dp[r][j][i], dp[r-1][k][j] + sum[i]); &#125; &#125; &#125; &#125; int ans = 0; for (int i = 1; i &lt;= cnt; i++) &#123; for (int j = 1; j &lt;= cnt; j++) &#123; ans = max(ans, dp[n][i][j]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125; å››é‡å¾ªç¯è§£æ ç¬¬ä¸€é‡å¾ªç¯ (for (int r = 2; r &lt;= n; r++)): éå†æ¯ä¸€è¡Œï¼Œä»ç¬¬äºŒè¡Œå¼€å§‹ï¼Œå› ä¸ºç¬¬ä¸€è¡Œå·²ç»åˆå§‹åŒ–è¿‡ã€‚ ç¬¬äºŒé‡å¾ªç¯ (for (int i = 1; i &lt;= cnt; i++)): éå†æ‰€æœ‰å¯èƒ½çš„çŠ¶æ€state[i]ï¼Œä½œä¸ºç¬¬rè¡Œçš„çŠ¶æ€ã€‚ ç¬¬ä¸‰é‡å¾ªç¯ (for (int j = 1; j &lt;= cnt; j++)): éå†æ‰€æœ‰å¯èƒ½çš„çŠ¶æ€state[j]ï¼Œä½œä¸ºç¬¬r-1è¡Œçš„çŠ¶æ€ã€‚ ç¬¬å››é‡å¾ªç¯ (for (int k = 1; k &lt;= cnt; k++)): éå†æ‰€æœ‰å¯èƒ½çš„çŠ¶æ€state[k]ï¼Œä½œä¸ºç¬¬r-2è¡Œçš„çŠ¶æ€ã€‚ æ£€æŸ¥state[i]å’Œstate[k]æ˜¯å¦å†²çªï¼Œå¦‚æœä¸å†²çªï¼Œæ›´æ–°dp[r][j][i]ã€‚ æ³¨æ„äº‹é¡¹ æ¯è¡ŒçŠ¶æ€ä¸å½“å‰è¡Œçš„éšœç¢çŠ¶æ€mp[r]è¿›è¡ŒåŒ¹é…ï¼Œç¡®ä¿ä¸æ”¾ç½®åœ¨éšœç¢ä½ç½®ã€‚ ç¡®ä¿æ¯è¡ŒçŠ¶æ€ä¸å‰ä¸¤è¡ŒçŠ¶æ€ä¸å†²çªï¼Œå³ä¸åœ¨ç›¸é‚»çš„è¡Œä¸­æœ‰ç›¸é‚»çš„æ”¾ç½®ã€‚ dp[r][j][i] = max(dp[r][j][i], dp[r-1][k][j] + sum[i]); è¿™è¡Œä»£ç æ˜¯åŠ¨æ€è§„åˆ’çš„æ ¸å¿ƒè½¬ç§»æ–¹ç¨‹ï¼Œç”¨äºæ›´æ–°å½“å‰çŠ¶æ€çš„æœ€å¤§å¤§ç‚®æ•°é‡ã€‚å…·ä½“æ¥è¯´ï¼Œè¿™ä¸ªè½¬ç§»æ–¹ç¨‹çš„æ„ä¹‰å¦‚ä¸‹ï¼š dpéƒ¨åˆ† è§£é‡Š dp[r][j][i]ï¼šè¡¨ç¤ºç¬¬ r è¡Œçš„çŠ¶æ€ä¸º state[i]ï¼Œç¬¬ r-1 è¡Œçš„çŠ¶æ€ä¸º state[j] æ—¶ï¼Œæ”¾ç½®å¤§ç‚®çš„æœ€å¤§æ•°é‡ã€‚ dp[r-1][k][j]ï¼šè¡¨ç¤ºç¬¬ r-1 è¡Œçš„çŠ¶æ€ä¸º state[j]ï¼Œç¬¬ r-2 è¡Œçš„çŠ¶æ€ä¸º state[k] æ—¶ï¼Œæ”¾ç½®å¤§ç‚®çš„æœ€å¤§æ•°é‡ã€‚ sum[i]ï¼šè¡¨ç¤ºçŠ¶æ€ state[i] ä¸­å¤§ç‚®çš„æ•°é‡ã€‚ å·¥ä½œåŸç† è¿™ä¸ªè½¬ç§»æ–¹ç¨‹çš„ä½œç”¨æ˜¯ç¡®ä¿åœ¨æ›´æ–°å½“å‰è¡ŒçŠ¶æ€çš„æœ€å¤§å¤§ç‚®æ•°é‡æ—¶ï¼Œè€ƒè™‘æ‰€æœ‰å¯èƒ½çš„å‰ä¸¤è¡ŒçŠ¶æ€ï¼Œå¹¶é€‰æ‹©æœ€å¤§å€¼ã€‚ æ›´å…·ä½“çš„è§£é‡Šï¼š å½“å‰è¡ŒçŠ¶æ€ state[i] çš„é€‰æ‹©ï¼š è€ƒè™‘ç¬¬ r è¡Œçš„çŠ¶æ€ state[i]ï¼Œå¹¶æ£€æŸ¥å®ƒæ˜¯å¦ä¸å½“å‰è¡Œçš„éšœç¢ä½ç½® (mp[r]) å†²çªã€‚ å‰ä¸€è¡ŒçŠ¶æ€ state[j] çš„é€‰æ‹©ï¼š è€ƒè™‘ç¬¬ r-1 è¡Œçš„çŠ¶æ€ state[j]ï¼Œå¹¶æ£€æŸ¥å®ƒæ˜¯å¦ä¸å½“å‰è¡ŒçŠ¶æ€ state[i] å†²çªã€‚ å†å‰ä¸€è¡ŒçŠ¶æ€ state[k] çš„é€‰æ‹©ï¼š è€ƒè™‘ç¬¬ r-2 è¡Œçš„çŠ¶æ€ state[k]ï¼Œå¹¶æ£€æŸ¥å®ƒæ˜¯å¦ä¸å½“å‰è¡ŒçŠ¶æ€ state[i] å†²çªã€‚ æ›´æ–° dp[r][j][i]ï¼š å¦‚æœ state[i]ã€state[j] å’Œ state[k] äº’ä¸å†²çªï¼Œé‚£ä¹ˆ dp[r][j][i] å°±ç­‰äºå‰ä¸€çŠ¶æ€ dp[r-1][k][j] åŠ ä¸Šå½“å‰è¡ŒçŠ¶æ€çš„ç‚®æ•° sum[i]ã€‚ ç”¨ max å‡½æ•°æ¥ç¡®ä¿é€‰æ‹©çš„æ˜¯æœ€å¤§å€¼ã€‚ ä¾‹å­ å‡è®¾æœ‰ä»¥ä¸‹å‚æ•°ï¼š state[i] è¡¨ç¤ºçš„ç¬¬ r è¡ŒçŠ¶æ€æ”¾ç½®äº†3ä¸ªå¤§ç‚®ã€‚ dp[r-1][k][j] è¡¨ç¤ºçš„ç¬¬ r-1 è¡Œå’Œç¬¬ r-2 è¡ŒçŠ¶æ€ç»„åˆèƒ½å¤Ÿæ”¾ç½®çš„æœ€å¤§å¤§ç‚®æ•°ä¸º5ã€‚ é‚£ä¹ˆï¼Œå¯¹äºå½“å‰çš„ç»„åˆï¼Œå¦‚æœå®ƒä»¬æ²¡æœ‰å†²çªï¼Œdp[r][j][i] å°†æ›´æ–°ä¸º 5 + 3 = 8ã€‚ æ€»çš„æ¥è¯´ï¼Œè¿™ä¸ªåŠ¨æ€è§„åˆ’è½¬ç§»æ–¹ç¨‹çš„ç›®çš„å°±æ˜¯åœ¨ä¸è¿åå¤§ç‚®æ”¾ç½®è§„åˆ™çš„å‰æä¸‹ï¼Œéå†æ‰€æœ‰å¯èƒ½çš„çŠ¶æ€ç»„åˆï¼Œæ‰¾åˆ°å½“å‰è¡ŒåŠå…¶å‰ä¸¤è¡Œçš„æ”¾ç½®æ–¹æ¡ˆä¸­èƒ½å¤Ÿæ”¾ç½®å¤§ç‚®çš„æœ€å¤§æ•°é‡ã€‚ å°æ˜çš„ç§¯æœ¨ è¿™æ®µä»£ç å®ç°äº†ä¸€ä¸ªä½¿ç”¨çŠ¶æ€å‹ç¼©åŠ¨æ€è§„åˆ’ï¼ˆDPï¼‰çš„ç®—æ³•ï¼Œé€šå¸¸ç”¨äºè§£å†³ç»„åˆä¼˜åŒ–é—®é¢˜ã€‚å…·ä½“æ¥è¯´ï¼Œè¿™é‡Œçš„ä»£ç è§£å†³äº†ä¸€ä¸ªå˜ç§çš„èƒŒåŒ…é—®é¢˜ã€‚æˆ‘ä»¬å°†é€æ­¥è§£æä»£ç ä¸­æ¶‰åŠçš„ä½è¿ç®—éƒ¨åˆ†ã€‚ æ•°æ®ç»“æ„å’Œå˜é‡ 12345const int N = 20;int s[N]; // å­˜å‚¨æ¯ä¸ªç‰©å“çš„æŸä¸ªå±æ€§å€¼ï¼ˆä¾‹å¦‚ï¼Œä»·å€¼æˆ–å…¶ä»–å±æ€§ï¼‰int w[N]; // å­˜å‚¨æ¯ä¸ªç‰©å“çš„é‡é‡int dp[1&lt;&lt;N]; // åŠ¨æ€è§„åˆ’æ•°ç»„ï¼Œå¤§å°ä¸º 2^N è¾“å…¥å’Œåˆå§‹åŒ– 123456void solve() &#123; int W, n; cin &gt;&gt; W &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; s[i] &gt;&gt; w[i]; &#125; W æ˜¯èƒŒåŒ…çš„å®¹é‡ã€‚ n æ˜¯ç‰©å“çš„æ•°é‡ã€‚ s[i] æ˜¯ç¬¬ i ä¸ªç‰©å“çš„å±æ€§å€¼ã€‚ w[i] æ˜¯ç¬¬ i ä¸ªç‰©å“çš„é‡é‡ã€‚ çŠ¶æ€å‹ç¼©å’Œä½è¿ç®— çŠ¶æ€å‹ç¼©çš„æ ¸å¿ƒåœ¨äºä½¿ç”¨ä¸€ä¸ªæ•´æ•°çš„äºŒè¿›åˆ¶è¡¨ç¤ºæ¥è¡¨ç¤ºä¸€ä¸ªå­é›†ã€‚ä¾‹å¦‚ï¼Œå¯¹äº n ä¸ªç‰©å“ï¼Œä½¿ç”¨ä¸€ä¸ª n ä½çš„äºŒè¿›åˆ¶æ•° i æ¥è¡¨ç¤ºç‰©å“çš„é€‰æ‹©çŠ¶æ€ï¼š i çš„ç¬¬ j ä½ä¸º 1 è¡¨ç¤ºé€‰æ‹©äº†ç¬¬ j ä¸ªç‰©å“ã€‚ i çš„ç¬¬ j ä½ä¸º 0 è¡¨ç¤ºæ²¡æœ‰é€‰æ‹©ç¬¬ j ä¸ªç‰©å“ã€‚ 123456789for (int i = 0; i &lt; (1 &lt;&lt; n); i++) &#123; int ss = 0; int ww = 0; for (int j = 1; j &lt;= n; j++) &#123; if (i &amp; (1 &lt;&lt; (j - 1))) &#123; ww += w[j]; ss = max(s[j], ss); &#125; &#125; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) æšä¸¾æ‰€æœ‰å¯èƒ½çš„ç‰©å“å­é›†ï¼Œå…±æœ‰ 2^n ä¸ªå­é›†ã€‚ if (i &amp; (1 &lt;&lt; (j - 1))) æ£€æŸ¥å­é›† i æ˜¯å¦åŒ…å«ç‰©å“ jã€‚(1 &lt;&lt; (j - 1)) ç”Ÿæˆä¸€ä¸ªåªæœ‰ç¬¬ j-1 ä½ä¸º 1 çš„æ•°ï¼Œi &amp; (1 &lt;&lt; (j - 1)) æ£€æŸ¥ i çš„ç¬¬ j-1 ä½æ˜¯å¦ä¸º 1ã€‚ åŠ¨æ€è§„åˆ’è½¬ç§»æ–¹ç¨‹ 123456789 if (ww &lt;= W) &#123; dp[i] = ss; &#125; else &#123; dp[i] = 0x3f3f3f3f; for (int j = i; j; j = (j - 1) &amp; i) &#123; dp[i] = min(dp[i], dp[j] + dp[j ^ i]); &#125; &#125;&#125; if (ww &lt;= W) æ£€æŸ¥å½“å‰å­é›†çš„æ€»é‡é‡ ww æ˜¯å¦ä¸è¶…è¿‡èƒŒåŒ…å®¹é‡ Wï¼Œå¦‚æœæ˜¯ï¼Œåˆ™ dp[i] è®¾ä¸ºå½“å‰å­é›†ä¸­æœ€å¤§å±æ€§å€¼ ssã€‚ else è¡¨æ˜å½“å‰å­é›†è¶…é‡ï¼Œæ­¤æ—¶éœ€è¦é€šè¿‡å­é›†åˆ’åˆ†æ¥è®¡ç®—æœ€ä¼˜è§£ã€‚ for (int j = i; j; j = (j - 1) &amp; i) éå†å½“å‰å­é›† i çš„æ‰€æœ‰å­é›† jã€‚è¿™ç§éå†æ–¹å¼åˆ©ç”¨äº† (j - 1) &amp; i çš„ç‰¹æ€§ï¼Œèƒ½é«˜æ•ˆåœ°ç”Ÿæˆ i çš„æ‰€æœ‰å­é›†ï¼š (j - 1) &amp; i ç”Ÿæˆ i çš„ä¸‹ä¸€ä¸ªå­é›†ã€‚ dp[i] = min(dp[i], dp[j] + dp[j ^ i]) æ›´æ–° dp[i]ï¼Œå…¶ä¸­ dp[j] + dp[j ^ i] è¡¨ç¤ºå°†å­é›† i æ‹†åˆ†ä¸º j å’Œ i-j ä¸¤ä¸ªå­é›†çš„æ€»å’Œã€‚ è¾“å‡ºç»“æœ 1cout &lt;&lt; dp[(1 &lt;&lt; n) - 1]; dp[(1 &lt;&lt; n) - 1] è¡¨ç¤ºæ‰€æœ‰ç‰©å“éƒ½è¢«è€ƒè™‘çš„æƒ…å†µä¸‹çš„æœ€ä¼˜è§£ã€‚","categories":[{"name":"cpp","slug":"cpp","permalink":"http://example.com/categories/cpp/"}],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"åˆ·é¢˜","slug":"åˆ·é¢˜","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}],"author":"tugumineko"},{"title":"ç”¨æˆ·æ€å†…å­˜åˆ†é…å™¨","slug":"user-malloc","date":"2024-05-28T12:36:26.000Z","updated":"2024-05-30T14:05:49.041Z","comments":true,"path":"2024/05/28/user-malloc/","permalink":"http://example.com/2024/05/28/user-malloc/","excerpt":"","text":"å†…å­˜çš„åˆ†é…å’Œé‡Šæ”¾åœ¨å †(Heap)ä¸Šå®Œæˆ void * ptr = malloc (size) free(ptr) Stackåˆ†é…æ˜¯è¿ç»­çš„ï¼Œå› ä¸ºä¸éœ€è¦ç®¡ç†ã€‚ Heapæ˜¯æŒ‰ç…§sizeå¤§å°åˆ†é…çš„ï¼Œä¸æ˜¯è¿ç»­çš„ã€‚ 1234567int* a1 = malloc (1000 *sizeof(int));int* a2 = malloc (100 *sizeof(int));int b[1000];int b2[100];*(int *)((uint64_t)&amp;b2 - sizeof(int)) = b1[999];//true malloc åˆ†é…å®Œè¦è®°å¾—é‡Šæ”¾ï¼Œé˜²æ­¢å†…å­˜æ³„éœ² å…·ä½“å®ç°ï¼š malloc : é€‰æ‹©å¯ä»¥æ”¾è¿›å»çš„å—æ ‡è®°ä¸ºallocatedï¼Œè¿”å›ä½åœ°å€ free ï¼šå°†alloctedæ ‡è®°å»é™¤ï¼Œå¹¶è¿æ¥æœªåˆ†é…çš„å…¶ä»–ç©ºé—´ï¼Œé‡Šæ”¾ç›¸é‚»çš„byteæ•ˆç‡æ›´é«˜ 8Byteå¯¹é½æœ€åæœ‰ä¸‰ä½ç©ºé—²0ï¼ˆæ˜¯å…«çš„å€æ•°ï¼‰ï¼Œæœ€åä¸€ä½ç”¨æ¥æ ‡è®°allocatedï¼Œä¸ä¼šå ç”¨ä»»ä½•ç©ºé—´ ç±»ä¼¼åœ°ï¼Œæœ‰ä¸ºäº†èŠ‚çœçº¢é»‘æ ‘èŠ‚ç‚¹å†…å­˜ç©ºé—´ï¼ˆå­—èŠ‚å¯¹é½ï¼‰çš„æ“ä½œï¼š 12345678910struct RBTreeNode&#123; //ç»“æ„ä½“å†…ä¸ä½¿ç”¨ä¼šæµªè´¹å†…å­˜å­—èŠ‚å¯¹é½çš„bool color RBTreeNode* prev; RBTreeNode* left; RBTreeNode* right; int64 value;&#125;;//32bytesbool color = p-&gt;prev &amp; 0x1;RBTreeNode* pre = p-&gt;prev &amp; 0xFFFFFFFE è¿™é‡Œé¢„ç•™4Bæ¥è®°å½•sizeï¼Œfreeæ—¶allocatedæ¶ˆå»ï¼Œsizeä¸å˜ å—åˆ†é…ç¤ºä¾‹1ï¼š int* a = malloc (sizeof(int)); *a = 0xabcd;//(0x0000abcd) size = 8 = 0x1;//åˆ†é…çš„å®é™…å—å¤§å°8byteï¼Œæ³¨æ„å­—èŠ‚å¯¹é½ 0xd 0xc 0xb 0xa 0000 0000 0000 0000 1101 1100 1011 1010 0000 0000 0000 0000 0000 0000 0000 1001 //size: 0x1 //allocated : 1 4B / 8B = 50% å—åˆ†é…ç¤ºä¾‹1ï¼š char* str = malloc(6); str = &quot;hello\\0&quot; size = 4B + 4B + 2B + 6B = 16B = 0x10; 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 '\\0' 'o' 'l' 'l' 'e' 'h' 0000 0000 0000 0000 0000 0000 0001 0001 è¿™æ ·çš„è¯ï¼ŒHeapå€ŸåŠ©sizeçš„åç§»å°±å½¢æˆäº†ä¸€ä¸ªå•å‘é“¾è¡¨ 123456789void* p = malloc(s);uint64_t header_addr = (uint64_t)p - 4;uint32_t header_value = *((uint32_t*)header_addr);//å–å32ä½uint32_t block_size = header_value &amp; 0xFFFFFFFE;int allocated = header_value &amp; 0x1;uint64_t next_header_addr = header_addr + block_size; malloc å’Œ free å®ç°ï¼š 1234567891011121314151617181920212223242526272829303132333435363738void malloc(uint32_t size) &#123; uint64_t p = head_start_address; while (1) &#123; uint32_t p_header_value = *((uint32_t*)p); uint32_t p_block_size = header_value &amp; 0xFFFFFFFE; uint32_t p_allocated = header_value &amp; 0x1; if(p_allocated == 0 &amp;&amp; p_block_size - sizeof(uint32_t) &gt;= size) &#123; //split uint32_t request_block_size = size + sizeof(uint32_t); if(request_block_size &amp; 0x7 != 0)&#123; //data alignment request_block_size = request_block_size &amp; 0xFFFFFFF8 + 0x8; &#125; p = request_block_size | 0x1;//size &amp;&amp; allocated uint64_t q = p + request_block_size;//next_header_addr q = p_block_size - request_block_size; return(void*)(p + sizeof(uint32_t));//go to payload &#125; else &#123; //go to next_head_address p = p + p_block_size; &#125; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435void free(void* p) &#123; uint64_t payload_addr = (uint64_t)p; uint64_t header_addr = p-4; uint32_t allocated = header_addr &amp; 0x1; if(allocated == 0)&#123; printf(&quot;free twice&quot;); return; &#125; uint32_t block_size = header_addr &amp; 0xFFFFFFFE; uint64_t q = header_addr + block_size; uint32_t q_allocated = get_allocation(q); uint32_t q_block_size = get_block_size(q); if(q_allocated == 1)&#123; set_free(q); return; &#125; else&#123; //merge q &amp;&amp; p block_size = block_size + q_block_size; header_addr = block_size | 0x0; p = header_addr + sizeof(uint32_t); &#125; &#125; è¿™åªæ˜¯ä¸€ä¸ªå•å‘é“¾è¡¨ï¼Œåœ¨freeæ—¶æ— æ³•å’Œå‰é¢åˆå¹¶ï¼Œåˆ©ç”¨ç©ºé—´ä¸å®Œå…¨ã€‚ ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼šè¦åœ¨blockåŠ ä¸€ä¸ªfooterçš„ç»“æ„ï¼Œå’Œheaderä¸€æ ·ï¼ŒåŒ…å«äº†sizeå’Œallocated éšå¼ç©ºé—²é“¾è¡¨ implicit free list åŸºäºåœ°å€å®ç°çš„implicit listå®ç°å¦‚ä¸‹ï¼ˆä¸å®Œå…¨å®ç°ï¼‰ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390//// Created by 29400 on 2024/5/29.//#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;void heap_init();uint64_t mem_alloc(uint32_t size);void mem_free(uint64_t vaddr);void syscall_brk(uint64_t) &#123;&#125;uint64_t heap_start_vaddr;uint64_t heap_end_vaddr;#define HEAP_MAX_SIZE (4096 * 8)uint8_t heap[HEAP_MAX_SIZE];typedef struct &#123;&#125;block_t;/** Round up to the next mutiple of n. * if (x== k * n) * return x. * else, x = k * n + m and m &lt; n * return x = (k + 1) * n. */static uint64_t round_up(uint64_t x, uint64_t n) &#123; return n * ((x + n - 1) / n);&#125;// applicantable for both header &amp;&amp; footerstatic uint32_t get_blocksize(uint64_t vaddr) &#123; if(vaddr==0) &#123; // NULL can be considered as size 0 return 0; &#125; assert(heap_start_vaddr &lt;= vaddr &amp;&amp; vaddr &lt;= heap_end_vaddr - 4); assert((vaddr &amp; 0x3) == 0x0); // 4 bytes alignment uint32_t value = *(uint32_t*)&amp;heap[vaddr]; return value &amp; 0xFFFFFFF8;&#125;// applicantable for both header &amp;&amp; footerstatic uint32_t get_allocated(uint64_t vaddr) &#123; if(vaddr==0) &#123; // NULL can be considered as allocated return 1; &#125; assert(heap_start_vaddr &lt;= vaddr &amp;&amp; vaddr &lt;= heap_end_vaddr); assert((vaddr &amp; 0x3) == 0x0); // 4 bytes alignment uint32_t value = *(uint32_t*)&amp;heap[vaddr]; return value &amp; 0x1;&#125;static void set_blocksize(uint64_t header_vaddr, uint32_t blocksize) &#123; if(header_vaddr==0) &#123; return; &#125; assert(heap_start_vaddr &lt;= header_vaddr &amp;&amp; header_vaddr &lt;= heap_end_vaddr); assert((header_vaddr &amp; 0x3) == 0x0); // 4 bytes alignment assert((blocksize &amp; 0x7) == 0x0); // 8 bytes alignment *(uint32_t*)&amp;heap[header_vaddr] &amp;= 0x00000007; *(uint32_t*)&amp;heap[header_vaddr] |= blocksize;&#125;static void set_allocated(uint64_t header_vaddr, uint32_t allocated) &#123; if(header_vaddr==0) &#123; return; &#125; assert(heap_start_vaddr &lt;= header_vaddr &amp;&amp; header_vaddr &lt;= heap_end_vaddr); assert((header_vaddr &amp; 0x3) == 0x0); // 4 bytes alignment *(uint32_t*)&amp;heap[header_vaddr] &amp;= 0x00000007; *(uint32_t*)&amp;heap[header_vaddr] |= (allocated &amp; 0x1);&#125;/** * @param vaddr can be : * 1. starting address of the block (8 * n + 4) * 2. starting address of the payload (8 * m) */static uint64_t get_payload_addr(uint64_t vaddr) &#123; return round_up(vaddr,8);&#125;/** * @param vaddr can be : * 1. starting address of the block (8 * n + 4) * 2. starting address of the payload (8 * m) */static uint64_t get_header_addr(uint64_t vaddr) &#123; uint64_t payload_vaddr = get_payload_addr(vaddr); // NULL block does not have header return payload_vaddr == 0 ? 0 : payload_vaddr - 4;&#125;/** * @param vaddr can be : * 1. starting address of the block (8 * n + 4) * 2. starting address of the payload (8 * m) */static uint64_t get_footer_addr(uint64_t vaddr) &#123; uint64_t next_header = get_header_addr(vaddr); // last block does not have footer return next_header == 0 ? 0 : next_header - 4;&#125;static int is_lastblock(uint64_t vaddr) &#123; assert(heap_start_vaddr &lt;= vaddr &amp;&amp; vaddr &lt;= heap_end_vaddr); assert((vaddr &amp; 0x3) == 0x0); // 4 bytes alignment uint64_t header_vaddr = get_header_addr(vaddr); uint64_t block_size = get_blocksize(heap_end_vaddr); if(header_vaddr + block_size == heap_end_vaddr + 1 + 4) &#123; return 1; &#125; return 0;&#125;/** * @param vaddr can be : * 1. starting address of the block (8 * n + 4) * 2. starting address of the payload (8 * m) */static uint64_t get_nextheader (uint64_t vaddr) &#123; if(vaddr==0||is_lastblock(vaddr)) &#123; return 0; &#125; uint64_t header_vaddr = get_header_addr(vaddr); uint32_t block_size = get_blocksize(header_vaddr); uint64_t next_header_vaddr = header_vaddr + block_size; assert(0 &lt;= next_header_vaddr &amp;&amp; next_header_vaddr &lt;= heap_end_vaddr); return next_header_vaddr;&#125;/** * @param vaddr can be : * 1. starting address of the block (8 * n + 4) * 2. starting address of the payload (8 * m) */static uint64_t get_prevheader (uint64_t vaddr) &#123; if(vaddr == 0) &#123; return 0; &#125; uint64_t header_vaddr = get_header_addr(vaddr); if(header_vaddr==heap_start_vaddr) &#123; return 0; &#125; //assert(header_vaddr &gt;= 20);//.// uint32_t prev_footer_vaddr = header_vaddr - 4; uint32_t block_size = get_blocksize(prev_footer_vaddr); uint32_t prev_header_vaddr = header_vaddr - block_size; assert(0 &lt;= prev_header_vaddr &amp;&amp; prev_header_vaddr &lt;= heap_end_vaddr - 12); return prev_header_vaddr;&#125;/** rules : * 1. block[0] ==&gt; A/F. * 2. block[last] ==&gt; A/F. * 3. block[i] == A ==&gt; block[i-1] == A/F &amp;&amp; block[i+1] == A/F. * 4. block[i] == F ==&gt; block[i-1] == A &amp;&amp; block[i+1] == A. * * these 4 rules ensure that * adjancent free blocks are always merged together * henceforth external fragmentation are minimized. */int heap_check() &#123; return 0;&#125;void heap_init() &#123; // heap_start_vaddr is the starting address of the first block // the payload of the first block is 8B aligned ([8]) // so the header address of the first block is [8] - 4 = [4] heap_start_vaddr = 4; set_blocksize(heap_start_vaddr,4096 - 8); set_allocated(heap_start_vaddr,0); // the last block is without footer heap_end_vaddr = 4096 - 1;&#125;/** * @param block_vaddr the virtual address of header * @param requested_blocksize the whole size of block * @return the virtual address of allocated payload, when no enough free block for current heap, return 0 */static uint64_t try_alloc(uint64_t block_vaddr, uint32_t requested_blocksize) &#123; uint64_t b = block_vaddr; uint32_t b_blocksize = get_blocksize(b); uint32_t b_allocated = get_allocated(b); if(b_allocated == 0 &amp;&amp; b_blocksize &gt;= requested_blocksize) &#123; //allocated this block if(b_blocksize &gt; requested_blocksize) &#123; //split the block &#x27;b&#x27; set_allocated(b, 1); set_blocksize(b, requested_blocksize); //set the left splited block /** * in the extreme situation, next block size == 8 * which makes the whole next block to be : * [0x0000&#x27;0008, 0x0000&#x27;0008] */ uint64_t next_header_vaddr = b + requested_blocksize; set_allocated(next_header_vaddr, 0); set_blocksize(next_header_vaddr, b_blocksize - requested_blocksize); return get_payload_addr(b); &#125; else &#123; set_blocksize(b, requested_blocksize); set_allocated(b, 1); return get_payload_addr(b); &#125; &#125; return 0;&#125;/** * @param size requested payload size * @return the virtual address of payload */uint64_t mem_alloc(uint32_t size)&#123; assert(0 &lt; size &amp;&amp; size &lt; 4096 - 8); uint64_t payload_vaddr = 0; uint32_t requested_blocksize = round_up(size,8) + 8; uint64_t last_block = 0; uint64_t b = heap_start_vaddr; while(b &lt;= heap_end_vaddr) &#123; payload_vaddr = try_alloc(b,requested_blocksize); if(payload_vaddr != 0) &#123; return payload_vaddr; &#125; else &#123; // go to next block if(is_lastblock(b)) &#123; last_block = b; &#125; b = get_nextheader(b); &#125; &#125; // when no enough free block for current heap // request a new free physical &amp; virtual page from OS if(heap_end_vaddr + 1 + 4096 &lt;= HEAP_MAX_SIZE) &#123; // we can allocated page for the request uint64_t old_heap_end = heap_end_vaddr; // brk system call syscall_brk(heap_end_vaddr + 1); heap_end_vaddr += 4096; uint32_t last_allocated = get_allocated(last_block); uint32_t last_blocksize = get_blocksize(last_block); if(get_allocated(last_block)==1) &#123; // add footer for the last block // set_allocated(old_heap_end) set_allocated(old_heap_end, 1); set_blocksize(old_heap_end, last_blocksize); set_allocated(heap_end_vaddr + 4, 0); set_blocksize(heap_end_vaddr + 4, 4096); last_block = old_heap_end + 4; &#125; else &#123; set_allocated(last_block,last_blocksize + 4096); &#125; // try to allocated payload_vaddr = try_alloc(last_block,requested_blocksize); if(payload_vaddr != 0) &#123; return payload_vaddr; &#125; &#125; // &lt;==&gt; return NULL; return 0;&#125;void mem_free(uint64_t payload_vaddr) &#123; assert(heap_start_vaddr &lt;= payload_vaddr &amp;&amp; payload_vaddr &lt;= heap_end_vaddr); assert((payload_vaddr &amp; 0x7) == 0x0); uint64_t req = get_header_addr(payload_vaddr); uint64_t req_footer = get_footer_addr(req);//.0.// uint32_t req_allocated = get_allocated(req); uint32_t req_blocksize = get_blocksize(req); assert(req_allocated==1); // block starting address of next &amp;&amp; prev uint64_t next = get_nextheader(req);// last . 0 uint64_t next_footer = get_footer_addr(next); uint64_t prev = get_prevheader(req);// first . 0 uint32_t next_allocated = get_allocated(next);// last . 1 uint32_t prev_allocated = get_allocated(prev);// first . 1 uint32_t next_blocksize = get_blocksize(next);// last . 0 uint32_t prev_blocksize = get_blocksize(prev);// first . 0 if(next_allocated == 1 &amp;&amp; prev_allocated == 1) &#123; set_allocated(req,0); set_allocated(req_footer,0); &#125; else if(next_allocated == 0 &amp;&amp; prev_allocated == 1) &#123; set_allocated(req, 0); set_blocksize(req, req_blocksize + next_blocksize); set_allocated(next_footer,0); set_blocksize(next_footer,req_blocksize + next_blocksize); &#125; else if(next_allocated == 1 &amp;&amp; prev_allocated ==0) &#123; set_allocated(prev, 0 ); set_blocksize(prev, req_blocksize + prev_blocksize); set_allocated(req_footer, 0); set_blocksize(req_footer,req_blocksize + prev_blocksize); &#125; else &#123; set_allocated(prev, 0 ); set_blocksize(prev, req_blocksize + prev_blocksize + next_blocksize); set_allocated(next_footer, 0); set_blocksize(next_footer, req_blocksize + prev_blocksize + next_blocksize); &#125;&#125; æ˜¾å¼ç©ºé—²é“¾è¡¨ explicit free list å¯ä»¥åšåˆ°Tsearch(Explicit)â‰¤12Tsearch(Implicit)T{search}(Explicit)\\le\\frac12T{search}(Implicit)Tsearch(Explicit)â‰¤21â€‹Tsearch(Implicit)ï¼Œï¼ˆäº¤é”™åˆ†å¸ƒï¼Œç³–æ°´ä¸ç­‰å¼ï¼‰","categories":[{"name":"C","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://example.com/tags/OS/"}],"author":"tugumineko"},{"title":"æ‰©æ•£æ¨¡å‹ - Diffusion Model","slug":"diffusion-model","date":"2024-05-26T06:10:13.000Z","updated":"2024-05-30T14:07:24.052Z","comments":true,"path":"2024/05/26/diffusion-model/","permalink":"http://example.com/2024/05/26/diffusion-model/","excerpt":"","text":"å¼•å…¥ Diffusion Modelæ˜¯å¦‚ä½•è¿ä½œçš„ å°±åƒæŠŠçŸ³å¤´é›•åˆ»æˆé›•å¡‘ï¼ŒDiffusionModelæ˜¯å°†ä¸€å¼ å……æ»¡å™ªå£°ï¼ˆnoiseï¼‰çš„å›¾ç‰‡ä¸æ–­Denoiseæœ€åç”Ÿæˆå›¾ç‰‡çš„è¿‡ç¨‹ Denoiseæ¨¡ç»„å†…éƒ¨å®é™…åšçš„äº‹æƒ… åœ¨é‡åˆ°ä¸€ä¸ªå›¾ç‰‡çš„Denoiseè¿‡ç¨‹çš„æ—¶å€™ï¼Œå…ˆè®¡ç®—å‡ºå™ªå£°çš„ä¸¥é‡ç¨‹åº¦ï¼Œç„¶åæ¨æ–­å‡ºéœ€è¦æ¶ˆå»çš„å™ªå£°ï¼ˆè¿™ä¸ªåœ¨è®­ç»ƒæ¨¡å‹çš„æ—¶å€™çš„stepï¼‰,æœ€åä¸€æ­¥æ­¥ç”Ÿæˆå›¾ç‰‡ ç±»ä¼¼äºä¸€ç§è‡ªæˆ‘ç›‘ç£çš„è®­ç»ƒæ–¹å¼ * å…ˆåŠ å™ªå£°è®­ç»ƒï¼Œç„¶åé‡åˆ°ä¸€ä¸ªæœ‰å™ªå£°çš„å›¾ç‰‡ï¼Œç”¨è¿™ä¸ªæ¨¡å‹å°±å¯ä»¥å»å™ª * è¦ä½¿æ–‡å­—å¯ä»¥å½±å“ç”Ÿæˆçš„å›¾ç‰‡ï¼Œåªè¦åœ¨æ¯æ¬¡è®­ç»ƒçš„æ—¶å€™è®°å½•å³å¯ Stable Diffusion æ–‡å­—ç”Ÿæˆçš„ä¸€ä¸ªä¸ªå‘é‡ï¼Œé€šè¿‡æ¶ˆå»GenerationModeläº§ç”Ÿçš„ä¸€ä¸ªçŸ©é˜µï¼Œç”Ÿæˆä¸€ä¸ªâ€œä¸€ä¸ªä¸­é—´äº§ç‰©â€ï¼ˆå›¾ç‰‡çš„å‹ç¼©ç‰ˆæœ¬ï¼‰ï¼Œå³äº§ç”Ÿæœ€åçš„Decoderï¼Œè¿˜åŸæˆåŸæ¥çš„å›¾ç‰‡ã€‚ä¾‹å¦‚ï¼šStable Diffusionã€DALL-E seriesã€Imagen Encodeè¶Šæ¥è¶Šå¤§ï¼ˆå¥½çš„æ–‡å­—çš„Encoderï¼‰ï¼Œå›¾ç‰‡çš„ç”Ÿæˆç»“æœè¶Šå¥½ï¼ˆå¯¹æ–‡å­—çš„ç†è§£æ›´å¥½ï¼‰ å¢å¤§DiffusionModelå¯¹ç”Ÿæˆå›¾åƒçš„æ•ˆæœæ˜¯æœ‰é™çš„ Frechet Inception Distanceï¼ˆFIDï¼‰ ä¸€ç§åˆ¤æ–­å›¾åƒç”Ÿæˆæ•ˆæœçš„å‚æ•°ï¼šå‡è®¾çœŸæ­£çš„å›¾åƒå’Œç”Ÿæˆçš„å›¾åƒæ»¡è¶³é«˜æ–¯åˆ†å¸ƒï¼Œè®¡ç®—å®ƒä»¬ä¹‹é—´çš„Frechet Distance. Smaller is better ç¼ºç‚¹ï¼šéœ€è¦å¤§é‡çš„æ ·æœ¬ï¼ˆsampleï¼‰ æ³¨è§£ï¼šå„ä¸ªå›¾ç‰‡ï¼ˆä¸€å¼ å›¾ç‰‡æ˜¯ä¸€ä¸ªé«˜ç»´åº¦å‘é‡ï¼‰ï¼Œä»»å–ä¸€ä¸ªç»´åº¦æ¥ç»Ÿè®¡åˆ†æï¼Œå‘ç°ç»å¸¸æ˜¯é«˜æ–¯åˆ†å¸ƒ Contrastive Language-Image Pre-Training(CLIP) ä¸€ä¸ªå¯¹æ¯”æ–‡å­—å’Œå›¾åƒåŒ¹é…åº¦çš„æ¨¡å‹ Encoderå’ŒDecoder Encoderä¸éœ€è¦æ–‡å­—å½“ä½œè¾“å…¥ï¼Œè€Œæ˜¯å‘é‡å½¢å¼å°±å¯ä»¥è®­ç»ƒ ä¸­é—´äº§ç‰©ä¸º[Latent Representation](ï¼Ÿéšè¡¨ç¤º) å…ˆEncoderä¸ºLatent Representationå†è®­ç»ƒæ¨¡å‹ ç”Ÿæˆå›¾åƒä½¿å…ˆä¸€æ­¥æ­¥ç»™Latent Representation Denoiseï¼Œæœ€åä¸¢ç»™Decoderå°±å¯ä»¥ç”Ÿå›¾äº†ã€‚ Encoderæ˜¯æ–‡å­—åˆ°å‹ç¼©å›¾ç‰‡ï¼ŒDecoderæ˜¯å‹ç¼©å›¾ç‰‡åˆ°é«˜æ¸…å›¾ç‰‡ Diffusion ModelèƒŒåçš„æ•°å­¦åŸç† VAE vs. Diffusion Model Training x0:sample clean image å‡åŒ€åˆ†å¸ƒ Uniform â¡ ( { 1 , â€¦ , T } ) ï¼šUniform({1,â€¦,T}) è¡¨ç¤º t å¯ä»¥å–è‡ªé›†åˆ{1,2,â€¦,T} ä¸­çš„ä»»ä½•ä¸€ä¸ªå€¼ e:sample noise åŠ æƒæ±‚å’Œ:tè¶Šå¤§ï¼Œå™ªå£°åŠ çš„è¶Šå‡¶ç‹ ,æœ€ç»ˆå¾—åˆ°Noisy image å°†sample eå’Œè®¡ç®—å‡ºæ¥çš„Noise predictorä½œå·® å®é™…ä¸Šæ˜¯ç»™äºˆä¸€ä¸ªæƒå€¼ç›´æ¥æ·»åŠ noiseï¼Œå¾—åˆ°noiseï¼Œè®­ç»ƒå’Œç”Ÿæˆéƒ½æ˜¯ä¸€æ ·çš„ Sampling xT : sample a noise å¾ªç¯ç”Ÿæˆzï¼ˆsample a noiseï¼‰","categories":[],"tags":[{"name":"æ·±åº¦å­¦ä¹ ","slug":"æ·±åº¦å­¦ä¹ ","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"author":"tugumineko"},{"title":"æ­£åˆ™è¡¨è¾¾å¼","slug":"æ­£åˆ™è¡¨è¾¾å¼","date":"2024-05-25T07:25:49.000Z","updated":"2024-05-27T04:37:23.673Z","comments":true,"path":"2024/05/25/æ­£åˆ™è¡¨è¾¾å¼/","permalink":"http://example.com/2024/05/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"å®šä½ ^ :åŒ¹é…è¡Œé¦–æˆ–æ­£åˆ™è¡¨è¾¾å¼æœç´¢çš„å­—ç¬¦ä¸²çš„å¼€å¤´ $ :åŒ¹é…è¡Œå°¾æˆ–æ­£åˆ™è¡¨è¾¾å¼æœç´¢çš„å­—ç¬¦ä¸²çš„æœ«å°¾ å…ƒå­—ç¬¦ . :åŒ¹é…é™¤æ–°è¡Œä»¥å¤–çš„ä»»æ„å•ä¸ªå­—ç¬¦ | :è¡¨ç¤ºå¤‡é€‰é¡¹ï¼Œå³â€œæˆ–â€ \\ :è¡¨ç¤ºä¸‹ä¸€ä¸ªæ˜¯æ–‡å­—å­—ç¬¦ï¼Œè€Œéç‰¹æ®Šå­—ç¬¦ å­—ç¬¦ç±» [â€¦] :åŒ¹é…æŸä¸€å­—ç¬¦é›†ä¸­çš„ä»»æ„å­—ç¬¦ã€‚åœ¨å­—ç¬¦é›†ä¸­å¯ä½¿ç”¨çŸ­åˆ’çº¿åˆ†éš”ç¬¬ä¸€ä¸ªå­—ç¬¦å’Œæœ€åä¸€ä¸ªå­—ç¬¦ [^â€¦] :åŒ¹é…æŸä¸€å­—ç¬¦é›†ä»¥å¤–çš„ä»»æ„å­—ç¬¦ å†…å®¹åˆè§„æ€§æ”¿ç­–ä¸­çš„æ­£åˆ™è¡¨è¾¾å¼åŒºåˆ†å¤§å°å†™ [:alnum:] :åŒ¹é…å­—æ¯æˆ–æ•°å­—ï¼ša-z|A-Z|0-9 [:alpha:] :åŒ¹é…å­—æ¯ï¼ša-z|A-Z [:digit:] :åŒ¹é…æ•°å­—ï¼š0-9 [:graph:] :ä»…åŒ¹é…å¯è§å­—ç¬¦ï¼Œå³ç©ºæ ¼ã€æ§åˆ¶ç¬¦ç­‰ä»¥å¤–çš„æ‰€æœ‰å­—ç¬¦ [:punct:] :åŒ¹é…æ ‡ç‚¹å­—ç¬¦å’Œç¬¦å·ï¼š! &quot; # $ % &amp; â€™ ( ) * + , \\ -. / : ; &lt; = &gt; ? @ [ ] ^ _ ` { | } [:print:] :åŒ¹é…å¯è§å­—ç¬¦å’Œç©ºæ ¼ [:space:] :åŒ¹é…ä»»æ„ç©ºç™½å­—ç¬¦ï¼ŒåŒ…æ‹¬ç©ºæ ¼ã€åˆ¶è¡¨ç¬¦å’Œæ¢è¡Œç¬¦ [:word:] :åŒ¹é…ä»»æ„å­—è¯å­—ç¬¦ï¼Œå³ä»»æ„å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿ï¼ša-z|A-Z|0-9|_ åœ¨æ­£åˆ™è¡¨è¾¾å¼ä¸­ä½¿ç”¨æ­¤å­—ç¬¦ç±»æ—¶ï¼Œå¿…é¡»å°†å…¶ä»¥å¦å¤–ä¸€ç»„æ–¹æ‹¬å·æ‹¬èµ· ç¼©ç•¥å­—ç¬¦ç±» \\w :å’Œ[:word:]ä½œç”¨ç›¸åŒ \\W :å’Œ[^[:word:]]ä½œç”¨ç›¸åŒ \\s :å’Œ[:space:]ä½œç”¨ç›¸åŒ \\S :å’Œ[^[:space:]]ä½œç”¨ç›¸åŒ \\d :å’Œ[:digit:]ä½œç”¨ç›¸åŒ \\D :å’Œ[^[:digit:]]ä½œç”¨ç›¸åŒ åˆ†ç»„ (â€¦) å°†è¡¨è¾¾å¼çš„ä¸åŒéƒ¨åˆ†å½’å…¥ä¸åŒçš„åˆ†ç»„ã€‚åˆ©ç”¨åˆ†ç»„ï¼Œæ‚¨å¯ä»¥ä¸ºæŸä¸ªåˆ†ç»„åˆ†é…ä¸€ä¸ªç¼–å·ï¼Œä¹Ÿå¯ä»¥åœ¨æŸä¸ªåˆ†ç»„çš„å‰ååŒ¹é…å­—ç¬¦ç±»ã€‚ æ•°é‡ {n} ï¼šå‡†ç¡®åŒ¹é…å‰ä¸€ä¸ªè¡¨è¾¾å¼nnnæ¬¡ {n,m} :åŒ¹é…å‰ä¸€ä¸ªè¡¨è¾¾å¼æœ€å°‘nnnæ¬¡ï¼Œæœ€å¤šmmmæ¬¡ ? :è¡¨ç¤ºå‰ä¸€ä¸ªå­—ç¬¦æˆ–è¡¨è¾¾å¼å¯ä»¥åŒ¹é…0æ¬¡æˆ–1æ¬¡ï¼ˆæˆä¸ºå¯é€‰é¡¹ï¼‰ * :åŒ¹é…ä¸Šä¸€ä¸ªå…ƒç´ 0æ¬¡æˆ–å¤šæ¬¡ + :åŒ¹é…ä¸Šä¸€ä¸ªå…ƒç´ ä¸€æ¬¡ å¥½äº†ï¼Œä½ å·²ç»æŒæ¡äº†æ‰€æœ‰æ­£åˆ™è¡¨è¾¾å¼çš„åŸºæœ¬æ“ä½œäº†ã€‚å¿«æ¥åšä¸€äº›ç®€å•çš„ç»ƒä¹ å§ï¼","categories":[],"tags":[{"name":"è¯­æ³•","slug":"è¯­æ³•","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"}],"author":"tugumineko"},{"title":"vim-syntax","slug":"vim-syntax","date":"2024-05-23T11:44:41.000Z","updated":"2024-05-28T12:39:50.676Z","comments":true,"path":"2024/05/23/vim-syntax/","permalink":"http://example.com/2024/05/23/vim-syntax/","excerpt":"","text":"VIMTUTOR Lesson 1 SUMMARY The cursor is moved using either the arrow keys or the hjkl keys. h (left) j (down) k (up) l (right) To start Vim from the shell prompt type: vim FILENAME &lt;ENTER&gt; To exit Vim type: &lt;ESC&gt; :q! &lt;ENTER&gt; to trash all changes. OR type: &lt;ESC&gt; :wq &lt;ENTER&gt; to save the changes. To delete the character at the cursor type: x To insert or append text type: i type inserted text &lt;ESC&gt; insert before the cursor A type appended text &lt;ESC&gt; append after the line NOTE: Pressing &lt;ESC&gt; will place you in Normal mode or will cancel an unwanted and partially completed command. Lesson 2 SUMMARY To delete from the cursor up to the next word type: dw To delete from the cursor to the end of a line type: d$ To delete a whole line type: dd To repeat a motion prepend it with a number: 2w The format for a change command is: operator [number] motion where: operator - is what to do, such as d for delete [number] - is an optional count to repeat the motion motion - moves over the text to operate on, such as w (word), $ (to the end of line), etc. To move to the start of the line use a zero: 0 To undo previous actions, type: u (lowercase u) To undo all the changes on a line, type: U (capital U) To undo the undoâ€™s, type: CTRL-R Lesson 3 SUMMARY To put back text that has just been deleted, type p . This puts the deleted text AFTER the cursor (if a line was deleted it will go on the line below the cursor). To replace the character under the cursor, type r and then the character you want to have there. The change operator allows you to change from the cursor to where the motion takes you. eg. Type ce to change from the cursor to the end of the word, c$ to change to the end of a line. The format for change is: c [number] motion Lesson 4 SUMMARY CTRL-G displays your location in the file and the file status. G moves to the end of the file. number G moves to that line number. gg moves to the first line. Typing / followed by a phrase searches FORWARD for the phrase. Typing ? followed by a phrase searches BACKWARD for the phrase. After a search type n to find the next occurrence in the same direction or N to search in the opposite direction. CTRL-O takes you back to older positions, CTRL-I to newer positions. Typing % while the cursor is on a (,),[,],{, or } goes to its match. To substitute new for the first old in a line type :s/old/new To substitute new for all 'oldâ€™s on a line type :s/old/new/g To substitute phrases between two line #'s type :#,#s/old/new/g To substitute all occurrences in the file type :%s/old/new/g To ask for confirmation each time add â€˜câ€™ :%s/old/new/gc Lesson 5 SUMMARY :!command executes an external command. Some useful examples are: (MS-DOS) (Unix) :!dir :!ls - shows a directory listing. :!del FILENAME :!rm FILENAME - removes file FILENAME. :w FILENAME writes the current Vim file to disk with name FILENAME. v motion :w FILENAME saves the Visually selected lines in file FILENAME. :r FILENAME retrieves disk file FILENAME and puts it below the cursor position. :r !dir reads the output of the dir command and puts it below the cursor position. Lesson 6 SUMMARY Type o to open a line BELOW the cursor and start Insert mode. Type O to open a line ABOVE the cursor. Type a to insert text AFTER the cursor. Type A to insert text after the end of the line. The e command moves to the end of a word. The y operator yanks (copies) text, p puts (pastes) it. Typing a capital R enters Replace mode until &lt;ESC&gt; is pressed. Typing â€œ:set xxxâ€ sets the option â€œxxxâ€. Some options are: â€˜icâ€™ â€˜ignorecaseâ€™ ignore upper/lower case when searching â€˜isâ€™ â€˜incsearchâ€™ show partial matches for a search phrase â€˜hlsâ€™ â€˜hlsearchâ€™ highlight all matching phrases You can either use the long or the short option name. Prepend â€œnoâ€ to switch an option off: :set noic Lesson 7 SUMMARY Type :help or press &lt;F1&gt; or &lt;Help&gt; to open a help window. Type :help cmd to find help on cmd . Type CTRL-W CTRL-W to jump to another window Type :q to close the help window Create a vimrc startup script to keep your preferred settings. When typing a : command, press CTRL-D to see possible completions. Press &lt;TAB&gt; to use one completion. VIMRC &quot; Comments in Vimscript start with a `&quot;`. &quot; If you open this file in Vim, itâ€™ll be syntax highlighted for you. &quot; Vim is based on Vi. Setting `nocompatible` switches from the default &quot; Vi-compatibility mode and enables useful Vim functionality. This &quot; configuration option turns out not to be necessary for the file named &quot; â€˜~/.vimrcâ€™, because Vim automatically enters nocompatible mode if that file &quot; is present. But weâ€™re including it here just in case this config file is &quot; loaded some other way (e.g. saved as `foo`, and then Vim started with &quot; `vim -u foo`). set nocompatible &quot; Turn on syntax highlighting. syntax on &quot; Disable the default Vim startup message. set shortmess+=I &quot; Show line numbers. set number &quot; This enables relative line numbering mode. With both number and &quot; relativenumber enabled, the current line shows the true line number, while &quot; all other lines (above and below) are numbered relative to the current line. &quot; This is useful because you can tell, at a glance, what count is needed to &quot; jump up or down to a particular line, by {count}k to go up or {count}j to go &quot; down. set relativenumber &quot; Always show the status line at the bottom, even if you only have one window open. set laststatus=2 &quot; The backspace key has slightly unintuitive behavior by default. For example, &quot; by default, you canâ€™t backspace before the insertion point set with â€˜iâ€™. &quot; This configuration makes backspace behave more reasonably, in that you can &quot; backspace over anything. set backspace=indent,eol,start &quot; By default, Vim doesnâ€™t let you hide a buffer (i.e. have a buffer that isnâ€™t &quot; shown in any window) that has unsaved changes. This is to prevent you from &quot; &quot; forgetting about unsaved changes and then quitting e.g. via :qa!. We find &quot; hidden buffers helpful enough to disable this protection. See :help hidden &quot; for more information on this. set hidden &quot; This setting makes search case-insensitive when all characters in the string &quot; being searched are lowercase. However, the search becomes case-sensitive if &quot; it contains any capital letters. This makes searching more convenient. set ignorecase set smartcase &quot; Enable searching as you type, rather than waiting till you press enter. set incsearch &quot; Unbind some useless/annoying default key bindings. nmap Q &lt;Nop&gt; &quot; â€˜Qâ€™ in normal mode enters Ex\\ mode. You almost never want this. &quot; Disable audible bell because itâ€™s annoying. set noerrorbells visualbell t_vb= &quot; Enable mouse support. You should avoid relying on this too much, but it can &quot; sometimes be convenient. set mouse+=a &quot; Try to prevent bad habits like using the arrow keys for movement. This is &quot; not the only possible bad habit. For example, holding down the h/j/k/l keys &quot; for movement, rather than using more efficient movement commands, is also a &quot; bad habit. The former is enforceable through a .vimrc, while we donâ€™t know &quot; how to prevent the latter. &quot; Do this in normal modeâ€¦ nnoremap &lt;Left&gt; :echoe &quot;Use h&quot;&lt;CR&gt; nnoremap &lt;Right&gt; :echoe &quot;Use l&quot;&lt;CR&gt; nnoremap &lt;Up&gt; :echoe &quot;Use k&quot;&lt;CR&gt; nnoremap &lt;Down&gt; :echoe &quot;Use j&quot;&lt;CR&gt; &quot; â€¦and in insert mode inoremap &lt;Left&gt; &lt;ESC&gt;:echoe &quot;Use h&quot;&lt;CR&gt; inoremap &lt;Right&gt; &lt;ESC&gt;:echoe &quot;Use l&quot;&lt;CR&gt; inoremap &lt;Up&gt; &lt;ESC&gt;:echoe &quot;Use k&quot;&lt;CR&gt; inoremap &lt;Down&gt; &lt;ESC&gt;:echoe &quot;Use j&quot;&lt;CR&gt; Vimè¿›é˜¶ æœç´¢å’Œæ›¿æ¢ :s(æ›¿æ¢å‘½ä»¤) %s/foo/bar/g - åœ¨æ•´ä¸ªæ–‡ä»¶ä¸­å°†fooå…¨å±€æ›¿æ¢æˆbar %s/\\[.*\\](\\(.*\\))/\\1/g - å°†æœ‰å‘½åçš„MarkdownMarkdownMarkdowné“¾æ¥æ›¿æ¢æˆç®€å•URLsURLsURLs å¤šçª—å£ ç”¨:sp/:vspæ¥åˆ†å‰²çª—å£ åŒä¸€ä¸ªç¼“å­˜å¯ä»¥åœ¨å¤šä¸ªçª—å£ä¸­æ˜¾ç¤º ç”¨&lt;c-w&gt;+(hjkl)åˆ‡æ¢çª—å£ å® q&#123;å­—ç¬¦&#125;æ¥å¼€å§‹åœ¨å¯„å­˜å™¨&#123;å­—ç¬¦&#125;ä¸­å½•åˆ¶å® qåœæ­¢å½•åˆ¶ @&#123;å­—ç¬¦&#125;é‡æ”¾å® å®çš„æ‰§è¡Œé”™è¯¯ä¼šåœæ­¢ &#123;è®¡æ•°&#125;@&#123;å­—ç¬¦&#125;æ‰§è¡Œä¸€ä¸ªå®{è®¡æ•°}æ¬¡ å®å¯ä»¥é€’å½’ é¦–å…ˆç”¨q&#123;å­—ç¬¦&#125;qæ¸…é™¤å® å½•åˆ¶è¯¥å®ï¼Œç”¨@&#123;å­—ç¬¦&#125;æ¥é€’å½’è°ƒç”¨è¯¥å®ï¼ˆåœ¨å½•åˆ¶å®Œæˆä¹‹å‰ä¸ä¼šæœ‰ä»»ä½•æ“ä½œï¼‰","categories":[{"name":"vim","slug":"vim","permalink":"http://example.com/categories/vim/"}],"tags":[{"name":"è¯­æ³•","slug":"è¯­æ³•","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"},{"name":"æ–‡æœ¬ç¼–è¾‘å™¨","slug":"æ–‡æœ¬ç¼–è¾‘å™¨","permalink":"http://example.com/tags/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"}],"author":"tugumineko"},{"title":"ç”Ÿæ´»åœ¨æ ‘ä¸Š","slug":"ç”Ÿæ´»åœ¨æ ‘ä¸Š","date":"2024-05-19T04:43:48.000Z","updated":"2024-05-28T15:32:43.032Z","comments":true,"path":"2024/05/19/ç”Ÿæ´»åœ¨æ ‘ä¸Š/","permalink":"http://example.com/2024/05/19/%E7%94%9F%E6%B4%BB%E5%9C%A8%E6%A0%91%E4%B8%8A/","excerpt":"","text":"äºŒå‰æœç´¢æ ‘ Treapæ ‘ æ¯ä¸ªç»“ç‚¹æœ‰2ä¸ªå€¼ é”®å€¼ï¼švalue ä¼˜å…ˆçº§ï¼špriority valueè¦æ»¡è¶³BSTçš„åŸºæœ¬æ€§è´¨ï¼Œpriorityç”¨äºæ»¡è¶³å †çš„æ€§è´¨ï¼Œç”¨æ¥å®ç°äºŒå‰æ ‘çš„å¹³è¡¡ Treapé€šè¿‡éšæœºåŒ–çš„priorityå±æ€§,ä»¥åŠç»´æŠ¤å †æ€§è´¨çš„è¿‡ç¨‹ï¼Œ[æ‰“ä¹±]äº†ç»“ç‚¹çš„æ’å…¥é¡ºåºã€‚ä»è€Œè®©äºŒå‰æœç´¢æ ‘è¾¾åˆ°äº†ç†æƒ³çš„å¤æ‚åº¦ï¼Œé¿å…äº†é€€åŒ–æˆé“¾çš„é—®é¢˜ åˆ©ç”¨Treapå¯ä»¥å®ç°ä¸€ä¸ªåæ¬¡æ ‘è€Œä¸”æ¯”çº¢é»‘æ ‘å¥½å†™å¾ˆå¤šï¼Œåœ¨ç®—æ³•ç«èµ›ä¸­å¾ˆå¸¸ç”¨ ç»“ç‚¹ç»“æ„ 1234567891011121314151617struct Node &#123; Node *ch[2];// ch[0]å·¦æ ‘çš„æŒ‡é’ˆï¼Œch[1]å³æ ‘çš„æŒ‡é’ˆ int val, rank; int rep_cnt;// valå‡ºç°çš„æ¬¡æ•° int siz;// ç»“ç‚¹æ ‘çš„å¤§å° Node(int val) : val(val), rep_cnt(1), siz(1) &#123; ch[0] = ch[1] = nullptr; rank = rand(); &#125; void upd_siz() &#123; siz = rep_cnt; if (ch[0] != nullptr) siz += ch[0]-&gt;siz; if (ch[1] != nullptr) siz += ch[1]-&gt;siz; &#125;&#125;; æ—‹è½¬ æ—‹è½¬æ“ä½œçš„å«ä¹‰ï¼š åœ¨ä¸å½±å“æœç´¢æ ‘çš„æ€§è´¨çš„å‰æä¸‹ï¼ŒæŠŠå’Œæ—‹è½¬æ–¹å‘ç›¸åçš„å­æ ‘å˜æˆæ ¹ç»“ç‚¹ã€‚ å°†æ–°çš„æ ¹ç»“ç‚¹çš„å­æ ‘å˜ä¸ºæ—§æ ¹ç»“ç‚¹çš„å­æ ‘ è¿™é‡Œä½¿ç”¨ä¸€ä¸ªtempå­˜æ–°çš„æ ¹ç»“ç‚¹ï¼Œå¹¶ä¸”æœ€åè¦æ›´æ”¹å¼•ç”¨ 123456789enum rot_type &#123; LF = 1, RT = 0 &#125;;void _rotate(Node *&amp;cur, rot_type dir) &#123; Node *tmp = cur-&gt;ch[dir];// æŠŠå’Œæ—‹è½¬æ–¹å‘ç›¸åçš„å­ç»“ç‚¹å˜æˆæ ¹ç»“ç‚¹ cur-&gt;ch[dir] = tmp-&gt;ch[!dir];// å°†æ–°çš„æ ¹ç»“ç‚¹çš„å­æ ‘å˜ä¸ºæ—§æ ¹ç»“ç‚¹çš„å­æ ‘ tmp-&gt;ch[!dir] = cur;// æ–°å­æ ‘æ”¾åˆ°ä¸æ—‹è½¬ç›¸åŒæ–¹å‘çš„æ ¹ç»“ç‚¹ï¼Œä»è€Œå®Œæˆæ—‹è½¬æ“ä½œ cur-&gt;upd_siz(), tmp-&gt;upd_siz(); cur = tmp;&#125; æ’å…¥ æ’çš„è¿‡ç¨‹ä¸­é€šè¿‡æ—‹è½¬æ¥ç»´æŠ¤æ ‘å †ä¸­å †çš„æ€§è´¨,æ—‹è½¬å®Œæˆåè¦æ›´æ–°ç»“ç‚¹å¤§å° 1234567891011121314151617181920212223void _insert(Node *&amp;cur, int val) &#123; if (cur == nullptr) &#123; cur = new Node(val); return; &#125; else if (val == cur-&gt;val) &#123; cur-&gt;rep_cnt++; cur-&gt;siz++; &#125; else if (val &lt; cur-&gt;val) &#123; _insert(cur-&gt;ch[0], val); if (cur-&gt;ch[0]-&gt;rank &lt; cur-&gt;rank) &#123; // åˆ©ç”¨rankç»´æŠ¤å°æ ¹å †æ€§è´¨ _rotate(cur, RT);// è¦æŠŠå·¦ç»“ç‚¹è½¬ä¸Šæ¥ï¼Œéœ€è¦å³æ—‹ &#125; cur-&gt;upd_siz(); &#125; else &#123; _insert(cur-&gt;ch[1], val); if (cur-&gt;ch[1]-&gt;rank &lt; cur-&gt;rank) &#123; _rotate(cur, LF); &#125; cur-&gt;upd_siz(); &#125;&#125; åˆ é™¤ æ³¨æ„æ›´æ–°ç»“ç‚¹å¤§å°ï¼Œæ€è·¯å’Œæ’å…¥å·®ä¸å¤š 123456789101112131415161718192021222324252627282930313233343536373839void _del(Node *&amp;cur, int val) &#123; // æ¯æ¬¡é€’å½’éƒ½è¦é‡æ–°æ›´æ–°size if (val &gt; cur-&gt;val) &#123; _del(cur-&gt;ch[1], val); cur-&gt;upd_siz(); &#125; else if (val &lt; cur-&gt;val) &#123; _del(cur-&gt;ch[0], val); cur-&gt;upd_siz(); &#125; else &#123; if (cur-&gt;rep_cnt &gt; 1) &#123; cur-&gt;rep_cnt--, cur-&gt;siz--; return; &#125; uint8_t state = 0; state |= (cur-&gt;ch[0] != nullptr); state |= ((cur-&gt;ch[1] != nullptr) &lt;&lt; 1); Node *tmp = cur; switch (state) &#123; case 0: delete cur; cur = nullptr; break; case 1: cur = tmp-&gt;ch[0]; delete tmp; break; case 2: cur = tmp-&gt;ch[1]; delete tmp; break; case 3: rot_type dir = cur-&gt;ch[0]-&gt;rank &lt; cur-&gt;ch[1]-&gt;rank ? RT : LF;// æŠŠä¼˜å…ˆçº§æ›´å°çš„å„¿å­è½¬ä¸Šå» _rotate(cur, dir); _del(cur-&gt;ch[!dir], val);// æ—‹è½¬å®Œæˆååˆ é™¤æ—§èŠ‚ç‚¹(ä½äºæ ¹èŠ‚ç‚¹çš„æ—‹è½¬æ–¹å‘çš„å­èŠ‚ç‚¹) cur-&gt;upd_siz(); break; &#125; &#125;&#125; æ ¹æ®å€¼æŸ¥è¯¢æ’å æŸ¥è¯¢ä»¥ cur ä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘ä¸­ï¼Œval è¿™ä¸ªå€¼çš„å¤§å°çš„æ’åï¼ˆè¯¥å­æ ‘ä¸­å°äº val çš„èŠ‚ç‚¹çš„ä¸ªæ•° + 1ï¼‰ 1234567891011121314151617181920int _query_rank(Node* cur, int val) &#123; int less_siz = cur-&gt;ch[0] == nullptr ? 0 : cur-&gt;ch[0]-&gt;siz; // åœ¨BSTä¸­ï¼Œå·¦å„¿å­æ¯”çˆ¶èŠ‚ç‚¹å° if (cur-&gt;val == val) return less_siz + 1; else if (cur-&gt;val &gt; val) &#123; if (cur-&gt;ch[0] != nullptr) return _query_rank(cur-&gt;ch[0], val); else return 1; // æ²¡æœ‰æ¯”å®ƒå°çš„äº† &#125; else &#123; if (cur-&gt;ch[1] != nullptr) // å¦‚æœè¦æŸ¥çš„å€¼æ¯”è¿™ä¸ªèŠ‚ç‚¹å¤§ï¼Œé‚£è¿™ä¸ªèŠ‚ç‚¹çš„å·¦å­æ ‘ä»¥åŠè¿™ä¸ªèŠ‚ç‚¹è‡ªèº«è‚¯å®šéƒ½æ¯”è¦æŸ¥çš„å€¼å° // æ‰€ä»¥è¦åŠ ä¸Šè¿™ä¸¤ä¸ªå€¼ï¼Œå†åŠ ä¸Šå¾€å³è¾¹æ‰¾çš„ç»“æœ // ï¼ˆä»¥å³å­æ ‘ä¸ºæ ¹çš„å­æ ‘ä¸­ï¼Œval è¿™ä¸ªå€¼çš„å¤§å°çš„æ’åï¼‰ return less_siz + cur-&gt;cnt + _query_rank(cur-&gt;ch[1], val); else return cur-&gt;siz + 1; // æ²¡æœ‰å³å­æ ‘ &#125;&#125; æ ¹æ®æ’åæŸ¥è¯¢å€¼ ç›´æ¥é€’å½’ï¼Œå’ŒBSTæœç´¢çš„å†™æ³•å·®ä¸å¤š æ’å&lt;=å·¦å­æ ‘çš„å¤§å°ï¼Œåˆ™æœç´¢å·¦å­æ ‘ æ’å&gt;=å·¦å­æ ‘çš„å¤§å° + æ ¹ç»“ç‚¹çš„é‡å¤æ¬¡æ•°ï¼Œåˆ™æœç´¢å³å­æ ‘ 123456789int _query_val(Node *cur, int rank) &#123; int less_siz = cur-&gt;ch[0] == nullptr ? 0 : cur-&gt;ch[0]-&gt;siz; if (rank &lt;= less_siz) return _query_val(cur-&gt;ch[0], rank); else if (rank &lt;= less_siz + cur-&gt;rep_cnt) return cur-&gt;val; else return _query_val(cur-&gt;ch[1], rank - less_siz - cur-&gt;rep_cnt);&#125; æŸ¥è¯¢ç¬¬ä¸€ä¸ªæ¯” val å°çš„èŠ‚ç‚¹ å…¨å±€å˜é‡ï¼Œq_prev_tmp æ˜¯åªæœ‰åœ¨ val æ¯”å½“å‰èŠ‚ç‚¹å€¼å¤§çš„æ—¶å€™æ‰ä¼šè¢«æ›´æ”¹çš„ï¼Œæ‰€ä»¥è¿”å›è¿™ä¸ªå˜é‡å°±æ˜¯è¿”å› val æœ€åä¸€æ¬¡æ¯”å½“å‰èŠ‚ç‚¹çš„å€¼å¤§ï¼Œä¹‹åå°±æ˜¯æ›´å°äº† 12345678910111213141516int _query_prev(Node *cur, int val) &#123; if (val &lt;= cur-&gt;val) &#123; // å¾€å·¦å­æ ‘æ‰¾ if (cur-&gt;ch[0] != nullptr) return _query_prev(cur-&gt;ch[0], val); &#125; else &#123; // åªæœ‰èƒ½è¿›åˆ°è¿™ä¸ª else é‡Œï¼Œæ‰ä¼šæ›´æ–° q_prev_tmp çš„å€¼ q_prev_tmp = cur-&gt;val; // å› ä¸ºè¦ç¡®å®šæœ€å¤§çš„ï¼Œæ‰€ä»¥è¦åˆ°å³å­æ ‘ç»§ç»­æ‰¾ if (cur-&gt;ch[1] != nullptr) _query_prev(cur-&gt;ch[1], val); // æ¥ä¸‹æ¥çš„é€’å½’å¯èƒ½ä¸ä¼šæ›´æ”¹ q_prev_tmp // äº†ï¼Œé‚£å°±ç›´æ¥è¿”å›æœ€åä¸€æ¬¡è¿›åˆ° è¿™ä¸ª else ä¸­çš„ // cur-&gt;val return q_prev_tmp; &#125; return -1;&#125; æŸ¥è¯¢ç¬¬ä¸€ä¸ªæ¯” val å¤§çš„èŠ‚ç‚¹ 12345678910int _query_nex(Node *cur, int val) &#123; if (val &gt;= cur-&gt;val) &#123; if (cur-&gt;ch[1] != nullptr) return _query_nex(cur-&gt;ch[1], val); &#125; else &#123; q_nex_tmp = cur-&gt;val; if (cur-&gt;ch[0] != nullptr) _query_nex(cur-&gt;ch[0], val); return q_nex_tmp; &#125; return -1;&#125; Splayæ ‘ ç†è®º é€šå¸¸åœ¨ä»»æ„æ•°æ®ç»“æ„çš„ç”Ÿå‘½æœŸå†…ï¼Œä¸ä»…æ‰§è¡Œä¸åŒæ“ä½œçš„æ¦‚ç‡å¾€å¾€æä¸å‡è¡¡ï¼Œè€Œä¸”å„æ“ä½œä¹‹é—´å…·æœ‰æå¼ºçš„å…³è”æ€§ï¼Œå¹¶åœ¨æ•´ä½“ä¸Šå¤šå‘ˆç°å‡ºæå¼ºçš„è§„å¾‹æ€§ã€‚å…¶ä¸­æœ€ä¸ºå…¸å‹çš„ï¼Œå°±æ˜¯æ‰€è°“çš„â€œæ•°æ®å±€éƒ¨æ€§â€ï¼Œå³ï¼š (1) åˆšåˆšè¢«è®¿é—®è¿‡çš„å…ƒç´ ï¼Œææœ‰å¯èƒ½åœ¨ä¸ä¹…ä¹‹åå†æ¬¡è¢«è®¿é—®åˆ° (2) å°†è¢«è®¿é—®çš„ä¸‹ä¸€å…ƒç´ ï¼Œææœ‰å¯èƒ½å°±å¤„äºä¸ä¹…ä¹‹å‰è¢«è®¿é—®è¿‡çš„æŸä¸ªå…ƒç´ é™„è¿‘ å°±BSTè€Œè¨€ï¼Œæ•°æ®å±€éƒ¨æ€§å…·ä½“è¡¨ç°ä¸ºï¼š (1) åˆšåˆšè¢«è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œææœ‰å¯èƒ½åœ¨ä¸ä¹…çš„ä¹‹åè®¿é—®åˆ° (2) å°†è¢«è®¿é—®çš„ä¸‹ä¸€èŠ‚ç‚¹ï¼Œææœ‰å¯èƒ½å°±å¤„äºä¸ä¹…ä¹‹å‰è¢«è®¿é—®è¿‡çš„èŠ‚ç‚¹çš„é™„è¿‘ å› æ­¤ï¼Œåªéœ€å°†åˆšè¢«è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼ŒåŠæ—¶åœ°â€è½¬ç§»â€œè‡³æ ‘æ ¹ï¼ˆé™„è¿‘ï¼‰ï¼Œå³å¯åŠ é€Ÿåç»­çš„æ“ä½œã€‚Splayæ ‘åº”è¿è€Œç”Ÿ å¯¹æ¯”Splayå’ŒTreap: (1) Splayæ ‘å…è®¸æŠŠä»»æ„èŠ‚ç‚¹æ—‹è½¬åˆ°æ ¹ (2) éœ€è¦åˆ†è£‚å’Œåˆå¹¶æ—¶ï¼ŒSplayæ ‘çš„æ“ä½œéå¸¸ç®€ä¾¿ ç»“æ„ä¸æ“ä½œ æ¯ä¸€æ¬¡æŸ¥è¯¢åéƒ½è¦splay 123456789101112131415161718192021222324252627282930313233343536373839404142int root; // æ ¹èŠ‚ç‚¹int ch[N][2], fa[N]; // å­èŠ‚ç‚¹/çˆ¶èŠ‚ç‚¹int val[N]; // æƒå€¼int size[N]; // å­æ ‘å¤§å°int cnt[N]; // é‡å¤æ¬¡æ•°int tot; // èŠ‚ç‚¹ä¸ªæ•°struct Splay &#123; // ç»´æŠ¤å­æ ‘å¤§å° void maintain(int x); // æŸ¥æ‰¾è¿™ä¸ªèŠ‚ç‚¹æ˜¯çˆ¶äº²çš„å·¦å­æ ‘è¿˜æ˜¯å³å­æ ‘ bool get(int x); // é”€æ¯è¿™ä¸ªèŠ‚ç‚¹ void clear(int x); // æ—‹è½¬ void rotate(int x); // ä¼¸å±•æ“ä½œ void splay(int x); // æ’å…¥v void insert(int v); // æŸ¥è¯¢å€¼ä¸ºvçš„æ•°æ’å int find_rank(int v); // æŸ¥è¯¢æ’åä¸ºrçš„æ•° int find_val(int r); // æŸ¥è¯¢æ ¹èŠ‚ç‚¹çš„å‰é©± int pre(); // æŸ¥è¯¢æ ¹èŠ‚ç‚¹çš„åç»§ int next(); // åˆ é™¤ä¸€ä¸ªå€¼ä¸ºvalçš„æ•° void del(int v);&#125; tree; åŸºæœ¬æ“ä½œ 123456789101112void Splay::maintain(int x) &#123; size[x] = size[ch[x][0]] + size[ch[x][1]] + cnt[x];&#125;bool Splay::get(int x) &#123; // å·¦å„¿å­è¿”å›0.å³å„¿å­è¿”å›1 return x == ch[fa[x]][1];&#125;void Splay::clear(int x) &#123; ch[x][0]=ch[x][1]=fa[x]=val[x]=size[x]=cnt[x]=0;&#125; æ—‹è½¬ 1234567891011121314151617181920// èŠ‚ç‚¹xä¸Šå‡ä¸€ä½void Splay::rotate(int x) &#123; // å³å„¿å­çš„çˆ¶äº²å·¦ç§»ï¼Œå·¦å„¿å­çš„çˆ¶äº²å³ç§» // è®¾çˆ¶äº²ä¸ºyï¼Œç¥–çˆ¶ä¸ºz int dir = get(x); int y = fa[x], z = fa[y]; // å…ˆæ€çš‡å¸å†è®©å¤ªå­ç»§ä½ï¼Œç„¶åå†ä¾›å¥‰ç¥–å®—ç‰ŒåŒ¾ ch[y][dir] = ch[x][!dir]; if (ch[y][!dir]) fa[ch[x][!dir]] = y; ch[x][!dir] = y; fa[y] = x; fa[x] = z; if (z) ch[z][y == ch[z][1]] = x; // å…ˆç»´æŠ¤å„¿å­ï¼Œå†ç»´æŠ¤çˆ¶äº² maintain(y); maintain(x); &#125; ä¼¸å±• 12345678void Splay::splay(int x) &#123; // è®¾çˆ¶äº²ä¸ºy,ç¥–çˆ¶ä¸ºz // è‹¥å„¿å­ç§ç±»ç›¸åŒï¼Œåˆ™å…ˆè½¬ç¥–çˆ¶ï¼Œå†è½¬çˆ¶äº² // è‹¥å„¿å­ç§ç±»ä¸åŒï¼Œåˆ™å…ˆè½¬çˆ¶äº²ï¼Œå†è½¬ç¥–çˆ¶ for (int i = fa[x]; i = fa[x], i; rotate(x)) if (fa[f]) get(x) == get(i) ? rotate(i) : rotate(x); root = x;&#125; æ’å…¥ ä¾ç„¶æ˜¯ä¸‰ç§æƒ…å†µï¼š ç©ºæ ‘nullptr é‡å¤çš„å€¼ï¼Œç›´æ¥cnt++ç„¶åä¼¸å±• æ²¡æœ‰ï¼Œåˆ™æŒ‰ç…§BSTæ’å…¥åä¼¸å±• è¿™é‡Œæ•°ç»„çš„ä¸‹æ ‡ç”¨totæ ‡è®°ï¼Œå³å…ƒç´ çš„æ’å…¥é¡ºåº 123456789101112131415161718192021222324252627282930313233void Splay::insert(int v) &#123; if (!root) &#123; val[++tot] = val; cnt[tot] = size[tot] = 1; root = tot; return; &#125; else &#123; int cur = root, i = 0; while (1) &#123; if (val[cur] == v) &#123; cnt[cur]++; maintain(cur); maintain(i); splay(cur); return; &#125; i = cur; cur = ch[cur][val[cur] &lt; v]; if (cur == 0) &#123; tot++; val[tot] = v; cnt[tot]++; fa[tot] = i; ch[x][val[x] &lt; v] = tot; maintain(tot); maintain(x); splay(tot); return; &#125; &#125; &#125;&#125; æŸ¥è¯¢å€¼ä¸ºvçš„æ•°çš„æ’å ç»å…¸å›é¡¾ï¼š å¦‚æœ x æ¯”å½“å‰èŠ‚ç‚¹çš„æƒå€¼å°ï¼Œå‘å…¶å·¦å­æ ‘æŸ¥æ‰¾ã€‚ å¦‚æœ x æ¯”å½“å‰èŠ‚ç‚¹çš„æƒå€¼å¤§ï¼Œå°†ç­”æ¡ˆåŠ ä¸Šå·¦å­æ ‘ï¼ˆsizeï¼‰å’Œå½“å‰èŠ‚ç‚¹ï¼ˆcntï¼‰çš„å¤§å°ï¼Œå‘å…¶å³å­æ ‘æŸ¥æ‰¾ã€‚ å¦‚æœ x ä¸å½“å‰èŠ‚ç‚¹çš„æƒå€¼ç›¸åŒï¼Œå°†ç­”æ¡ˆåŠ  1 å¹¶è¿”å›ã€‚ æœ€åè¦è¿›è¡Œsplay 1234567891011121314151617int Splay::find_rank(int v) &#123; int ans = 0, cur = root; while (1) &#123; if (v &lt; val[cur]) cur = ch[cur][0]; else &#123; ans += size[ch[cur][0]]; if(!cur)return ans+1; if (v == val[cur]) &#123; splay(cur); return ans + 1; &#125; ans += cnt[cur]; cur = ch[cur][1]; &#125; &#125;&#125; æŸ¥è¯¢æ’åä¸ºrçš„æ•° ç»å…¸å›é¡¾ï¼š å¦‚æœå·¦å­æ ‘éç©ºä¸”å‰©ä½™æ’å r ä¸å¤§äºå·¦å­æ ‘çš„å¤§å° sizeï¼Œé‚£ä¹ˆå‘å·¦å­æ ‘æŸ¥æ‰¾ã€‚ å¦åˆ™å°† r å‡å»å·¦å­æ ‘çš„å’Œæ ¹çš„å¤§å°ã€‚å¦‚æœæ­¤æ—¶ r çš„å€¼å°äºç­‰äº 0ï¼Œåˆ™è¿”å›æ ¹èŠ‚ç‚¹çš„æƒå€¼ï¼Œå¦åˆ™ç»§ç»­å‘å³å­æ ‘æŸ¥æ‰¾ã€‚ 123456789101112131415int Splay::find_val(int r) &#123; int cur = root; while (1) &#123; if (ch[cur][0] != 0 &amp;&amp; r &lt;= size[ch[cur][0]]) cur = ch[cur][0]; else &#123; r -= cnt[cur] + size[ch[cur][0]]; if (r &lt;= 0) &#123; splay(cur); return val[cur]; &#125; cur = ch[cur][1]; &#125; &#125;&#125; æŸ¥è¯¢å‰é©± å‰é©±å®šä¹‰ä¸ºå°äº x çš„æœ€å¤§çš„æ•°ï¼Œé‚£ä¹ˆæŸ¥è¯¢å‰é©±å¯ä»¥è½¬åŒ–ä¸ºï¼šå°† x æ’å…¥ï¼ˆæ­¤æ—¶ x å·²ç»åœ¨æ ¹çš„ä½ç½®äº†ï¼‰ï¼Œå‰é©±å³ä¸º x çš„å·¦å­æ ‘ä¸­æœ€å³è¾¹çš„èŠ‚ç‚¹ï¼Œæœ€åå°† x åˆ é™¤å³å¯ã€‚ è¿™é‡Œæ’å…¥å’Œåˆ é™¤æ“ä½œè¯·è‡ªè¡Œæ·»åŠ  1234567891011int Splay::pre()&#123; int cur = ch[root][0]; if( cur == 0 ) return cur; while( ch[cur][1] ) cur = ch[cur][1]; splay(cur); return cur;&#125; æŸ¥è¯¢åç»§ è¿™é‡Œæ’å…¥å’Œåˆ é™¤æ“ä½œè¯·è‡ªè¡Œæ·»åŠ  1234567891011int Splay::next()&#123; int cur = ch[root][1]; if( cur == 0 ) return cur; while( ch[cur][0] ) cur = ch[cur][0]; splay(cur); return cur;&#125; åˆå¹¶ å¯¹äºåˆå¹¶ä¸¤æ£µæ ‘ï¼Œå…¶ä¸­ä¸€æ£µæ ‘çš„å€¼éƒ½å°äºå¦ä¸€æ£µæ ‘çš„å€¼ã€‚ æˆ‘ä»¬å¯ä»¥æ‰¾åˆ°è¾ƒå°ä¸€æ£µæ ‘çš„æœ€å¤§å€¼ x ï¼Œå°†å…¶æ—‹è½¬åˆ°æ ¹èŠ‚ç‚¹ã€‚ å†æŠŠè¾ƒå¤§ä¸€æ£µæ ‘ä½œä¸º x çš„å³å­æ ‘æ’å…¥ã€‚ åˆ é™¤ é¦–å…ˆå°† x è½¬ç§»åˆ°æ ¹èŠ‚ç‚¹ è‹¥ x å€¼ä¸åªä¸€ä¸ªï¼Œç›´æ¥cnt[x]â€“ å¦åˆ™å°†å®ƒçš„å·¦å³å­æ ‘åˆå¹¶ 1234567891011121314151617181920212223242526272829303132333435363738394041424344void Splay::del(int v)&#123; find_rank(v);//splay if(cnt[root]&gt;1)&#123; cnt[root]--; maintain(root); return; &#125; if((ch[root][0]==0)&amp;&amp;(ch[root][1]==0))&#123; clear(root); root = 0; return; &#125; if(ch[root][0]==0)&#123; int cur = root; root = ch[root][1]; fa[root]=0; clear(cur); return; &#125; if(ch[root][1]==0)&#123; int cur = root; root = ch[root][0]; fa[root]= 0; clear(cur); return; &#125; int cur = root; int x = pre();//splay //merge fa[ch[cur][1]] = x; ch[x][1] = ch[cur][1]; clear(cur); maintain(root); return;&#125; åºåˆ—æ“ä½œ æŒ‰ç…§åºåˆ—å»ºæˆçš„Splayæœ‰ä»¥ä¸‹æ€§è´¨: Splayçš„ä¸­åºéå†ç›¸å½“äºåŸåºåˆ—ä»å·¦åˆ°å³çš„éå† Splayä¸Šçš„ä¸€ä¸ªèŠ‚ç‚¹ä»£è¡¨åºåˆ—çš„ä¸€ä¸ªå…ƒç´ ï¼›Splayä¸Šçš„ä¸€é¢—å­æ ‘ï¼Œä»£è¡¨åŸåºåˆ—çš„ä¸€æ®µåŒºé—´ åˆ©ç”¨Splayæ“ä½œï¼Œå¯ä»¥å¿«é€Ÿæå–å‡ºä»£è¡¨æŸä¸ªåŒºé—´çš„Splayçš„å­æ ‘ å…·ä½“æ“ä½œï¼š Splay çš„ä¸€é¢—å­æ ‘ä»£è¡¨åŸåºåˆ—çš„ä¸€æ®µåŒºé—´ã€‚ç°åœ¨æƒ³æ‰¾åˆ°åºåˆ—åŒºé—´ [L, R] ä»£è¡¨çš„å­æ ‘ï¼Œåªéœ€è¦å°†ä»£è¡¨ aLâˆ’1a_{L - 1}aLâˆ’1â€‹ çš„èŠ‚ç‚¹ Splay åˆ°æ ¹ï¼Œå†å°†ä»£è¡¨ aR+1a_{R + 1}aR+1â€‹çš„èŠ‚ç‚¹ splay åˆ°æ ¹çš„å³å„¿å­å³å¯ã€‚æ ¹æ®ã€ŒSplay çš„ä¸­åºéå†ç›¸å½“äºåŸåºåˆ—ä»å·¦åˆ°å³çš„éå†ã€ï¼Œå¯¹åº” aR+1a_{R + 1}aR+1â€‹ çš„èŠ‚ç‚¹çš„å·¦å­æ ‘ä¸­åºéå†ä¸ºåºåˆ— a[L, R]ï¼Œæ•…å…¶ä¸ºåŒºé—´ [L, R] ä»£è¡¨çš„å­æ ‘ã€‚ ä¸€èˆ¬ä¼šå»ºç«‹å·¦å³ä¸¤ä¸ªå“¨å…µèŠ‚ç‚¹ 0 å’Œ n + 1ï¼Œæ”¾åœ¨æ•°åˆ—çš„æœ€å¼€å¤´å’Œæœ€ç»“å°¾ï¼Œé˜²æ­¢ L - 1 æˆ– R + 1 è¶…å‡ºæ•°åˆ—èŒƒå›´ã€‚ 123456789101112131415void Splay::splay(int x, int goal = 0) &#123; // å¦‚æœç›®æ ‡ç‚¹ goal ä¸º 0 è¯´æ˜æ—‹è½¬åˆ°æ ¹èŠ‚ç‚¹ if (goal == 0) root = x; // è®¾çˆ¶äº²ä¸ºy,ç¥–çˆ¶ä¸ºz // è‹¥å„¿å­ç§ç±»ç›¸åŒï¼Œåˆ™å…ˆè½¬ç¥–çˆ¶ï¼Œå†è½¬çˆ¶äº² // è‹¥å„¿å­ç§ç±»ä¸åŒï¼Œåˆ™å…ˆè½¬çˆ¶äº²ï¼Œå†è½¬ç¥–çˆ¶ while (fa[x] != goal) &#123; int i = fa[x], g = fa[i]; if (g != goal) &#123; get(i) == get(x) ? rotate(i) : rotate(x); &#125; rotate(x); &#125;&#125; åŒºé—´ç¿»è½¬ ä¸€ä¸ªæš´åŠ›åšæ³•æ˜¯æ¯æ¬¡å°†æ ¹èŠ‚ç‚¹çš„å·¦å³å„¿å­äº¤æ¢ï¼Œç„¶åé€’å½’å·¦å³å­æ ‘åšåŒæ ·çš„æ“ä½œï¼Œè¿™æ ·å¤æ‚åº¦ä¸º O(n)ï¼Œä¸å¯æ‰¿å—ã€‚ å¯ä»¥è€ƒè™‘ä½¿ç”¨æ‡’æ ‡è®°ï¼Œå…ˆç»™æ ¹æ‰“ä¸Šã€Œç¿»è½¬æ ‡è®°ã€å¹¶äº¤æ¢å…¶å·¦å³å„¿å­ã€‚å½“é€’å½’åˆ°ä¸€ä¸ªå¸¦æ‡’æ ‡è®°çš„ç‚¹æ—¶ï¼Œå°†æ‡’æ ‡è®°ä¸‹ä¼ å³å¯ 12345678910111213141516171819void Splay::tagrev(int v)&#123; swap(ch[v][0],ch[v][1]); lazy[v] ^= 1;&#125;void Splay::pushdown(int v)&#123; if(lazy[v])&#123; tagrev(ch[v][0]); tagrev(ch[v][1]); lazy[v] = 0; &#125;&#125;void Splay::reverse(int l, int r)&#123; int L = find_val(l-1), R = find_val(r+1); splay(L), splay(R, L); int temp = ch[ch[L][1]][0]; tagrev(temp);&#125; å°†Splayç”¨äºéœ€è¦åŒºé—´ç¿»è½¬çš„åŒºé—´ç»´æŠ¤ å¯¹äºåŒºé—´åè½¬è¿™ç§æ“ä½œï¼Œç”±äºåŸæ•°åˆ—çš„é¡ºåºå·²ç»ç»™å®šï¼Œæ‰€ä»¥ä¸èƒ½æŒ‰ç…§æƒå€¼æ’åºï¼Œæ‰€ä»¥é€‰æ‹©æŒ‰ç…§çš„ç‚¹çš„ç¼–å·å»ºç«‹BST é¸½äº†(æˆ‘å†™ä¸å‡ºæ¥ å¤šå‰æœç´¢æ ‘ Bæ ‘","categories":[{"name":"cpp","slug":"cpp","permalink":"http://example.com/categories/cpp/"}],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"tugumineko"},{"title":"C++ä¹‹æ—…(A Tour of C++)è¯»ä¹¦ç¬”è®°","slug":"the-tour-of-cpp","date":"2024-05-08T14:55:22.000Z","updated":"2024-05-14T14:43:18.094Z","comments":true,"path":"2024/05/08/the-tour-of-cpp/","permalink":"http://example.com/2024/05/08/the-tour-of-cpp/","excerpt":"","text":"åŸºç¡€ ç¨‹åº ISO C++æ ‡å‡†ä¸­å®šä¹‰äº†ä¸¤ç§å®ä½“ï¼š æ ¸å¿ƒè¯­è¨€ç‰¹æ€§.i.e.å†…ç½®ç±»å‹(char,int).å¾ªç¯(for,while) æ ‡å‡†åº“ç»„ä»¶.i.e.å®¹å™¨(vector,map).è¾“å…¥è¾“å‡ºæ“ä½œ(&lt;&lt;,getline) C++æ˜¯ä¸€ç§é™æ€è¯­è¨€ã€‚è¿™æ„å‘³ç€ï¼Œæ¯ä¸€ä¸ªå®ä½“(å¯¹è±¡ã€å€¼ã€åç§°å’Œè¡¨è¾¾å¼ç­‰)è¢«ä½¿ç”¨çš„é‚£ä¸€åˆ»ï¼Œç¼–è¯‘å™¨å¿…é¡»çŸ¥é“å…¶å‡†ç¡®çš„ç±»å‹ã€‚ 1int main()&#123;&#125; //æœ€å°çš„cppç¨‹åº 123456//import std; æ˜¯cpp20çš„ç‰¹æ€§#include&lt;iostream&gt; //æ ‡å‡†åº“ç»„ä»¶int main()&#123; std::cout&lt;&lt;&quot;Hello, World!\\n&quot;; //æ ‡å‡†åº“å‘½åç©ºé—´std::&#125; Hello, World! å‡½æ•° 123double sqrt(double d); //å‡½æ•°å£°æ˜çš„æ—¶å€™å¯ä»¥åŒ…å«å‚æ•°çš„åç§°double s = sqrt(2); //æ£€æµ‹å‚æ•°ç±»å‹åœ¨å¿…è¦çš„æ—¶å€™ä¼šå‘ç”Ÿéšå¼ç±»å‹è½¬æ¢char&amp; String::operator[](int index); //å‡½æ•°çš„ç±»å‹æ˜¯char&amp; String::(int),å‡½æ•°å¯ä»¥æ˜¯ç±»æˆå‘˜ ç±»å‹ã€å˜é‡å’Œè¿ç®— unsignedä¸€èˆ¬ç”¨äºä½è¿ç®— æ•°å­—å¯ä»¥æ˜¯æµ®ç‚¹æ•°æˆ–è€…æ•´æ•°ï¼š æµ®ç‚¹å­—é¢é‡å«æœ‰å°æ•°ç‚¹æˆ–è€…æŒ‡æ•°ç¬¦å· 0bäºŒè¿›åˆ¶æ•´æ•° //0b0101010 0xåå…­è¿›åˆ¶æ•´æ•° //0x3f3f3f3f 0å…«è¿›åˆ¶æ•´æ•° //0334 ä½¿ç”¨å•å¼•å·(â€™)ä½œä½æ•°å­—åˆ†éš”ç¬¦ 0x3.243Fâ€™6A88â€™85A3â€™08D3 åˆå§‹åŒ–: = çš„å½¢å¼æ˜¯Cè¯­è¨€ä¼ ç»Ÿçš„å½¢å¼ï¼Œä¼šå‘ç”Ÿéšå¼ç±»å‹è½¬æ¢ {} æ›´é€šç”¨ï¼Œè€Œä¸”å¯ä»¥çœç•¥â€™=â€™,ä¸ä¼šå‘ç”Ÿéšå¼ç±»å‹è½¬æ¢ å¸¸é‡è¢«å£°æ˜æ—¶å¿…é¡»è¢«åˆå§‹åŒ–ï¼Œç”¨æˆ·è‡ªå®šä¹‰ç±»å‹å¯ä»¥åœ¨å®šä¹‰æ—¶è¢«éšå¼åˆå§‹åŒ– å¦‚æœå˜é‡çš„ç±»å‹å¯ä»¥ä»åˆå§‹åŒ–ç¬¦å·ä¸­æ¨å¯¼å‡ºæ¥ï¼Œå°±æ— éœ€æ˜¾å¼æŒ‡å®šç±»å‹ ä½¿ç”¨ auto å¸¸ç”¨åœ¨æ³›å‹ç¼–ç¨‹ä¸­ï¼Œä»¥é¿å…ä¹¦å†™å†—é•¿çš„ç±»å‹åç§°åŠé‡å¤ä»£ç  1234567double d1 = 2.3;double d2 &#123;2.3&#125;;double d3 = &#123;2.3&#125;;complex&lt;double&gt; z = 1;complex&lt;double&gt; z2 &#123;d1,d2&#125;;complex&lt;double&gt; z3 = &#123;d1,d2&#125;;vector&lt;int&gt; v &#123;1, 2, 3, 4, 5, 6&#125;; 12auto y = 3.14;auto z &#123;sqrt(y)&#125;; ä½œç”¨åŸŸå’Œç”Ÿå‘½å‘¨æœŸ å£°æ˜è¯­å¥æŠŠä¸€ä¸ªåå­—å¼•å…¥ä½œç”¨åŸŸï¼š å±€éƒ¨ä½œç”¨åŸŸï¼šåœ¨å‡½æ•°/åŒ¿åå‡½æ•°ä¸­å®šä¹‰çš„åå­—å«åšå±€éƒ¨åå­—(åŒ…æ‹¬å‡½æ•°å‚æ•°çš„åå­—)ï¼Œä»¥è¯­å¥å—({})ç»“å°¾. ç±»ä½œç”¨åŸŸï¼šä¸åœ¨å‡½æ•°ã€åŒ¿åå‡½æ•°æˆ– enum class ä¸­ä½†åœ¨ç±»çš„å†…éƒ¨. å‘½åç©ºé—´ä½œç”¨åŸŸï¼šä¸æ˜¯å±€éƒ¨åå­—å’Œç±»åå­—ä¸”åœ¨å‘½åç©ºé—´çš„å†…éƒ¨. ç”Ÿå‘½å‘¨æœŸï¼š å¯¹è±¡å¿…é¡»å…ˆè¢«æ„é€ ï¼ˆåˆå§‹åŒ–ï¼‰æ‰èƒ½è¢«ä½¿ç”¨ï¼Œå¹¶ä¸”åœ¨é€€å‡ºä½œç”¨åŸŸæ—¶è¢«é”€æ¯ã€‚ å‘½åç©ºé—´å¯¹è±¡åœ¨ç¨‹åºç»“æŸæ—¶è¢«é”€æ¯ã€‚ å¯¹è±¡æˆå‘˜çš„é”€æ¯æ—¶é—´ç‚¹å–å†³äºæ‰€å±å¯¹è±¡çš„é”€æ¯æ—¶é—´ç‚¹ã€‚ ä¸€ä¸ªç”¨newåˆ›å»ºçš„å¯¹è±¡åˆ™å¯ä»¥æŒç»­ç”Ÿå­˜ï¼Œç›´åˆ°ç”¨deleteå°†å…¶é”€æ¯ã€‚ å¸¸é‡ const ç”¨æ¥è¯´æ˜æ¥å£ï¼Œå¯ä»¥ç”¨æŒ‡é’ˆæˆ–è€…å¼•ç”¨çš„æ–¹å¼ä¼ å…¥å‚æ•°è€Œä¸ç”¨æ‹…å¿ƒè¢«æ”¹å˜ ç¼–è¯‘å™¨è´Ÿè´£å¼ºåˆ¶æ‰§è¡Œ const æ‰¿è¯º constå£°æ˜çš„å€¼å¯ä»¥åœ¨è¿è¡Œæ—¶è®¡ç®— constexpr å£°æ˜å¸¸é‡ï¼Œåœ¨åªè¯»å†…å­˜ä¸­ï¼Œæé«˜æ€§èƒ½ constexpr çš„å€¼å¿…é¡»ç”±ç¼–è¯‘å™¨è¿ç®— const double s1 = sum(v); //å¯è¡Œ:å…è®¸åœ¨è¿è¡Œæ—¶è¿ç®— constexpr double s2 = sum(v); 123456789double sum1(const double&amp;);double sum2(const vector&lt;double&gt;&amp;);vector&lt;double&gt; v &#123;1.2, 3.4, 5.6&#125;;const double s1 = sum1(1.0); //å¯è¡Œconstexpr double s2 = sum1(1.0); //ä¸è¡Œconstexpr double s3 = sum2(v); //ä¸è¡Œ&#125; è‹¥è¦ä½¿å‡½æ•°åœ¨å¸¸é‡è¡¨è¾¾å¼(ä¸Šæ–‡ä»£ç )ä¸­ä½¿ç”¨ï¼Œè¿™ä¸ªå‡½æ•°å¿…é¡»è¢«å®šä¹‰ä¸º constexpr æˆ– consteval constexpr å‡½æ•° åœ¨è¾“å…¥éå¸¸é‡å‚æ•°æ—¶ï¼Œè¾“å‡ºçš„ä¸æ˜¯å¸¸é‡è¡¨è¾¾å¼ åœ¨è¾“å…¥å¸¸é‡å‚æ•°æ—¶ï¼Œè¾“å‡ºçš„æ‰æ˜¯å¸¸é‡è¡¨è¾¾å¼ consteval å‡½æ•°å¯ä»¥è®©è¾“å…¥å˜é‡åªèƒ½ä¸ºå¸¸é‡è¡¨è¾¾å¼,å³å¯ä»¥çœç•¥è¾“å…¥çš„å¸¸é‡è¡¨è¾¾å¼è¯­æ³•ï¼Œè¿˜å¯ä»¥ä½¿è¾“å‡ºä¸ºå¸¸é‡è¡¨è¾¾å¼ã€‚ 12345constexpr double squre(double x)&#123;return x*x;&#125;constexpr double max1 = 1.4*squre(17) //å¯è¡Œï¼Œ17ä¸ºå¸¸é‡constexpr double max2 = 1.4*squre(var) //é”™è¯¯ï¼Œvarä¸æ˜¯å˜é‡ï¼Œæ‰€ä»¥è¿”å›å€¼ä¸æ˜¯å¸¸é‡è¡¨è¾¾å¼const double max3 = 1.4*squre(var) //å¯è¡Œ 1234consteval double square2(double x)&#123;return x*x;&#125;constexpr double max1 = 1.4*square2(17); //å¯è¡Œconst double max2 = 1.4*square2(var); //é”™è¯¯ï¼Œå‡½æ•°è¾“å…¥åªèƒ½æ˜¯å¸¸é‡è¡¨è¾¾å¼ æ€»ç»“ è¿™é‡Œè®¨è®ºçš„æœ‰ä¸‰ä¸ªéƒ¨åˆ†ï¼Œå‡½æ•°çš„è¿”å›å€¼ç±»å‹ï¼ˆå‡½æ•°çš„å£°æ˜ï¼‰ï¼Œå‡½æ•°çš„è¾“å…¥å‚æ•°ç±»å‹ï¼Œæ•°æ®ç±»å‹,å‡æœ‰ä¸¤ç§å†™æ³•ï¼Œæ³¨æ„åˆ†è¾¨ å‡½æ•°çš„è¾“å…¥å‚æ•°ç±»å‹ (æ•°æ®ç±»å‹ å˜é‡å):å¯ä»¥æ˜¯å˜é‡ï¼Œä¹Ÿå¯ä»¥æ˜¯å¸¸é‡è¡¨è¾¾å¼ (const æ•°æ®ç±»å‹&amp; å˜é‡å):å‡½æ•°ä¸ä¼šä¿®æ”¹ä»–å®ƒçš„å‚æ•° æ•°æ®ç±»å‹ const:è¯´æ˜æ¥å£ï¼Œæ„ä¸ºâ€œåªè¯»â€ cosntexpr:å£°æ˜å¸¸é‡ï¼Œèµ‹å€¼ç»™ä»–çš„åªèƒ½æ˜¯å¸¸é‡è¡¨è¾¾å¼ å‡½æ•°çš„è¿”å›å€¼ç±»å‹ constexpr:ä¸æŒ‡å®šè¾“å…¥ç±»å‹ï¼Œè¾“å…¥å’Œè¾“å‡ºçš„ä¸å˜æ€§ä¸€è‡´ consteval:è¾“å…¥å’Œè¾“å‡ºå‡ä¸ºå¸¸é‡è¡¨è¾¾å¼ æ³¨æ„conståªå…·æœ‰æ¥å£æ€§è´¨ï¼Œä¸æ˜¯å®é™…ä¸Šçš„å¸¸é‡ å‡½æ•°çš„å£°æ˜ä¸ºå¸¸é‡(constexpr,consteval)å¯ä»¥å®ç°C++çš„çº¯å‡½æ•°ï¼Œå³æ•°å­¦æ„ä¹‰ä¸Šçš„å‡½æ•°ï¼Œä¸ä¼šæœ‰å‰¯ä½œç”¨ï¼Œä¸èƒ½ä¿®æ”¹å‡½æ•°çš„è¾“å…¥å‚æ•° æŒ‡é’ˆã€æ•°ç»„å’Œå¼•ç”¨ 123456T a[n]; //æ•°ç»„T* p; //æŒ‡é’ˆT&amp; r; //å¼•ç”¨char* p = &amp;v[3]; //pæŒ‡å‘æ•°ç»„vçš„ç¬¬å››ä¸ªå…ƒç´ char x = *p; //*pä»£è¡¨pæŒ‡å‘çš„å¯¹è±¡(*è§£å¼•ç”¨) æ³¨æ„*åœ¨å®šä¹‰æ—¶æ˜¯å®šä¹‰æŒ‡é’ˆ,åœ¨æŒ‡é’ˆå‰ä½¿ç”¨æ˜¯è§£å¼•ç”¨ ç©ºæŒ‡é’ˆ ç©ºæŒ‡é’ˆç”¨nullptrè¡¨è¾¾ï¼Œæ•´æ•°ç”¨0æˆ–NULLè¡¨è¾¾ï¼Œåœ¨æ£€éªŒæ—¶æ˜¯å…¼å®¹çš„ ä¸èƒ½å¼•ç”¨ç©ºæŒ‡é’ˆ æ˜ å°„åˆ°ç¡¬ä»¶ èµ‹å€¼: på’ŒqåŒæ—¶æŒ‡å‘yçš„åœ°å€ 1234int y = 3;int* p = &amp;x;int* q = &amp;y;p = q; åœ°å€r1,r2ä¸åŒï¼Œä½†æ˜¯ä½¿ä¸åŒçš„åœ°å€å…·æœ‰ç›¸åŒçš„å€¼ 12345int x = 2;int y = 3;int&amp; r1 = x;int&amp; r2 = y;r1 = r2; è¿™é‡Œç›´æ¥ç”¨å¼•ç”¨çš„æ–¹æ³•æ“ä½œåœ°å€ï¼Œæ²¡æœ‰ä½¿ç”¨æŒ‡é’ˆ åˆå§‹åŒ–:æ²¡æœ‰æœªç»åˆå§‹åŒ–çš„å¼•ç”¨ ä½¿ç”¨ = æ¥åˆå§‹åŒ–ä¸€ä¸ªå¼•ç”¨ï¼Œæ³¨æ„è¿™ä¸æ˜¯èµ‹å€¼ int&amp; r = x; //ræŒ‡ä»£x è¡¥å……åœ¨å‡½æ•°ä¸­å¼•ç”¨çš„ä¸¤ç§æ–¹æ³• void sort(vector&lt;double&gt;&amp;v) è‹¥åªæƒ³å‡å°‘å¤åˆ¶å‚æ•°çš„å¼€é”€ï¼Œåˆ™ï¼š double sum(const vector&lt;double&gt;&amp;) è¿™æ ·å°±ä¸èƒ½æ”¹å˜å‡½æ•°ä¼ å…¥çš„å‚æ•° ç”¨æˆ·è‡ªå®šä¹‰ç±»å‹ å†…ç½®ç±»å‹ï¼šç”¨åŸºæœ¬ç±»å‹ã€constæ“ä½œç¬¦å’Œå£°æ˜æ“ä½œç¬¦æ„é€ å‡ºæ¥çš„ç±»å‹ ç”¨æˆ·è‡ªå®šä¹‰ç±»å‹ï¼šåˆ©ç”¨C++çš„æŠ½è±¡æœºåˆ¶ä»å…¶ä»–ç±»å‹æ„é€ å‡ºæ¥çš„ç±»å‹ï¼ŒåŒ…æ‹¬ç±»å’Œæšä¸¾ç±»å‹ ç»“æ„ struct 1234567891011121314151617181920212223242526struct Vector &#123; double* elem; int sz; &#125;; void vector_init(Vector&amp; v, int s)&#123; v.elem = new double[s]; v.sz = s; &#125;double read_and_sum(int s) //ä»cinä¸­è¯»å…¥sä¸ªæ•´æ•°ï¼Œç„¶åè¿”å›å®ƒä»¬çš„å’Œï¼›å‡å®šsä¸ºæ­£&#123; Vector v; vector_init(v,s); for(int i=0;i!=s;i++)&#123; std::cin&gt;&gt;v.elem[i]; &#125; double sum = 0; for(int i=0;i!=s;i++)&#123; sum += v.elem[i]; &#125; return sum;&#125; è®¿é—®ç»“æ„ä½“çš„æˆå‘˜æœ‰ä¸¤ç§æ–¹å¼ ç”¨ . è¡¨ç¤ºé€šè¿‡åå­—æˆ–è€…å¼•ç”¨è®¿é—® ç”¨ -&gt; è¡¨ç¤ºé€šè¿‡æŒ‡é’ˆè®¿é—® 12345void f(Vector v, Vector&amp; rv, Vector* pv)&#123; int i1 = v.sz; //é€šè¿‡åå­—è®¿é—® int i2 = rv.sz; //é€šè¿‡å¼•ç”¨è®¿é—® int i3 = pv-&gt;sz; //é€šè¿‡æŒ‡é’ˆè®¿é—® &#125; ç±» class æŠŠç±»å‹çš„æ¥å£ï¼ˆæ‰€æœ‰ä»£ç éƒ½å¯ä½¿ç”¨çš„éƒ¨åˆ†ï¼‰ä¸å…¶å®ç°ï¼ˆå¯è®¿é—®å¤–éƒ¨ä¸å¯è®¿é—®çš„æ•°æ®ï¼‰åˆ†ç¦»å¼€æ¥çš„è¯­è¨€æœºåˆ¶è¢«ç§°ä¸ºç±» 123456789class Vector &#123;public: Vector(int s) :elem&#123; new double[s] &#125;, sz&#123; s &#125; &#123;&#125; //æ„é€ å‡½æ•° double&amp; operator[](int i) &#123; return elem[i]; &#125; int size() &#123; return sz; &#125;private: double* elem; int sz;&#125;; æ„é€ å‡½æ•°åœ¨åˆå§‹åŒ–ç±»å¯¹è±¡æ—¶ä¸€å®šä¼šè¢«è°ƒç”¨ é”™è¯¯å¤„ç†æš‚æ—¶æ²¡æœ‰æ¶‰åŠ æ€è€ƒé€šè¿‡newè·å–çš„doubleæ•°ç»„å¦‚ä½•å½’è¿˜ï¼Ÿ structå’Œclassæ²¡æœ‰æœ¬è´¨åŒºåˆ«ï¼Œstructæ˜¯é»˜è®¤publicçš„ æšä¸¾ enum class æšä¸¾ç±»å‹ç”¨äºè¡¨ç¤ºå°‘é‡æ•´æ•°æ•°å€¼çš„é›†åˆ é€šè¿‡ç¬¦å·åç§°æ›¿ä»£æ•´æ•° åé¢çš„classè¡¨ç¤ºè¿™ä¸ªæšä¸¾ç±»å‹æ˜¯å¼ºç±»å‹ï¼Œå¹¶ä¸”å…·å¤‡ç‹¬ç«‹ä½œç”¨åŸŸ ä¸èƒ½æ··ç”¨ä¸åŒç±»çš„æšä¸¾å€¼ æ— æ³•éšå¼åœ°æ··ç”¨æšä¸¾ç±»å‹ä¸æ•´æ•°ç±»å‹çš„å€¼ é»˜è®¤æƒ…å†µä¸‹ï¼Œä¸€ä¸ªenum classå®šä¹‰ä»…å®šä¹‰èµ‹å€¼æ“ä½œç¬¦ã€åˆå§‹åŒ–å‡½æ•°åŠæ¯”è¾ƒæ“ä½œç¬¦ï¼Œä¹Ÿå¯ä»¥è‡ªå®šä¹‰å…¶ä»–æ“ä½œç¬¦ 123456789101112131415enum class Color &#123; red, blue, green &#125;;enum class Traffic_light &#123; green, yellow, red &#125;;Color col = Color::red;Traffic_light light = Traffic_light::red;Traffic_light* operator++(Traffic_light&amp; t) &#123; using enum Traffic_light; switch (t) &#123; case green:return t = yellow; case red:return t = green; case green:return t = red; &#125;&#125; Color x = redColor y = traffic_light::red int i = Color::redColor c = 2 Color z = Color::redauto z = Color::red Color x = Color{5}Color y {6} enum æ™®é€šenumä¸­çš„æšä¸¾å€¼è¿›å…¥ä¸enumè‡ªèº«åŒçº§çš„ä½œç”¨åŸŸ å¯ä»¥è¢«éšå¼è½¬æ¢ä¸ºæ•´æ•°æ•°å€¼ ç”¨æšä¸¾è¡¨ç¤ºä¸€ç»„å‘½åçš„å¸¸é‡ä¸ºæšä¸¾å®šä¹‰æ“ä½œæ¥ç®€åŒ–å¹¶ä¿è¯å®‰å…¨ä¼˜å…ˆä½¿ç”¨enum classä»¥é¿å…å¾ˆå¤šéº»çƒ¦ 12enum Color &#123;red, green, blue&#125;;int col = red; //col &#123;0&#125; è”åˆ union å®é™…å ç”¨ç©ºé—´å°±æ˜¯å®ƒæœ€å¤§æˆå‘˜æ‰€å çš„ç©ºé—´ï¼Œå¯ä»¥ç”¨æ¥èŠ‚çº¦ç©ºé—´ åŒä¸€æ—¶åˆ»ï¼Œunionä¸­åªèƒ½ä¿å­˜ä¸€ä¸ªæˆå‘˜çš„å€¼ 12345678910111213141516171819enum class Type &#123; ptr, num &#125;;union Value &#123; Node* p; int i;&#125;;struct Entry &#123; string name; Type t; Value v;&#125;;void f(Entry* pe)&#123; if (pe-&gt;t == Type::num) cout &lt;&lt; pe-&gt;v.i; //...&#125; é¿å…ä½¿ç”¨â€œè£¸â€union;å°†å…¶ä¸ç±»å‹å­—æ®µä¸€èµ·å°è£…åœ¨ä¸€ä¸ªç±»ä¸­ ä½¿ç”¨æ ‡å‡†åº“ç±»å‹variantå¯ä»¥æ¶ˆé™¤å¤§å¤šæ•°éœ€è¦ç›´æ¥ä½¿ç”¨unionvariantæ›´ç®€å•ï¼Œå®‰å…¨ 1234567891011struct Entry &#123; string name; variant&lt;Node*,int&gt; v;&#125;;void f(Entry* pe)&#123; if (holds_alternative&lt;int&gt;(pe-&gt;v)) cout &lt;&lt; get&lt;int&gt;(pe-&gt;v); //...&#125; æ¨¡å—åŒ– ä¸€ä¸ªC++ç¨‹åºåŒ…å«è®¸å¤šç‹¬ç«‹å¼€å‘çš„éƒ¨åˆ†ï¼Œä¾‹å¦‚å‡½æ•°ã€ç”¨æˆ·è‡ªå®šä¹‰ç±»å‹ã€ç±»å±‚æ¬¡ã€ æ¨¡æ¿ä¸ºäº†è®©è¿™äº›ç‹¬ç«‹å¼€å‘çš„éƒ¨åˆ†åœ¨å…¶ä»–åœ°æ–¹ä½¿ç”¨ï¼ˆç±»ä¼¼äºå‡½æ•°çš„å£°æ˜ï¼‰ï¼Œæˆ‘ä»¬ä½¿ç”¨æ¨¡å—åŒ–çš„æ–¹æ³• åŒºåˆ†å£°æ˜(ç”¨ä½œæ¥å£)å’Œå®šä¹‰(ç”¨ä½œå®ç°) åˆ†ç¦»ç¼–è¯‘ å¤´æ–‡ä»¶ åœ¨C++ä¸­ï¼Œæ¥å£æ–‡ä»¶åç¼€åä¸º.h,é‡Œé¢åº”è¯¥åŒ…æ‹¬å‡½æ•°çš„å£°æ˜ å®ç°æ¥å£å‡½æ•°çš„æ–‡ä»¶åç¼€åä¸º.cpp,ä¸ºäº†å¸®åŠ©ç¼–è¯‘å™¨ä¿æŒä¸€è‡´æ€§ï¼ŒåŒæ ·åº”è¯¥åŒ…å«æä¾›æ¥å£çš„.hæ–‡ä»¶ è¦ä½¿ç”¨è¿™ä¸ªå¤´æ–‡ä»¶çš„å‡½æ•°ï¼Œå°±éœ€è¦åœ¨å¤´æ–‡ä»¶ä¸­åŒ…å«&quot;xxx.h&quot; ä½¿ç”¨#includeåŠå¤´æ–‡ä»¶å®ç°æ¨¡å—åŒ–æ˜¯ä¸€ç§ä¼ ç»Ÿæ–¹æ³•ï¼Œå®ƒå…·æœ‰æ˜æ˜¾çš„ç¼ºç‚¹ã€‚ ç¼–è¯‘æ—¶é—´ï¼šä¸åŒçš„æ–‡ä»¶æ¯ä¸€æ¬¡includeä¸åŒçš„å¤´æ–‡ä»¶ç¼–è¯‘å™¨éƒ½è¦å¤„ç†ä¸€æ¬¡ ä¾èµ–é¡ºåºï¼šå…ˆincludeçš„å¤´æ–‡ä»¶çš„å®šä¹‰ä¸å®å¯èƒ½ä¼šå½±å“åä¸€ä¸ªçš„ä»£ç çš„å«ä¹‰ ä¸åè°ƒï¼šå¯èƒ½ä¼šå‡ºç°ç±»ä¼¼ä¸‹é¢çš„é—®é¢˜ æˆ‘ä»¬æœ‰æ„æ— æ„åœ°åœ¨ä¸¤ä¸ªæºæ–‡ä»¶ä¸­å®šä¹‰äº†åŒä¸€ä¸ªå®ä½“çš„æ—¶å€™ ä¸åŒæºæ–‡ä»¶å¼•ç”¨å¤´æ–‡ä»¶çš„é¡ºåºä¸ä¸€è‡´çš„æ—¶å€™ ä¼ æŸ“æ€§ï¼šä¸€ä¸ªæ–‡ä»¶(1)åŒ…å«çš„å¤´æ–‡ä»¶(2)ä¼šåŒ…å«å…¶ä»–è¿™ä¸ªæ–‡ä»¶(1)ä¸éœ€è¦çš„å¤´æ–‡ä»¶ï¼Œä»¥æ­¤ç±»æ¨ä¼šå¯¼è‡´ä»£ç è†¨èƒ€ä¸”å†—ä½™ é¿å…åœ¨å¤´æ–‡ä»¶ä¸­å®šä¹‰éå†…è”å‡½æ•°ä¸è¦åœ¨å¤´æ–‡ä»¶ä¸­ä½¿ç”¨ using æŒ‡ä»¤ æ¨¡å— å†™æ³•1ï¼šå°†class exportå¹¶è¡¨ç¤ºæˆå£°æ˜çš„å½¢å¼ï¼Œå°±å’Œ.hå†™æ³•å·®ä¸å¤š 12345678910111213141516171819202122232425export module Vector;export class Vector &#123; public: Vector(int s); double&amp; operator[](int i); int size(); private: double* elem; int sz;&#125;;Vector::Vector(int s) : elem&#123;new double[s]&#125;, sz&#123;s&#125; &#123;&#125;double&amp; Vector::operator[](int i) &#123; return elem[i]; &#125;int Vector::size() &#123; return sz; &#125;export bool operator==(const Vector&amp; v1, const Vector&amp; v2) &#123; if (v1.sieze() != v2.size()) return false; for (int i = 0; i &lt; v1.size(); i++) if (v1.elem[i] != v2.elem[i]) return false; return true;&#125; å†™æ³•2ï¼šå‡½æ•°exportçš„å°±æ˜¯å¯è§çš„ï¼Œæ²¡æœ‰exportçš„å°±æ˜¯ä¸å¯è§çš„(ç±»ä¼¼java) module Vectoræ¥å£å½¢å¼ï¼Œåç¼€åä¸º.cppm import Vectorä½¿ç”¨Vector export module Vectorå®šä¹‰Vector æ¨¡å—åœ¨ç»´æŠ¤æ€§ä¸ç¼–è¯‘æ—¶é—´æ–¹é¢çš„æ”¹è¿›éå¸¸æ˜¾è‘— å‘½åç©ºé—´ ç”¨ namespace å‘½åç©ºé—´å {} ç”¨ :: è®¿é—® è¡¨è¾¾æŸäº›å£°æ˜æ˜¯å±äºä¸€ä¸ªæ•´ä½“çš„ è¡¨æ˜å®ƒä»¬çš„åå­—ä¸ä¼šä¸å…¶ä»–å‘½åç©ºé—´ä¸­çš„åå­—å†²çª çœŸæ­£çš„main()ï¼ˆä¸æ˜¯è‡ªå·±å®šä¹‰çš„å‘½åç©ºé—´é‡Œçš„ï¼‰ ç”¨ using å£°æ˜å°†å‘½åç©ºé—´ä¸­çš„åå­—æ”¾è¿›ä½œç”¨åŸŸ,å¯ä»¥é™ä½å¯è¯»æ€§ 1234567void my_code(vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y) &#123; using std::swap; // å°†æ ‡å‡†åº“çš„swapæ”¾è¿›ä½œç”¨åŸŸ //... swap(x, y); // std::swap() other::swap(x, y); // æŸä¸ªå…¶ä»–çš„swap() //...&#125; ä½¿ç”¨æ ‡å‡†åº“å‘½åç©ºé—´ä¸­æ‰€æœ‰åç§°çš„è®¿é—®æƒ using namespace std; ç”¨ä»¥ä¸Šæ–¹å¼ä½¿ç”¨å‘½åç©ºé—´æŒ‡ä»¤ä¸ä¼šå½±å“ä½¿ç”¨æ¨¡å—çš„ç”¨æˆ·ï¼Œå½±å“ä»…é™äºæ¨¡å—å†…éƒ¨ å‡½æ•°å‚æ•°ä¸è¿”å›å€¼ å‡½æ•°ä¹‹é—´ä¼ é€’ä¿¡æ¯æœ‰ä¸‰ç§è·¯å¾„ï¼š å‚æ•° å…¨å±€å˜é‡ ç±»å¯¹è±¡ä¸­çš„å…±äº«çŠ¶æ€ åœ¨å‡½æ•°çš„ä¿¡æ¯ä¼ é€’ä¸­ï¼Œæˆ‘ä»¬åº”è€ƒé‡ï¼š å¯¹è±¡æ˜¯è¢«å¤åˆ¶çš„è¿˜æ˜¯å…±äº«çš„ï¼Ÿ è¿™ä¸ªå…±äº«å¯¹è±¡æ˜¯å¦å¯è¢«ä¿®æ”¹ï¼Ÿ è¿™ä¸ªå¯¹è±¡æ˜¯å¦è¢«ç§»åŠ¨ï¼Œä»è€Œç•™ä¸‹äº†ä¸€ä¸ªç©ºå¯¹è±¡ï¼Ÿ å‚æ•°ä¼ é€’ é»˜è®¤æƒ…å†µå¤åˆ¶(ä¼ å€¼)/ç›´æ¥æŒ‡å‘å¼•ç”¨(ä¼ å¼•ç”¨)/ç›´æ¥åªè¯»const&amp; æ‹¥æœ‰é»˜è®¤å€¼çš„å‡½æ•°å‚æ•°å¯ä»¥è¾¾åˆ°å’Œé‡è½½å‡½æ•°ä¸€æ ·çš„æ•ˆæœ 123void print(int value, int base = 10);print(x,8);print(x);//é»˜è®¤åè¿›åˆ¶ 1234567void print(int value, int base)&#123; //...&#125;void print(int value)&#123; print(int value, 10);&#125; è¿”å›å€¼ è¿”å›å€¼çš„é»˜è®¤è¡Œä¸ºæ˜¯å¤åˆ¶ è¿”å›å¼•ç”¨çš„æƒ…å†µåªåº”å½“å‡ºç°åœ¨è¿”å›çš„å†…å®¹ä¸å±äºå‡½æ•°å±€éƒ¨çš„æ—¶å€™(æ³¨æ„æ•°ç»„) å±€éƒ¨å˜é‡åœ¨å‡½æ•°è¿”å›çš„æ—¶å€™æ¶ˆå¤±ï¼Œå› æ­¤æˆ‘ä»¬ä¸åº”å½“è¿”å›å®ƒçš„å¼•ç”¨æˆ–è€…æŒ‡é’ˆ å¯¹äºè¾ƒå¤§çš„å¯¹è±¡æ„é€ ç§»åŠ¨æ–¹æ³•æ¥æå¤§åœ°å‡å°‘å¤åˆ¶å¼€é”€ ç¼–è¯‘å™¨ä¼šä¼˜åŒ–å¤åˆ¶è¡Œä¸ºï¼Œå«åšçœç•¥å¤åˆ¶ä¼˜åŒ– ä½¿ç”¨æŒ‡é’ˆè¿”å›å¤§å¯¹è±¡çš„ä»£ç æ€§èƒ½ä¸ä¼šæ¯”ä½¿ç”¨å¼•ç”¨è¿”å›çš„å‡½æ•°å¥½ï¼Œä¸è¦ä½¿ç”¨è¿™æ ·çš„ä»£ç  1234567891011Matrix* add(const Matrix&amp; x, const Matrix&amp; y) &#123; Matrix* p = new Matrix; //.... return p;&#125;Matrix m1, m2;//...Matrix* m3 = add(m1, m2); // åªå¤åˆ¶æŒ‡é’ˆ//...delete m3; // å¾ˆå®¹æ˜“å¿˜è®° è¿”å›ç±»å‹æ¨å¯¼ ä½¿ç”¨ auto å…³é”®å­— auto mul(int i, double d) &#123; return i*d; &#125; è¿”å›ç±»å‹åç½® æœ‰çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦å…ˆçœ‹åˆ°å‚æ•°ï¼Œç„¶åå†³å®šè¿”å›å€¼çš„ç±»å‹ã€‚ è¿™åŒ…æ‹¬ä½†ä¸é™äºè¿”å›ç±»å‹æ¨å¯¼è¿™ç§æƒ…å½¢ï¼Œè¿™ä¸ªé—®é¢˜ä¸å‘½åç©ºé—´ã€åŒ¿åå‡½æ•°ã€æ¦‚å¿µéƒ½æœ‰ä¸€å®šçš„è”ç³» ä½¿ç”¨ auto å…³é”®å­—ï¼Œè¡¨ç¤ºè¿”å›å€¼ä¼šåœ¨åé¢æåˆ° auto mul(int i, double d) -&gt; double &#123; return i*d; &#125; ä½¿ç”¨è¿™ç§è®°æ³•èƒ½å¤Ÿæ›´æœ‰æ•ˆåœ°å®ç°ä»£ç å¯¹é½ auto next_elem -&gt; Elem*; auto exit(int) -&gt; void; auto sqrt(double) -&gt; double; ä¸è¦è¿‡åº¦ä½¿ç”¨è¿”å›ç±»å‹æ¨æ–­ ç»“æ„åŒ–ç»‘å®š æŠŠç±»å¯¹è±¡æˆå‘˜èµ‹äºˆå±€éƒ¨å˜é‡åç§°çš„æœºåˆ¶ ä½¿ç”¨ {s, i} æ„é€  ä½¿ç”¨ [n, v] è¯»å–(â€œè§£åŒ…â€) 123456789101112131415struct Entry &#123; string name; int value;&#125;;Entry read_entry(istream&amp; is) // ç®€å•åœ°è¯»å‡½æ•°&#123; string s; int i; is &gt;&gt; s &gt;&gt; i; return &#123;s, i&#125;;&#125;auto [n, v] = read_entry(cin);cout&lt;&lt;n&lt;&lt;&#x27; &#x27;&lt;&lt;v&lt;&lt;&#x27;\\n&#x27;; å¯¹å®Œå…¨æ²¡æœ‰ç§æœ‰æ•°æ®çš„ç±»ä½¿ç”¨ç»“æ„åŒ–ç»‘å®šæ—¶ï¼Œç»‘å®šè¡Œä¸ºæ˜¯æ˜æ˜¾çš„ï¼šæä¾›çš„åç§°æ•°é‡å¿…é¡»ä¸æ•°æ®æˆå‘˜çš„æ•°é‡ç›¸ç­‰ï¼Œæ¯ä¸€ä¸ªç»‘å®šåç§°å¯¹åº”ä¸€ä¸ªæˆå‘˜å˜é‡ 12345678910map&lt;string, int&gt; m;//...for (const auto [key, value] : m) &#123; cout &lt;&lt; key &lt; &#x27; &#x27; &lt;&lt; value &lt;&lt; &#x27;\\n&#x27;;&#125;auto incr(map&lt;string, int&gt;&amp; m) -&gt; void &#123; for (auto&amp; [key, value]) value++;&#125; ç»“æ„åŒ–ç»‘å®šä¹Ÿå¯ä»¥ç”¨äºå¤„ç†éœ€è¦é€šè¿‡æˆå‘˜å‡½æ•°è®¿é—®å¯¹è±¡æ•°æ®çš„ç±»ï¼ˆ?ï¼‰ complex&lt;double&gt; z = &#123;1,2&#125;; auto [re,im] = z+2; ä¸è¦è¿‡åº¦ä½¿ç”¨ç»“æ„åŒ–ç»‘å®š","categories":[{"name":"cpp","slug":"cpp","permalink":"http://example.com/categories/cpp/"}],"tags":[{"name":"è¯­æ³•","slug":"è¯­æ³•","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"}],"author":"tugumineko"},{"title":"pythonå›¾åƒå¤„ç†","slug":"pythonå›¾åƒå¤„ç†","date":"2024-05-06T08:31:57.000Z","updated":"2024-06-30T14:09:35.521Z","comments":true,"path":"2024/05/06/pythonå›¾åƒå¤„ç†/","permalink":"http://example.com/2024/05/06/python%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/","excerpt":"","text":"pythonå›¾åƒå¤„ç† è¯¦è§æ–‡æ¡£Pillow:Python-Imaging-Libraryè¿™é‡Œä½¿ç”¨çš„æ˜¯Imageæ¨¡å— å›¾åƒå±æ€§ formatå±æ€§ string or None æ ‡è¯†äº†å›¾åƒæ ¼å¼ï¼Œå¦‚æœå›¾åƒä¸æ˜¯ä»æ–‡ä»¶è¯»å–å®ƒçš„å€¼å°±æ˜¯None modeå±æ€§ string æ³¨ï¼šå¦‚æœä¸€ä¸ªå›¾ç‰‡çš„é¢œè‰²æ ¼å¼ä¸ºsrgbï¼Œåˆ™è¯´æ˜è¿™å¼ å›¾ç‰‡å­˜å‚¨çš„é¢œè‰²å€¼æ˜¯encoder gammaä¹‹åçš„é¢œè‰²å€¼ sRGBæ ‡å‡†ï¼š äººçœ¼å¯¹äº®åº¦çš„æ„ŸçŸ¥ä¸æ˜¯çº¿æ€§çš„ï¼Œ å…¶å¯¹è¾ƒæš—åŒºåŸŸçš„å˜åŒ–æ›´åŠ æ•æ„Ÿï¼Œå‚è§ Computer Color is Broken åŸºäºäººçœ¼è¯¥ç‰¹ç‚¹ï¼ŒsRGBæ ‡å‡†è¦æ±‚å›¾åƒï¼ˆå„é€šé“ä¸º8bits,æœ€å¤šå­˜å‚¨256ä¸ªäº®åº¦å€¼ï¼‰ä½¿ç”¨encoder gamma,æŠŠæ›´å¤šçš„ç©ºé—´ç”¨æ¥å­˜å‚¨æ›´å¤šæš—éƒ¨åŒºåŸŸï¼Œæ¥æœ€å¤§åŒ–åœ°åˆ©ç”¨è¡¨ç¤ºäº®åº¦çš„æ•°æ®ä½æˆ–å¸¦å®½ã€‚ sizeå±æ€§ (width,height) å›¾åƒçš„å°ºå¯¸ï¼ŒæŒ‰ç…§åƒç´ æ•°è®¡ç®— paletteå±æ€§ palette or None é¢œè‰²è°ƒè‰²æ¿è¡¨æ ¼ï¼Œåªå¯¹æ¨¡å¼ä¸º&quot;P&quot;çš„å›¾åƒè¿”å›Image Palette infoå±æ€§ dictionary å­˜å‚¨å›¾åƒç›¸å…³æ•°æ®çš„å­—å…¸ 12345678from PIL import Imageim = Image.open(&quot;personal/1.png&quot;)print(im.format)print(im.mode)print(im.size)print(im.palette)print(im.info)im.show() PNG RGBA (1920, 1200) None &#123;'srgb': 0, 'gamma': 0.45455, 'dpi': (119.9896, 119.9896)&#125; æ„å»ºå›¾åƒ Image.open(fp,mode) 123from PIL import Image im = Image.open(&quot;personal/21.jpg&quot;,&quot;r&quot;)im.show() éœ€è¦çŸ¥é“çš„æ˜¯åœ¨winçš„ç¯å¢ƒä¸‹im.showçš„æ–¹å¼ä¸ºwinè‡ªå¸¦çš„å›¾åƒæ˜¾ç¤ºåº”ç”¨ã€‚æ‰“å¼€å¹¶ç¡®è®¤ç»™å®šçš„å›¾åƒæ–‡ä»¶ã€‚è¿™ä¸ªæ˜¯ä¸€ä¸ªæ‡’æ“ä½œï¼›è¯¥å‡½æ•°åªä¼šè¯»æ–‡ä»¶å¤´ï¼Œè€ŒçœŸå®çš„å›¾åƒæ•°æ®ç›´åˆ°è¯•å›¾å¤„ç†è¯¥æ•°æ®æ‰ä¼šä»æ–‡ä»¶è¯»å–ï¼ˆè°ƒç”¨load()æ–¹æ³•å°†å¼ºè¡ŒåŠ è½½å›¾åƒæ•°æ®ï¼‰ã€‚å¦‚æœå˜é‡modeè¢«è®¾ç½®ï¼Œé‚£å¿…é¡»æ˜¯â€œrâ€ã€‚ç”¨æˆ·å¯ä»¥ä½¿ç”¨ä¸€ä¸ªå­—ç¬¦ä¸²ï¼ˆè¡¨ç¤ºæ–‡ä»¶åç§°çš„å­—ç¬¦ä¸²ï¼‰æˆ–è€…æ–‡ä»¶å¯¹è±¡ä½œä¸ºå˜é‡fileçš„å€¼ã€‚æ–‡ä»¶å¯¹è±¡å¿…é¡»å®ç°read()ï¼Œseek()å’Œtell()æ–¹æ³•ï¼Œå¹¶ä¸”ä»¥äºŒè¿›åˆ¶æ¨¡å¼æ‰“å¼€ã€‚ Image.new(mode,size,color=0) 123from PIL import Image,ImageColorim = Image.new(&#x27;RGB&#x27;,(200,200),color=&quot;red&quot;)im.show() Image.fromarray(obj,mode=None) obj-æ•°ç»„æ¥å£å¯¹è±¡ mode-ä¸è‡ªåŠ¨åˆ¤æ–­ 123456from PIL import Imageimport numpy as nparr = (np.eye(300)*255) # äºŒç»´æ•°ç»„im = Image.fromarray(arr) # è½¬æ¢ä¸ºå›¾åƒim.show() 12345678910111213141516from PIL import Imageimport numpy as npimage = Image.open(&quot;personal/21.jpg&quot;)image1 = image.resize((200,200)) # resizedata = image1.getdata() # è½¬æ¢ä¸ºæ•°ç»„åºåˆ—print(list(data)) # æŸ¥çœ‹å…·ä½“æ•°æ®éœ€è¦ä½¿ç”¨ list() è½¬æ¢obj = []for t in data: obj.append([sum(t) / 3]) # ç°åº¦æ–¹æ³•ï¼šRGBä¸‰ä¸ªåˆ†é‡çš„å‡å€¼# å˜æˆ 200 * 200 çš„äºŒç»´æ•°ç»„obj = np.array(obj).reshape((200,200))print(obj)im = Image.fromarray(obj)im.show() [[223. 222.66666667 222. ... 240.66666667 240.66666667 240.66666667] [222.66666667 222.66666667 221.66666667 ... 240.66666667 241. 240.66666667] [222.33333333 221.66666667 221.33333333 ... 240.66666667 240.66666667 240.33333333] ... [120.33333333 118.33333333 145.66666667 ... 216.66666667 189. 189.33333333] [119. 133.33333333 166. ... 205. 188. 190. ] [125.33333333 162.66666667 163. ... 196.33333333 188.33333333 190. ]] è¾“å‡ºå¦‚ä¸‹ï¼š å›¾åƒå¤„ç† å›¾åƒæ··åˆ é€æ˜åº¦æ··åˆ Image.blend(im1,im2,alpha) im1:Imageå¯¹è±¡ï¼Œé€æ˜åº¦ä¸º(1-alpha) im2:Imageå¯¹è±¡ï¼Œé€æ˜åº¦ä¸º(alpha) alpha:é€æ˜åº¦(0~1). æ³¨æ„ï¼šim1å’Œim2çš„å¤§å°å¿…é¡»ä¸€æ ·ï¼Œä¸”æ¨¡å¼ä¸ºRGB 123456from PIL import Imageim1 = Image.open(&#x27;personal/10.jpg&#x27;).convert(mode=&#x27;RGB&#x27;)im2 = Image.new (&#x27;RGB&#x27;,im1.size,&#x27;blue&#x27;)im1.show()Image.blend(im1,im2,0.2).show() æ•ˆæœå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š é®ç½©æ··åˆ Image.composite(im1,im2,mask) å‡ä¸ºImageå¯¹è±¡ï¼Œä½¿ç”¨maskæ¥æ··åˆim1å’Œim2 è¿™é‡Œä¸‰ä¸ªImageå¯¹è±¡çš„sizeå’Œmodeéƒ½å¿…é¡»ç›¸åŒ 12345678910from PIL import Imageim1 = Image.open(&#x27;personal/7.jpg&#x27;)im2 = Image.open(&#x27;personal/14.jpg&#x27;)print(im1.mode)print(im2.mode)print(im1.size)print(im3.size)r, g, b = im2.split()Image.composite(im1,im2,b).show() RGB RGB (3840, 2160) (3840, 2160) æ•ˆæœå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š å›¾åƒç¼©æ”¾ æŒ‰åƒç´ ç¼©æ”¾ Image.eval(im,fun) ç¬¬ä¸€ä¸ªä¸ºImageå¯¹è±¡ ç¬¬äºŒä¸ªä¸ºä¸€ä¸ªæ–¹æ³•ï¼ˆå‡½æ•°ï¼‰ï¼Œè¯¥å‡½æ•°ä¼ å…¥ä¸€ä¸ªå‚æ•°ï¼Œå³åƒç´ ç‚¹ã€‚ è¯¥å‡½æ•°ä¼šå¯¹å›¾ç‰‡ä¸­æ¯ä¸ªåƒç´ ç‚¹è¿›è¡Œå‡½æ•°å†…çš„æ“ä½œ 1234567891011from PIL import Imageim = Image.open(&quot;personal/hira.png&quot;)# lambda è¡¨è¾¾å¼Image.eval(im,lambda x:x*2).show()# func è¡¨è¾¾å¼def func(x): return x*1.5Image.eval(im,func).show() æ•ˆæœå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š(1å€/1.5å€/2å€) æŒ‰å°ºå¯¸ç¼©æ”¾ Image.thumbnail() ä¸åŒäºå‰é¢ç›´æ¥é€šè¿‡Imageè°ƒç”¨æ–¹æ³•ï¼Œè€Œæ˜¯ä½¿ç”¨Imageçš„å…·ä½“å®ä¾‹imè°ƒç”¨thumbnailæ–¹æ³• è¿™é‡Œç¼©æ”¾å›¾åƒå¹¶ä¸ä¼šå¯¹å›¾åƒè¿›è¡Œå˜å½¢ï¼Œå³æ˜¾ç¤ºæ•ˆæœæ˜¯ä¸€æ ·çš„ã€‚ 12345678910from PIL import Imageim1 = Image.open(&quot;personal/11.jpg&quot;)im2 = im1.copy()# å°†å¤åˆ¶åçš„å›¾åƒè¿›è¡Œç¼©æ”¾ï¼Œä¼ å…¥ä¸€ä¸ªå…ƒç»„im2.thumbnail((1024,1024))im2.show()print(&quot;im1çš„å¤§å°&quot;, im1.size)print(&quot;im2çš„å¤§å°&quot;, im2.size) im1çš„å¤§å° (2156, 3291) im2çš„å¤§å° (671, 1024) å›¾åƒçš„å‰ªåˆ‡ä¸ç²˜è´´ å›¾åƒç²˜è´´ Image.paste(im,box,mask=None) Imageçš„å…·ä½“å®ä¾‹è°ƒç”¨æ–¹æ³• imä¸ºImageå¯¹è±¡ï¼Œboxä¸ºè¦ç²˜è´´çš„åŒºåŸŸï¼Œmaskä¸ºé®ç½©ã€‚ boxå‚æ•°æœ‰ä¸‰ç§å½¢å¼: (x1,y1):å°†imå·¦ä¸Šè§’å¯¹é½(x1,y1)ç‚¹ï¼Œå…¶ä½™éƒ¨åˆ†ç²˜è´´ï¼Œå‰©ä½™éƒ¨åˆ†æŠ›å¼ƒ (x1,y1,x2,y2):å°†imç²˜è´´è‡³æ­¤åŒºåŸŸ None:æ­¤æ—¶imå¿…é¡»ä¸åŸå›¾åƒå¤§å°ä¸€è‡´ å›¾åƒå‰ªè£ Image.crop(box) 123456from PIL import Imageim1 = Image.open(&quot;personal/111.PNG&quot;) im2 = Image.open(&quot;personal/image_6.png&quot;)im1_crop = im1.crop((0, 0, 671, 1024))im2.paste(im1_crop,(200,0))im2.show() æ•ˆæœå¦‚å›¾æ‰€ç¤ºï¼š å…¶ä»– è½¬æ¢å›¾åƒæ ¼å¼ å°†.pngè½¬æ¢ä¸º.jpg,æ³¨æ„ï¼šä¸èƒ½å°†RGBAè½¬åŒ–ä¸º.jpg 123456from PIL import Imageim = Image.open(&quot;personal/10.png&quot;,&quot;r&quot;)print(im)im.save(&quot;personal/10.jpg&quot;) # å°†.pngè½¬åŒ–ä¸º.jpgim = Image.open(&quot;personal/10.jpg&quot;,&quot;r&quot;)print(im.format,im.size,im.mode) &lt;PIL.PngImagePlugin.PngImageFile image mode=RGB size=1920x1080 at 0x255C7FE22E0&gt; JPEG (1920, 1080) RGB","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"æ•°å­—å›¾åƒå¤„ç†","slug":"æ•°å­—å›¾åƒå¤„ç†","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"author":"tugumineko"},{"title":"å†’æ³¡æ’åºæ›²çº¿çš„æ¨å¯¼","slug":"A-Rigorous-Derivation-of-the-Bubble-Sort-Curve","date":"2024-05-05T04:42:10.000Z","updated":"2024-05-05T11:42:08.289Z","comments":true,"path":"2024/05/05/A-Rigorous-Derivation-of-the-Bubble-Sort-Curve/","permalink":"http://example.com/2024/05/05/A-Rigorous-Derivation-of-the-Bubble-Sort-Curve/","excerpt":"","text":"å†’æ³¡æ’åº éå†ä¸€ç»„æ•°å­—ä»¥ç›¸é‚»äº¤æ¢çš„æ–¹å¼æ‰¾åˆ°è¿™ä¸€ç»„æ•°å­—çš„æœ€å€¼çš„æ’åºæ–¹å¼ è¿™é‡Œè®¨è®ºçš„æ˜¯ä»å°åˆ°å¤§çš„æ’åº å†’æ³¡æ’åºæ›²çº¿ ç»™å‡ºå®šä¹‰ å‡è®¾ï¼šåœ¨å®Œå…¨å‡åŒ€ä¸”éšæœºæ‰“ä¹±ä¸€ç»„æ•°å­—çš„æƒ…å†µä¸‹è¿›è¡Œå†’æ³¡æ’åºï¼Œå°†æ•°å­—çš„å¤§å°ä»¥æŸ±çš„é«˜åº¦è¡¨ç¤ºï¼Œåœ¨ä¸åŒçš„æ—¶é—´ä¸‹ä¼šç”Ÿæˆä¸åŒçš„å½¢çŠ¶ã€‚å‡è®¾è¿™ä¸€å½¢çŠ¶å¯ä»¥ç”¨ä¸€ä¸ªè¿‘ä¼¼å‡½æ•°æ¥è¡¨ç¤ºï¼Œè¿™ä¸ªå‡½æ•°çš„æ›²çº¿å°±æ˜¯å†’æ³¡æ’åºæ›²çº¿ã€‚ å»ºç«‹æ¨¡å‹ ä¸ºæ–¹ä¾¿è¡¨ç¤ºï¼šæˆ‘ä»¬è®¾ç½®è¿™å¼ å›¾ç‰‡çš„é•¿å’Œå®½å‡ä¸ºå•ä½1ï¼Œç»™å®šå˜é‡æ—¶é—´tï¼Œå½“t=0æ—¶ï¼Œä¸ºéšæœºæ‰“ä¹±çš„çŠ¶æ€ï¼›å½“t=1æ—¶ï¼Œä¸ºæ’åºå®Œæˆçš„çŠ¶æ€ t=0 t=1 è¿™æ ·ï¼Œå°±å¯ä»¥å»ºç«‹ä¸€ä¸ªå…³äºxå’Œtçš„äºŒå…ƒå‡½æ•° f(x,t)={xx&gt;1âˆ’t???xâ‰¤1âˆ’tf(x, t)=\\left\\{\\begin{array}{ll}x &amp; x&gt;1-t \\\\???&amp; x \\leq 1-t\\end{array}\\right. f(x,t)={x???â€‹x&gt;1âˆ’txâ‰¤1âˆ’tâ€‹ æ˜¾ç„¶ï¼Œå›¾åƒåˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼š å½“xå¤§äº1-tçš„æ—¶å€™ï¼Œå‡½æ•°å€¼ä¸ºå…¶æœ¬èº«ã€‚ æˆ‘ä»¬éœ€è¦æ¨å¯¼ï¼Œå½“xå°äº1-tçš„æ—¶å€™çš„å‡½æ•°å€¼ã€‚ æ‰€ä»¥ç¬¬ä¸€éƒ¨åˆ†çš„æ›²çº¿å‘¢ï¼Ÿ æ¨å¯¼æ›²çº¿ å…³é”®åœ¨äº å› ä¸ºå†’æ³¡æ’åºæ¯ä¸€æ¬¡éå†åªæ”¹å˜ç›¸é‚»å…ƒç´ ï¼Œå‰né¡¹å…ƒç´ åœ¨ç»è¿‡ç›¸åŒæ¬¡æ•°çš„éå†çš„æƒ…å†µä¸‹çš„å½¢çŠ¶æ˜¯ä¸å˜çš„ï¼Œç”±äºæˆ‘ä»¬è®¾ç½®äº†å•ä½å®½â€“&gt;è¿™ä¸€éƒ¨åˆ†çš„æ›²çº¿åªéštçš„å¢é•¿è€Œæ¨ªå‘æ‹‰ä¼¸ æ•°æ®æ˜¯å®Œå…¨å‡åŒ€ä¸”éšæœºæ‰“ä¹±çš„ï¼Œæ‰€ä»¥å³ä½¿å®ƒä»¬çš„æ•°æ®ä¸å®Œå…¨ç›¸åŒï¼Œå®ƒä»¬å½¢æˆçš„å¼§çº¿ä¹Ÿéƒ½æ˜¯ç›¸åŒçš„â€“&gt;åœ¨æ•°æ®é‡ä¸åŒçš„æƒ…å†µä¸‹ï¼Œå–å‰né¡¹å…ƒç´ åœ¨æ‹‰ä¼¸å‰æœ‰ç›¸åŒçš„å½¢çŠ¶ æ¨å¯¼è¿‡ç¨‹ æˆ‘ä»¬åœ¨tçš„ä¸¤ä¸ªä¸åŒå€¼å¤„ç»˜åˆ¶å‡½æ•°ï¼Œè®°ä¸ºf(x,a)f(x, a)f(x,a)å’Œf(x,b)f(x, b)f(x,b) ä¸ºäº†åˆ©ç”¨å…ˆå‰æ¨å¯¼å‡ºçš„æ€§è´¨ï¼Œæˆ‘ä»¬å°†å›¾åƒtè¾ƒå¤§çš„ä¸€æ–¹è¿›è¡Œæ‹‰ä¼¸ ç”±äºå‡½æ•°æ˜¯è¿ç»­çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥çŸ¥é“è¯¥ç‚¹åæ ‡ä¸º(1âˆ’a,1âˆ’a)(1-a,1-a)(1âˆ’a,1âˆ’a)â€“&gt;f(1âˆ’a,a)=1âˆ’af(1-a,a)=1-af(1âˆ’a,a)=1âˆ’a ä»¤tä»1åˆ°0å‘ˆçº¿æ€§å˜åŒ–ï¼Œæˆ‘ä»¬å¾—åˆ°äº†æ¨å¯¼å¼f(1âˆ’a,a)=1âˆ’af(1-a,a)=1-af(1âˆ’a,a)=1âˆ’a ä»£å…¥åˆ°f(xâ‹…ba,b)f(x\\cdot \\frac{b}{a},b)f(xâ‹…abâ€‹,b)ä¸­ï¼Œåœ¨è¿›è¡Œå‹ç¼©ï¼Œå°±å¾—åˆ°äº†å‡½æ•°å›¾åƒã€‚ æ¨å¯¼è¿‡ç¨‹å¦‚ä¸‹ åœ¨f(xâ‹…ba,b)=f(x,a),xâ‰¤1âˆ’aä¸­ï¼Œä»¤x=1âˆ’a,åˆ™æœ‰ï¼šåœ¨f(x\\cdot \\frac{b}{a}, b)=f(x,a),x\\le1-aä¸­ï¼Œ ä»¤ x = 1-a,åˆ™æœ‰ï¼š åœ¨f(xâ‹…abâ€‹,b)=f(x,a),xâ‰¤1âˆ’aä¸­ï¼Œä»¤x=1âˆ’a,åˆ™æœ‰ï¼š f((1âˆ’a)â‹…ba,b)=f(1âˆ’a,a)=1âˆ’a.f((1-a)\\cdot \\frac{b}{a}, b)=f(1-a,a)=1-a. f((1âˆ’a)â‹…abâ€‹,b)=f(1âˆ’a,a)=1âˆ’a. ä»¤x=(1âˆ’a)â‹…ba,t=bï¼Œåˆ™æœ‰ï¼ša=tx+tä»¤x=(1-a)\\cdot \\frac{b}{a},t=bï¼Œåˆ™æœ‰ï¼š a=\\frac{t}{x+t} ä»¤x=(1âˆ’a)â‹…abâ€‹,t=bï¼Œåˆ™æœ‰ï¼ša=x+ttâ€‹ æ‰€ä»¥f(x,t)={xx&gt;1âˆ’txx+txâ‰¤1âˆ’tæ‰€ä»¥f(x, t)=\\left\\{\\begin{array}{ll}x &amp; x&gt;1-t \\\\\\frac{x}{x+t} &amp; x \\leq 1-t\\end{array}\\right. æ‰€ä»¥f(x,t)={xx+txâ€‹â€‹x&gt;1âˆ’txâ‰¤1âˆ’tâ€‹","categories":[],"tags":[{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"tugumineko"},{"title":"PyTorchæ·±åº¦å­¦ä¹ ","slug":"PyTorchæ·±åº¦å­¦ä¹ ","date":"2024-05-04T16:38:25.000Z","updated":"2024-11-03T12:06:12.743Z","comments":true,"path":"2024/05/05/PyTorchæ·±åº¦å­¦ä¹ /","permalink":"http://example.com/2024/05/05/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"PyTorchæ·±åº¦å­¦ä¹  ç¥ç»ç½‘ç»œ å±‚å±‚ç»„æˆï¼Œå¤šè¾¾å‡ ç™¾å±‚æˆ–è€…ä¸Šåƒå±‚çš„å«ä½œæ·±åº¦ç¥ç»ç½‘ç»œã€‚ä»æµ·é‡çš„æ•°æ®ä¸­è¿›è¡Œå¤„ç†å’Œåˆ†æï¼Œæç‚¼å‡ºç‰©ä½“çš„ç‰¹å¾ï¼Œå»ºç«‹æ¨¡å‹ï¼Œä»è€Œå®ç°å¤„ç†å¤§é‡æ•°æ®ï¼Œè§£å†³å¤æ‚çš„ä»»åŠ¡ã€‚ æ¶æ„ï¼šæ¯ä¸ªæ•°æ®ä¸ä¸åŒæƒé‡ç›¸ä¹˜ååŠ å’Œï¼ŒåŠ ä¸Šåå·®åæ¿€æ´»å†å°†ç»“æœä¼ å…¥ä¸‹ä¸€ä¸ªç¥ç»ç½‘ç»œã€‚ æ„å»ºä¸€ä¸ªç¥ç»ç½‘ç»œéœ€è¦ä¸‹é¢äº”ä¸ªæ­¥éª¤ï¼š å‡†å¤‡æ•°æ® å®šä¹‰æ¨¡å‹ è®­ç»ƒæ¨¡å‹ è¯„ä¼°é¢„æµ‹ åšå‡ºé¢„æµ‹ é‚£ä¹ˆæˆ‘ä»¬æ€ä¹ˆé«˜æ•ˆå¿«é€Ÿåœ°å®Œæˆä¸Šè¿°äº”ä¸ªæ­¥éª¤å‘¢ï¼Ÿ å·ç§¯ç¥ç»ç½‘ç»œCNN(Convolution Neural Networks) ä¾‹ï¼šLeNet-5 PyTorchæ˜¯ä¸€æ¬¾æµè¡Œçš„æ·±åº¦å­¦ä¹ æ¡†æ¶ï¼Œæœ‰ç€ä¸°å¯Œçš„å·¥å…·åŒ… åˆ©ç”¨PyTorchè¯†åˆ«æ•°å­— å‡†å¤‡æ•°æ®ï¼šè®¡ç®—æœºå°†å›¾ç‰‡è¿›è¡Œåˆ†å‰²ï¼Œå°†å›¾ç‰‡è½¬åŒ–æˆæ•°å­—ä¿¡æ¯ å®šä¹‰æ¨¡å‹ï¼š å·ç§¯å±‚ï¼šæŠŠå›¾åƒå˜ä¸ºä¸€ç³»åˆ—æ•°æ®èŒƒå›´ä¸º0~1çš„çŸ©é˜µã€‚ æ± åŒ–å±‚ï¼šæŠŠä¸€å¼ å¾ˆå¤§çš„å›¾åƒå‹ç¼©ï¼Œå˜æˆä¸€å¼ æ›´å°æ›´å®¹æ˜“è®¡ç®—çš„å›¾åƒçŸ©é˜µã€‚ å…¨è¿æ¥å±‚ï¼šæŠŠå¤„ç†åçš„å›¾åƒè½¬åŒ–æˆä¸€æ®µæ•°æ®ã€‚ è®­ç»ƒæ¨¡å‹ï¼š å°†è®­ç»ƒæ•°æ®è¾“å…¥æ¨¡å‹å¹¶è®¡ç®—æŸå¤±å¹¶è°ƒæ•´æ›´æ–°å‚æ•°ã€‚é‡å¤è¿›è¡Œå¤šä¸ªå‘¨æœŸåç›´åˆ°æ¨¡å‹èƒ½å¤Ÿå¾ˆå¥½åœ°è¯†åˆ«æ•°å­—ã€‚ æŸå¤±å‡½æ•°ï¼šäº¤å‰ç†µæŸå¤±(Cross Entropy Loss) ä¼˜åŒ–å™¨ï¼šéšæœºæ¢¯åº¦ä¸‹é™(SGD) è¯„ä¼°æ¨¡å‹+é¢„æµ‹ å·ç§¯å±‚(Convolutions):æå–ç‰¹å¾ æ± åŒ–å±‚(Subsampling):å°†ç‰¹å¾æå–åˆ°æœ€çªå‡ºçš„å…ƒç´  å…¨è¿æ¥å±‚(Full connection):æœ€åOUTPUTä¸ºä¸€ä¸ªåç»´å‘é‡ï¼Œæ¯ä¸€ç»´ä»£è¡¨ä¸€ä¸ªæ•°å­—ç±»åˆ«çš„é¢„æµ‹æ¦‚ç‡ PyTorchå®æ“ éªŒè¯/å®‰è£…pytorch 12import torchprint(torch.__version__) # torch.__version__ è¿”å›å®‰è£…çš„ PyTorch çš„ç‰ˆæœ¬å· 2.3.0+cpu å‡†å¤‡æ•°æ® æ•°æ®ä¸‹è½½ï¼šå°†æ•°æ®å˜ä¸ºé€‚åˆç¥ç»ç½‘ç»œæ¨¡å‹è®­ç»ƒçš„æ ¼å¼ åŠ è½½æ•°æ®ï¼šç»è¿‡é¢„å¤„ç†ï¼Œä½¿å¾—æ•°å­—éƒ½ä½äºå›¾åƒçš„ä¸­å¿ƒä½ç½®ï¼Œæ‰‹å†™æ•°æ®åˆ†ç±» 12345678from torchvision.datasets import MNISTfrom torchvision.transforms import ToTensor# å®šä¹‰ä¿å­˜æˆ–åŠ è½½æ•°æ®é›†çš„ä½ç½®path = &#x27;~/.torch/datasets/mnist&#x27;# ä¸‹è½½å¹¶å®šä¹‰æ•°æ®é›†train = MNIST(path, train=True, download=True, transform=ToTensor())test = MNIST(path, train=True, download=True, transform=ToTensor()) å¤„ç†å›¾åƒæ•°æ® PILå›¾åƒï¼šä»¥åƒç´ æ•°ç»„çš„å½¢å¼ä¿å­˜ï¼Œæ¯ä¸ªåƒç´ ç‚¹æ•°å­—èŒƒå›´ä¸º0~1ï¼Œè¿™æ ·å°±ä¼šæœ‰æ— é™çš„ç²¾åº¦ 123456789101112131415from PIL import Imageimport torchvision.transforms as transforms# Load the image using PILimage_path = &#x27;./personal/1.png&#x27;image = Image.open(image_path)# Convert the image to a PyTorch tensortransform = transforms.ToTensor()tensor = transform(image)print(image)# Check the tensor shape to confirm conversiontensor.shape, tensor.dtype # (torch.Size([3, 1024, 1024]), torch.float32) &lt;PIL.PngImagePlugin.PngImageFile image mode=RGBA size=1920x1200 at 0x1B6D50F8F10&gt; (torch.Size([4, 1200, 1920]), torch.float32) æ•°æ®é›†åˆ’åˆ†: å°†æ•°æ®åˆ’åˆ†ä¸ºæ›´å°çš„batch(å­æ•°æ®é›†),å¢åŠ å¤„ç†å¤§é‡æ•°æ®çš„æ•ˆç‡ é€šè¿‡æšä¸¾çš„æ–¹å¼è¿›è¡Œè®­ç»ƒ 1234# å®šä¹‰å¦‚ä½•æšä¸¾æ•°æ®é›†from torch.utils.data import DataLoadertrain_dl = DataLoader(train, batch_size=64, shuffle=True)test_dl = DataLoader(test, batch_size=1024,shuffle=False) å®šä¹‰æ¨¡å‹ ç‰¹å¾æå– å·ç§¯ï¼šå°†çŸ©é˜µå’Œä¸€ç»„æƒé‡ç›¸ä¹˜ï¼Œç”Ÿæˆä¸€ä¸ªæ–°çš„äºŒç»´æ•°ç»„ å·ç§¯æ ¸(kernel),å¯¹æŸä¸ªå±€éƒ¨çš„åŠ æƒæ±‚å’Œï¼Œå†³å®šäº†æƒé‡çŸ©é˜µ ç‰¹å¾å›¾(feature map),ä¸€ä¸ªç‰¹å¾å›¾å¯¹åº”ä¸€ä¸ªå›¾åƒçš„ä¸€ä¸ªç‰¹å¾ ä¸åŒçš„å·ç§¯æ ¸å’ŒåŒä¸€ä¸ªå·ç§¯ç»„åˆï¼Œç”Ÿæˆäº†ä¸åŒçš„ç‰¹å¾å›¾ï¼Œè¿™äº›äºŒç»´çš„ç‰¹å¾å›¾å®é™…ä¸Šå®ç°äº†ä¸€ä¸ªä¸‰ç»´çš„å·ç§¯å±‚ã€‚å±‚æ•°è¶Šé«˜ï¼Œå¯ä»¥è¯†åˆ«çš„ç‰¹å¾è¶Šé«˜çº§ å±‚ä¸å±‚ä¹‹é—´ä¼šæœ‰è‹¥å¹²ä¸ªå·ç§¯æ ¸ï¼Œä¸Šä¸€å±‚çš„æ¯ä¸ªç‰¹å¾å›¾è·Ÿæ¯ä¸ªå·ç§¯æ ¸åšå·ç§¯ï¼Œéƒ½ä¼šäº§ç”Ÿä¸‹ä¸€å±‚çš„ä¸€ä¸ªç‰¹å¾å›¾ è¾“å…¥çš„ç‰¹å¾å›¾ä¹Ÿå¯ä»¥æ˜¯å¤šä¸ªï¼Œä¾‹å¦‚RGB æ± åŒ–ï¼š é€æ¸ç¼©å°è¡¨ç¤ºç©ºé—´çš„å¤§å°ä»¥æé«˜è®¡ç®—æ•ˆç‡ ä¼šå•ç‹¬å¯¹æ¯ä¸ªç‰¹å¾å›¾è¿›è¡Œè¿ç®— å¸¸ç”¨æ–¹æ³•ï¼šæœ€å¤§æ± åŒ– å…¨è¿æ¥å±‚ï¼š å¯¹å‰é¢å·ç§¯å±‚æå–çš„ç‰¹å¾è¿›è¡Œæ•´åˆï¼Œä»¥è¿›è¡Œæœ€ç»ˆçš„åˆ†ç±»å†³ç­– å°†å‰ä¸€å±‚çš„æ‰€æœ‰ç¥ç»å…ƒä¸å½“å‰å±‚çš„æ¯ä¸ªç¥ç»å…ƒç›¸è¿æ¥ï¼Œä»è€Œä½¿ç½‘ç»œèƒ½å¤Ÿç†è§£å¹¶å­¦ä¹ åˆ°å›¾åƒæ›´åŠ å¤æ‚çš„ç‰¹å¾ å®šä¹‰ç»§æ‰¿è‡ªModuleçˆ¶ç±»çš„ç±»CNN å»ºç«‹æ–¹æ³•__init__ ç¬¬ä¸€ä¸ªå·ç§¯å±‚ä½¿ç”¨Conv2dåˆ›å»ºäºŒç»´å·ç§¯å±‚ï¼Œæ¥æ”¶n_channelsä¸ªè¾“å…¥é€šé“ï¼Œè¾“å‡º32ä¸ªç‰¹å¾å›¾ï¼Œä½¿ç”¨3X3çš„å·ç§¯æ ¸è¿›è¡Œå·ç§¯è¿ç®— ä½¿ç”¨kaiming_uniform_æ–¹æ³•åˆå§‹åŒ–æƒé‡(weightä¹Ÿç§°ä¸ºå‚æ•°)ï¼Œå¹¶è®¾ç½®æ¿€æ´»å‡½æ•°ä¸ºrelu (æœºå™¨å­¦ä¹ çš„å…³é”®æ˜¯æ›´æ–°æ¯æ¬¡å·ç§¯çš„æƒé‡) æ¿€æ´»å‡½æ•°ï¼Œåšå‡ºæ˜¯å¦è¦ä¼ é€’ä¿¡æ¯çš„å†³å®šé—¨ ç¬¬ä¸€ä¸ªæ± åŒ–å±‚å°†ç‰¹å¾å›¾åˆ†å‰²æˆ2X2å¤§å°çš„åŒºåŸŸï¼Œå¹¶ä»æ¯ä¸ªåŒºåŸŸä¸­å–æœ€å¤§å€¼(æœ€å¤§æ± åŒ–) stride(2,2)æ˜¯æ± åŒ–æ“ä½œçš„æ­¥é•¿ è¿™æ„å‘³ç€æ± åŒ–çª—å£æ¯æ¬¡ç§»åŠ¨ä¸¤ä¸ªåƒç´ ï¼Œæœ‰æ•ˆå‡å°‘äº†ç‰¹å¾å›¾çš„ç»´åº¦ ä½œç”¨ï¼š ä¿ç•™äº†æœ€å¤§ç‰¹å¾çš„åŒæ—¶å‡å°‘äº†å°ºå¯¸ å‡å°‘è¿‡æ‹Ÿåˆï¼Œå‡å°‘æ³›åŒ–èƒ½åŠ› ç¬¬äºŒå±‚å·ç§¯å±‚çš„ä½œç”¨æ˜¯è¿›ä¸€æ­¥æå–æ± åŒ–å±‚çš„ç‰¹å¾ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯Conv2dçš„ç¬¬ä¸€ä¸ªå‚æ•°ç”±n_channelså˜æˆäº†32ï¼Œè¿™æ˜¯å› ä¸ºè¿™é‡Œçš„è¾“å…¥æ˜¯ç¬¬ä¸€å±‚å·ç§¯å±‚çš„è¾“å…¥ è¿™æ„å‘³ç€æˆ‘ä»¬ä»32ä¸ª3x3çš„å·ç§¯æ ¸ä¸­è¿›è¡Œæ“ä½œï¼Œå¹¶å°†ä»æ¯ä¸ªä½ç½®çš„3x3åŒºåŸŸæå–ç‰¹å¾ï¼Œå¹¶è¾“å‡º32ä¸ªæ–°çš„ç‰¹å¾é€šé“ ç¬¬äºŒå±‚æ± åŒ–çš„ä½œç”¨ï¼š é€šè¿‡å‡å°‘ç‰¹å¾å›¾çš„ç©ºé—´å°ºå¯¸ï¼Œæ¥é™ä½åç»­ç½‘ç»œå±‚çš„è®¡ç®—è´Ÿè½½ åœ¨ä¸€å®šç¨‹åº¦ä¸Šå¢å¼ºæ¨¡å‹çš„æŠ—å™ªå£°èƒ½åŠ› é€šè¿‡è¿™ä¸¤å±‚çš„è¿ç»­æ“ä½œï¼Œæˆ‘ä»¬çš„CNNèƒ½å¤Ÿé€æ¸æŠ½è±¡å›¾åƒå†…å®¹ï¼Œå°†åŸå§‹è¾“å…¥è½¬åŒ–ä¸ºé«˜çº§ç‰¹å¾ï¼Œä»è€Œå¯¹åç»­çš„åˆ†ç±»æˆ–å…¶ä»–ä»»åŠ¡æä¾›å¿…è¦çš„ä¿¡æ¯ ç¬¬ä¸€ä¸ªå…¨è¿æ¥å±‚å°†5x5x32ä¸ªçº¿ç´¢è½¬åŒ–ä¸º100ä¸ªæœ‰æ„ä¹‰çš„æ¦‚å¿µ ä½¿ç”¨kaiming_uniformæ¥åˆå§‹åŒ–è¿™ä¸ªå¤„ç†ä¸­å¿ƒçš„è¿æ¥æƒé‡ RELUæ¿€æ´»å‡½æ•°å¼•å…¥äº†ä¸€ç§éçº¿æ€§çš„æ€è€ƒæ–¹å¼ï¼Œè®©ç¥ç»ç½‘ç»œæ•æ‰åˆ°æ›´åŠ å¤æ‚çš„æ¨¡å¼å’Œè”ç³» ç¬¬äºŒä¸ªå…¨è¿æ¥å±‚å°†æç‚¼å‡ºçš„100ä¸ªæ¦‚å¿µè¿›ä¸€æ­¥ç®€åŒ–ä¸º10ä¸ªæœ€ç»ˆçš„å†³ç­–ï¼Œæ¯ä¸€ä¸ªå†³ç­–éƒ½å¯¹åº”ç€ä¸€ä¸ªæ‰‹å†™æ•°å­—çš„ç±»åˆ«ï¼ˆ0~9ï¼‰ ä½¿ç”¨xavier_uniform_çš„æ–¹æ³•æ¥åˆå§‹åŒ–æ¯ä¸ªè¿æ¥çš„æƒé‡ ä½¿ç¥ç»ç½‘ç»œçš„ç½‘æ—¢ä¸æ˜¯å¤ªç´§ä¹Ÿä¸æ˜¯å¤ªæ¾â€“æƒé‡é€‚ä¸­ï¼ŒæŸ”éŸ§æ€§ä¸å¼ºåº¦å…¼å¾— å¦‚æœæƒé‡è¿‡å¤§â€“ç¥ç»ç½‘ç»œåƒµç¡¬ï¼Œéš¾ä»¥æ•æ‰ç»†å¾®çš„ç‰¹å¾ å¦‚æœæƒé‡è¿‡å°â€“ç¥ç»ç½‘ç»œæ¾æ•£ï¼Œå®¹æ˜“é”™è¿‡é‡è¦çš„æ¨¡å¼ xavier_uniform_é€šè¿‡åˆå§‹åŒ–æƒé‡ä¸ºä¸€ä¸ªå‡åŒ€åˆ†å¸ƒçš„å€¼ï¼Œå¸®åŠ©ç¥ç»ç½‘ç»œä¸€å¼€å§‹æ—¶å°±ä¿æŒäº†ä¸€ç§å¹³è¡¡çŠ¶æ€ Softmaxä¸ºæ¿€æ´»å‡½æ•°ï¼Œå®ƒå°†å†³ç­–ä¸­å¿ƒçš„è¾“å‡ºè½¬æ¢ä¸ºæ¦‚ç‡åˆ†å¸ƒã€‚ä½¿ç¥ç»ç½‘ç»œèƒ½å¤Ÿæ ¹æ®æ¦‚ç‡æœ€é«˜çš„ç±»åˆ«æ¥åšå‡ºæœ€ç»ˆçš„é¢„æµ‹ 123456789101112131415161718192021222324252627from torch.nn import Moduleclass CNN(Module): # å®šä¹‰æ¨¡å‹å±æ€§ def __init__(self, n_channels): super().__init__() # è¾“å…¥åˆ°å·ç§¯å±‚ 1 self.hidden1 = Conv2d(n_channels, 32, (3,3)) kaiming_uniform_(self.hidden1.weight, nonlinearity=&#x27;relu&#x27;) self.act1 = ReLU() # æ± åŒ–å±‚ 1 self.pool1 = MaxPool2d((2,2), stride=(2,2)) # å·ç§¯å±‚ 2 self.hidden2 = Conv2d(32, 32, (3, 3)) kaiming_uniform_(self.hidden2.weight, nonlinearity=&#x27;relu&#x27;) self.act2 = ReLU() # æ± åŒ–å±‚ 2 self.pool2 = MaxPool2d((2,2), stride(2,2)) # å…¨è¿æ¥å±‚ 1 self.hidden3 = Linear(5*5*32, 100) kaiming_uniform_(self.hidden3.weight, nonlinearity=&#x27;relu&#x27;) self.act3 = RELU() # å…¨è¿æ¥å±‚ 2 self.hidden4 = Linear(100, 10) xavier_uniform_(self.hidden4.weight) self.act4 = Softmax(dim=1) å‰å‘ä¼ æ’­ å®šä¹‰ æŒ‡æ•°æ®åœ¨ç¥ç»ç½‘ç»œä¸­çš„æµåŠ¨æ–¹å‘ è¾“å…¥å±‚ -&gt; éšè—å±‚ -&gt; è¾“å‡ºå±‚ åœ¨å·ç§¯ç¥ç»ç½‘ç»œä¸­èµ·åˆ°å…³é”®ä½œç”¨ ç›®çš„ è®¡ç®—è¾“å‡º: æ ¹æ®è¾“å…¥æ•°æ®å’Œç½‘ç»œç»“æ„è®¡ç®—ç¥ç»ç½‘ç»œçš„è¾“å‡º æŸå¤±å‡½æ•°è¯„ä¼°: ä½¿ç”¨è¾“å‡ºæ•°æ®ä¸çœŸå®æ ‡ç­¾è®¡ç®—æŸå¤±å‡½æ•°ï¼Œä»¥è¯„ä¼°æ¨¡å‹çš„æ€§èƒ½ åå‘ä¼ æ’­å‡†å¤‡: ä¸ºåå‘ä¼ æ’­é˜¶æ®µæä¾›å¿…è¦çš„ä¸­é—´ä¿¡æ¯ï¼Œå¦‚æ¯å±‚çš„è¾“å…¥ã€æƒé‡å’Œæ¿€æ´»å‡½æ•°çš„å¯¼æ•°ç­‰ åå‘ä¼ æ’­ ç›®çš„æ˜¯è®¡ç®—æŸå¤±å‡½æ•°å…³äºç½‘ç»œå‚æ•°çš„æ¢¯åº¦ï¼Œä»¥ä¾¿é€šè¿‡æ¢¯åº¦ä¸‹é™ç­‰ä¼˜åŒ–ç®—æ³•æ›´æ–°ç½‘ç»œçš„æƒé‡ï¼Œä»è€Œæ”¹è¿›æ¨¡å‹çš„æ€§èƒ½ å‰å‘ä¼ æ’­æ˜¯è·¯å¾„ä¸Šæ‰§è¡Œå…·ä½“çš„æ•°æ®å¤„ç†ï¼Œæ‰§è¡Œå±‚ä¸å±‚ä¹‹é—´çš„æ•°æ®ä¼ é€’å’Œå‚æ•°è®¡ç®— è€Œæ¨¡å‹æ¶æ„åˆ™æ˜¯å®šä¹‰äº†å‰å‘ä¼ æ’­çš„è·¯å¾„å’Œæ“ä½œé¡ºåº å°†æ•°æ®è¿›è¡Œè¾“å…¥è¿›å…¥ç¬¬ä¸€å±‚å·ç§¯å±‚è¿›è¡Œå¤„ç†ï¼Œç„¶åé€šè¿‡æ¿€æ´»å‡½æ•°åå†è¿›è¡Œè¿›ä¸€æ­¥çš„æ± åŒ–æ“ä½œ æ•°æ®ç»è¿‡è¿›ä¸€æ­¥çš„æå–ç‰¹å¾ï¼Œå‡å°‘ä½“ç§¯æ“ä½œã€‚ä¾‹å¦‚ç‰¹å¾å›¾ä½“ç§¯ä»(32,15,15)å˜ä¸º(32,7,7) æ•°æ®æ‰å¹³åŒ–(Flattening): å°†å¤šç»´çš„æ•°æ®ç»“æ„è½¬åŒ–ä¸ºä¸€ç»´å‘é‡å½¢å¼ï¼Œä½¿å…¶èƒ½å¤Ÿè¢«ç¥ç»ç½‘ç»œå¤„ç† å…¨è¿æ¥å±‚ self.hidden3(X) å°†æ‰å¹³åŒ–åçš„æ•°æ®ä¼ å…¥åï¼Œå°†è¾“å…¥å‘é‡ä¸æƒé‡çŸ©é˜µç›¸ä¹˜ï¼ŒåŠ ä¸Šåç½®ï¼Œç„¶åè¾“å‡ºç»“æœã€‚ 12345678910111213141516171819# å‰å‘ä¼ æ’­def forward(self, X): # è¾“å…¥åˆ°éšå±‚ 1 X = self.hidden1(X) X = self.act1(X) X = self.pool1(X) # éšå±‚ 2 X = self.hidden2(X) X = self.act2(X) X = self.pool2(X) # æ‰å¹³åŒ– X = X.view(-1, 5*5*32) # éšå±‚ 3 X = self.hidden3(X) X = self.act3(X) # è¾“å‡ºå±‚ X = self.hidden4(X) X = self.act4(X) return X æŸå¤±å‡½æ•° æä¾›äº†ä¸€ä¸ªé¢„æµ‹ç»“æœå’ŒçœŸå®ç»“æœå·®è·æœ‰å¤šå¤§çš„æµ‹é‡æ ‡å‡† ä¼˜åŒ–å™¨ æ ¹æ®æŸå¤±å‡½æ•°æä¾›çš„åé¦ˆæ¥è°ƒæ•´æ¨¡å‹å‚æ•° å†³å®šäº†å¦‚ä½•ä»¥æœ€æœ‰æ•ˆçš„æ–¹å¼æ›´æ–°å‚æ•°ä»¥æœ€å°åŒ–æŸå¤±å‡½æ•° æœ€å°æ¢¯åº¦ä¸‹é™ æœ€åŸºæœ¬ åœ¨å¤„ç†å¤æ‚æŸå¤±é¢çš„æƒ…å†µä¸‹å¯èƒ½é™·å…¥æ”¶æ•›æ…¢æˆ–å±€éƒ¨æœ€ä¼˜ Adamä¼˜åŒ–å™¨ é€šè¿‡è‡ªé€‚åº”å­¦ä¹ ç‡æ ‡å‡†ï¼Œå¸¸èƒ½æ›´å¿«åœ°æ”¶æ•›åˆ°å…¨å±€æœ€ä¼˜æˆ–è€…è¾ƒä¼˜çš„è§£ ä¸‹é¢ä½¿ç”¨äº¤å‰ç†µæŸå¤±å‡½æ•°å’Œéšæœºæ¢¯åº¦ä¸‹é™ä½œä¸ºä¼˜åŒ–å™¨ äº¤å‰ç†µæŸå¤±å‡½æ•° åˆ†ç±»é—®é¢˜ä¸­å¸¸ç”¨çš„æŸå¤±å‡½æ•° è¡¡é‡äº†é¢„æµ‹æ¦‚ç‡åˆ†å¸ƒå’Œå®é™…æ ‡ç­¾åˆ†å¸ƒä¹‹é—´çš„å·®å¼‚ å¯ä»¥æœ‰æ•ˆå¤„ç†æ¦‚ç‡è¾“å‡ºï¼Œå¹¶ä¸”åœ¨æ•°å­¦ä¸Šå¯ä»¥è§£é‡Šä¸ºæœ€å¤§ä¼¼ç„¶ä¼°è®¡ éšæœºæ¢¯åº¦ä¸‹é™ä¼˜åŒ–å™¨ model.parameters() è¡¨ç¤ºä¼˜åŒ–å™¨å°†æ›´æ–°æ‰€æœ‰æ¨¡å‹çš„è¿è¡Œå‚æ•° å­¦ä¹ ç‡(learning rate)å†³å®šäº†æ¯æ¬¡å‚æ•°æ›´æ–°çš„æ­¥é•¿å¤§å° åŠ¨é‡(momentum)é€šè¿‡åœ¨æ›´æ–°æ–¹å‘ä¸ŠåŠ é€Ÿï¼Œå¸®åŠ©ä¼˜åŒ–å™¨åœ¨éç‚¹é™„è¿‘æ›´å¿«æ”¶æ•›ï¼Œå¹¶å‡å°éœ‡è¡ è®­ç»ƒå‘¨æœŸ epoch ä¸€ä¸ªepochæŒ‡æ¨¡å‹è®­ç»ƒæ—¶ä¸€æ¬¡å®Œæ•´çš„å‰å‘ä¼ æ’­å’Œåå‘ä¼ æ’­çš„è¿‡ç¨‹ å¤šæ¬¡éå†å¯ä»¥ä½¿æ¨¡å‹æ›´å¥½åœ°å­¦ä¹ æ•°æ®çš„ç‰¹å¾ è®­ç»ƒæŸå¤± Train Loss æ¨¡å‹åœ¨è®­ç»ƒæ•°æ®é›†ä¸Šçš„å¹³å‡æŸå¤±å€¼ è®­ç»ƒæŸå¤±è¶Šä½ï¼Œè¡¨ç¤ºæ¨¡å‹å¯¹è®­ç»ƒæ•°æ®çš„æ‹Ÿåˆåº¦è¶Šå¥½ è®­ç»ƒå‡†ç¡®ç‡ Train Acc è¡¡é‡æ¨¡å‹åœ¨è®­ç»ƒæ•°æ®é›†ä¸Šé¢„æµ‹æ­£ç¡®çš„æ¯”ä¾‹ æµ‹è¯•å‡†ç¡®ç‡ Test Acc è¡¡é‡æ¨¡å‹åœ¨æµ‹è¯•æ•°æ®é›†ä¸Šé¢„æµ‹æ­£ç¡®çš„æ¯”ä¾‹ å¯ä»¥å¾ˆçœŸå®åœ°ååº”æ¨¡å‹å¯¹æœªçŸ¥æ•°æ®çš„æ³›åŒ–èƒ½åŠ› minibatch æœ‰åˆ©äºæ¨¡å‹çš„ç¨³å®šè®­ç»ƒï¼Œæé«˜è®¡ç®—æ•ˆç‡ æ¯ä¸ªminibatchåŒ…å«è¾“å…¥æ•°æ®(inputs)å’Œå¯¹åº”çš„æ ‡ç­¾(targets) 123456789101112131415161718def train_model(train_dl, model): # å®šä¹‰ä¼˜åŒ–å™¨ criterion = CrossEntropyLoss() optimizer = SGD(model.parameters(),lr=0.01,momentum=0.9) # æšä¸¾ epochs for epoch in range(10): # æšä¸¾ mini batches for i, (inputs, targets) in enumerate(train_dl): # æ¢¯åº¦æ¸…é™¤ optimizer.zero_grad() # è®¡ç®—æ¨¡å‹è¾“å‡º yhat = model(inputs) # è®¡ç®—æŸå¤± loss = criterion(yhat,targets) # è´¡çŒ®åº¦åˆ†é… loss.backward() # å‡çº§æ¨¡å‹æƒé‡ optimizer.step() è¯„ä¼°æ¨¡å‹ è¯„ä¼°è¯¯å·®: å‡æ–¹è¯¯å·® (MSE, Mean Squared Error) é¢„æµ‹å€¼ä¸å®é™…å€¼ä¹‹é—´çš„å¹³å‡å‡æ–¹è¯¯å·® å‡æ–¹æ ¹è¯¯å·® (RMSE,Root Mean Squared Error) RMSE=MSERMSE = \\sqrt{MSE} RMSE=MSEâ€‹ å¹³å‡ç»å¯¹è¯¯å·® (MAE, Mean Absolute Error) æ‹Ÿåˆä¼˜åº¦ å€¼è¶Šæ¥è¿‘1ï¼Œæ¨¡å‹çš„è§£é‡Šèƒ½åŠ›è¶Šå¼º è¯„ä¼°æŒ‡æ ‡ å¯¹äºåˆ†ç±»æ¨¡å‹è€Œè¨€ï¼Œè¯„ä¼°æŒ‡æ ‡åªè¦è¡¡é‡æ¨¡å‹çš„åˆ†ç±»æ•ˆæœ æ··æ·†çŸ©é˜µG (Confusion Matrix) åŒ…æ‹¬TPã€TNã€FPã€FN TP (True Positive):è¢«åˆ¤å®šä¸ºæ­£æ ·æœ¬ï¼Œå®é™…ä¸Šæ˜¯æ­£æ ·æœ¬ -&gt; çœŸé˜³æ€§ FN (False Negative):è¢«åˆ¤å®šä¸ºè´Ÿæ ·æœ¬ï¼Œå®é™…ä¸Šæ˜¯æ­£æ ·æœ¬ -&gt; å‡é˜´æ€§ FP (False Positive):è¢«åˆ¤å®šä¸ºæ­£æ ·æœ¬ï¼Œå®é™…ä¸Šæ˜¯è´Ÿæ ·æœ¬ -&gt; å‡é˜³æ€§ TN (True Negative):è¢«åˆ¤å®šä¸ºè´Ÿæ ·æœ¬ï¼Œå®é™…ä¸Šæ˜¯è´Ÿæ ·æœ¬ -&gt; çœŸé˜´æ€§ ROCæ›²çº¿ (Receiver Operating Characteristic Curve) æ¨ªè½´è¡¨ç¤ºçš„æ˜¯ FPR ,å³é”™è¯¯åœ°é¢„æµ‹ä¸ºæ­£ä¾‹çš„æ¦‚ç‡ çºµè½´è¡¨ç¤ºçš„æ˜¯ TPR ,å³æ­£ç¡®åœ°é¢„æµ‹ä¸ºæ­£ä¾‹çš„æ¦‚ç‡ FPR=FPFP+TNFPR = \\frac {FP} {FP+TN} FPR=FP+TNFPâ€‹ TPR=TPTP+FNTPR = \\frac {TP} {TP+FN} TPR=TP+FNTPâ€‹ AOC (Area Under the Curve) è¡¡é‡çš„æ˜¯ROCæ›²çº¿ä¸‹çš„é¢ç§¯ AOCè¶Šå¤§ï¼Œè¡¨ç¤ºå½“å‰çš„åˆ†ç±»ç®—æ³•ï¼Œå°±è¶Šæœ‰å¯èƒ½å°†æ­£æ ·æœ¬æ’åœ¨è´Ÿæ ·æœ¬å‰é¢ï¼Œæ¨¡å‹çš„åˆ†ç±»æ€§èƒ½è¶Šå¥½ å‡†ç¡®ç‡ (Accuracy) Accuracy=TP+TNTP+TN+FP+FNAccuracy = \\frac {TP+TN}{TP+TN+FP+FN} Accuracy=TP+TN+FP+FNTP+TNâ€‹ ç²¾ç¡®ç‡ (Precision) è¡¡é‡æ¨¡å‹é¢„æµ‹ä¸ºæ­£ç±»çš„æ ·æœ¬ä¸­ï¼Œå®é™…ä¸ºæ­£ç±»çš„æ¯”ç‡ é€‚ç”¨äºå‡é˜³æ€§æ¯”ä¾‹è¾ƒé«˜çš„æƒ…å†µ Precision=TPTP+FPPrecision = \\frac {TP}{TP + FP} Precision=TP+FPTPâ€‹ å¬å›ç‡ (Recall) è¡¡é‡æ¨¡å‹é¢„æµ‹ä¸ºè´Ÿç±»çš„æ ·æœ¬ä¸­ï¼Œå®é™…ä¸ºè´Ÿç±»çš„æ¯”ç‡ é€‚ç”¨äºå‡é˜´æ€§æ¯”ä¾‹è¾ƒé«˜çš„æƒ…å†µ Recall=TPTP+FNRecall = \\frac {TP}{TP+FN} Recall=TP+FNTPâ€‹ F1åˆ†æ•° ä¸€èˆ¬å…¬è®¤çš„ç»“åˆç²¾ç¡®ç‡å’Œå¬å›ç‡çš„æŒ‡æ ‡ F1Score=2â‹…Precisionâ‹…AccuracyPrecision+AccuracyF1 Score = \\frac {2\\cdot{Precision}\\cdot{Accuracy}} {Precision + Accuracy} F1Score=Precision+Accuracy2â‹…Precisionâ‹…Accuracyâ€‹","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"æ·±åº¦å­¦ä¹ ","slug":"æ·±åº¦å­¦ä¹ ","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"author":"tugumineko"},{"title":"markdown-syntax","slug":"markdown-syntax","date":"2024-04-29T10:35:23.000Z","updated":"2024-05-23T11:53:09.248Z","comments":true,"path":"2024/04/29/markdown-syntax/","permalink":"http://example.com/2024/04/29/markdown-syntax/","excerpt":"","text":"æ³¨ï¼š ç‚¹å‡»runæŸ¥çœ‹æ•ˆæœ Markdown æ ‡é¢˜è¯­æ³• #çš„æ•°é‡ä»£è¡¨äº†æ ‡é¢˜çš„çº§åˆ« Heading level 1 Heading level 2 Heading level 3 Heading level 4 Heading level 5 Heading level 6 ==æ ‡è¯†ä¸€çº§æ ‡é¢˜ï¼Œâ€“æ ‡è¯†äºŒçº§æ ‡é¢˜(ä¸¤ä¸ªåŠä¸¤ä¸ªä»¥ä¸Š) Heading level 1 Heading level 2 æ®µè½ï¼Œè¯·ä½¿ç”¨ç©ºç™½è¡Œå°†ä¸€è¡Œæˆ–å¤šè¡Œæ–‡æœ¬è¿›è¡Œåˆ†å‰²,ä½†æ˜¯é—´è·æ˜¯å›ºå®šçš„ã€‚ -Iâ€™m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -ğŸ˜…Yes, you are right. Fuck the Jesus. æ¢è¡Œï¼Œåœ¨ä¸€è¡Œçš„æœ«å°¾æ·»åŠ ä¸¤ä¸ªæˆ–å¤šä¸ªç©ºæ ¼ï¼Œç„¶åæŒ‰å›è½¦é”®,å³å¯åˆ›å»ºä¸€ä¸ªæ¢è¡Œã€‚ -Iâ€™m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -ğŸ˜…Yes, you are right. Fuck the Jesus. &lt;br&gt;ä¹Ÿå¯ä»¥æ¢è¡Œ -Iâ€™m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -ğŸ˜…Yes, you are right. Fuck the Jesus. Markdown å¼ºè°ƒè¯­æ³• ç²—ä½“ï¼Œä¸¤ä¸ªæ˜Ÿå·**æˆ–__ æ–œä½“ï¼Œä¸€ä¸ªæ˜Ÿå·*æˆ–_ -Iâ€™m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -ğŸ˜…Yes, you are right. Fuck the Jesus. Markdown å¼•ç”¨è¯­æ³• å—å¼•ç”¨ï¼Œè¯·åœ¨æ®µè½å‰æ·»åŠ ä¸€ä¸ª &gt; ç¬¦å·ã€‚ å—å¼•ç”¨å¯ä»¥åŒ…å«å¤šä¸ªæ®µè½ã€‚ä¸ºæ®µè½ä¹‹é—´çš„ç©ºç™½è¡Œæ·»åŠ ä¸€ä¸ª &gt; ç¬¦å·ã€‚ -Iâ€™m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -ğŸ˜…Yes, you are right. Fuck the Jesus. å—å¼•ç”¨å¯ä»¥åµŒå¥—ã€‚åœ¨è¦åµŒå¥—çš„æ®µè½å‰æ·»åŠ ä¸€ä¸ª &gt;&gt; ç¬¦å·ã€‚ -Iâ€™m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -ğŸ˜…Yes, you are right. Fuck the Jesus. Markdown åˆ—è¡¨è¯­æ³• æœ‰åºåˆ—è¡¨ï¼Œè¯·åœ¨æ¯ä¸ªåˆ—è¡¨é¡¹å‰æ·»åŠ æ•°å­—å¹¶ç´§è·Ÿä¸€ä¸ªè‹±æ–‡å¥ç‚¹ã€‚æ•°å­—ä¸å¿…æŒ‰æ•°å­¦é¡ºåºæ’åˆ—ï¼Œä½†æ˜¯åˆ—è¡¨åº”å½“ä»¥æ•°å­— 1 èµ·å§‹ã€‚(åˆ—è¡¨åªä¼šæŒ‰ç…§12345çš„é¡ºåºè¿›è¡Œ) åŒä¸€åºå·çš„éœ€ä½¿ç”¨æ¢è¡Œç¬¦ã€‚ -Iâ€™m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -ğŸ˜…Yes, you are right. Fuck the Jesus. æ— åºåˆ—è¡¨ï¼Œè¯·åœ¨æ¯ä¸ªåˆ—è¡¨é¡¹å‰é¢æ·»åŠ ç ´æŠ˜å· (-)ã€æ˜Ÿå· (*) æˆ–åŠ å· (+) ã€‚ç¼©è¿›ä¸€ä¸ªæˆ–å¤šä¸ªåˆ—è¡¨é¡¹å¯åˆ›å»ºåµŒå¥—åˆ—è¡¨ã€‚ -Iâ€™m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -ğŸ˜…Yes, you are right. Fuck the Jesus. ä¸å¼•ç”¨å—ç»“åˆä½¿ç”¨ã€‚ä¹Ÿä¼šè¾¾åˆ°ç¼©è¿›æ•ˆæœã€‚ -Iâ€™m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -ğŸ˜…Yes, you are right. Fuck the Jesus. ä»£ç å— ä»£ç å—é€šå¸¸é‡‡ç”¨å››ä¸ªç©ºæ ¼æˆ–ä¸€ä¸ªåˆ¶è¡¨ç¬¦ç¼©è¿›ã€‚å½“å®ƒä»¬è¢«æ”¾åœ¨åˆ—è¡¨ä¸­æ—¶ï¼Œç¼©è¿›å…«ä¸ªç©ºæ ¼æˆ–ä¸¤ä¸ªåˆ¶è¡¨ç¬¦ã€‚ä½†æ˜¯è¿™æ ·ä¼šé€ æˆå¤šé‡ç¼©è¿›ã€‚ -Iâ€™m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -ğŸ˜…Yes, you are right. Fuck the Jesus. -I'm you. So am I GOD?? -No, as Jesus said, *you are just not only a bitch, but also son of a bitch.* -ğŸ˜…Yes, you are right. Fuck the **Jesus**. -Iâ€™m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -ğŸ˜…Yes, you are right. Fuck the Jesus. Markdown å›´æ ä»£ç å— å—ä¿æŠ¤çš„ä»£ç å—(ä¸ç¼©è¿›),æ ¹æ®Markdownå¤„ç†å™¨æˆ–ç¼–è¾‘å™¨çš„ä¸åŒï¼Œæ‚¨å°†åœ¨ä»£ç å—ä¹‹å‰å’Œä¹‹åçš„è¡Œä¸Šä½¿ç”¨ä¸‰ä¸ªåå¼•å·ï¼ˆ(```ï¼‰æˆ–ä¸‰ä¸ªæ³¢æµªå·ï¼ˆ~~~ï¼‰ã€‚ -Iâ€™m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -ğŸ˜…Yes, you are right. Fuck the Jesus. 123-I&#x27;m you. So am I GOD??-No, as Jesus said, *you are just not only a bitch, but also son of a bitch.*-ğŸ˜…Yes, you are right. Fuck the **Jesus**. å›¾ç‰‡ è§markdownå›¾ç‰‡è¯­æ³• Markdown ä»£ç è¯­æ³• è¦å°†å•è¯æˆ–çŸ­è¯­è¡¨ç¤ºä¸ºä»£ç ï¼Œè¯·å°†å…¶åŒ…è£¹åœ¨åå¼•å· (`) ä¸­ã€‚ ä»£ç è¯­æ³•å’Œä»£ç å—çš„æ˜¾ç¤ºæ˜¯ä¸ä¸€æ ·çš„ã€‚ -Iâ€™m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -ğŸ˜…Yes, you are right. Fuck the Jesus. Markdown åˆ†éš”çº¿è¯­æ³• åœ¨å•ç‹¬ä¸€è¡Œä¸Šä½¿ç”¨ä¸‰ä¸ªæˆ–å¤šä¸ªæ˜Ÿå· (**)ã€ç ´æŠ˜å· (â€”) æˆ–ä¸‹åˆ’çº¿ (___) ï¼Œå¹¶ä¸”ä¸èƒ½åŒ…å«å…¶ä»–å†…å®¹ã€‚ä¸ºäº†å…¼å®¹æ€§ï¼Œè¯·åœ¨åˆ†éš”çº¿çš„å‰åå‡æ·»åŠ __ç©ºç™½è¡Œ__. -Iâ€™m you. So am I GOD?? -No, as Jesus said, you are just not only a bitch, but also son of a bitch. -ğŸ˜…Yes, you are right. Fuck the Jesus. Markdown é“¾æ¥è¯­æ³• è¶…é“¾æ¥Markdownè¯­æ³•ä»£ç ï¼š[è¶…é“¾æ¥æ˜¾ç¤ºå](è¶…é“¾æ¥åœ°å€ &quot;è¶…é“¾æ¥title&quot;)(é“¾æ¥titleå¯é€‰)(é“¾æ¥åœ°å€è¦å†™å®Œæ•´) è¿™æ˜¯ä¸€ä¸ªé“¾æ¥ Hello Worldã€‚ ä½¿ç”¨å°–æ‹¬å·&lt;&gt;https://tugumineko.github.io/ å¼ºè°ƒé“¾æ¥, åœ¨é“¾æ¥è¯­æ³•å‰åå¢åŠ æ˜Ÿå·ã€‚ è¦å°†é“¾æ¥è¡¨ç¤ºä¸ºä»£ç ï¼Œè¯·åœ¨æ–¹æ‹¬å·ä¸­æ·»åŠ åå¼•å·ã€‚ This is Hello World. This is Hello World. This is Hello World. ä¸ºäº†å…¼å®¹æ€§ï¼Œåœ¨å†™é“¾æ¥æ—¶è¯·å°½é‡ä½¿ç”¨%20ä»£æ›¿ç©ºæ ¼ã€‚ Markdown å›¾ç‰‡è¯­æ³• ä»£ç æ ¼å¼![å›¾ç‰‡alt](å›¾ç‰‡é“¾æ¥ &quot;å›¾ç‰‡title&quot;) å¯¹åº”çš„HTMLä»£ç ï¼š&lt;img src=&quot;å›¾ç‰‡é“¾æ¥&quot; alt=&quot;å›¾ç‰‡alt&quot; title=&quot;å›¾ç‰‡title&quot;&gt; Markdown è½¬ä¹‰å­—ç¬¦è¯­æ³• è¦æ˜¾ç¤ºåŸæœ¬ç”¨äºæ ¼å¼åŒ– Markdown æ–‡æ¡£çš„å­—ç¬¦ï¼Œè¯·åœ¨å­—ç¬¦å‰é¢æ·»åŠ åæ–œæ å­—ç¬¦ \\ åœ¨ HTML æ–‡ä»¶ä¸­ï¼Œæœ‰ä¸¤ä¸ªå­—ç¬¦éœ€è¦ç‰¹æ®Šå¤„ç†ï¼š &lt; å’Œ &amp; ã€‚ &lt; ç¬¦å·ç”¨äºèµ·å§‹æ ‡ç­¾ï¼Œ&amp; ç¬¦å·åˆ™ç”¨äºæ ‡è®° HTML å®ä½“ï¼Œå¦‚æœä½ åªæ˜¯æƒ³è¦ä½¿ç”¨è¿™äº›ç¬¦å·ï¼Œä½ å¿…é¡»è¦ä½¿ç”¨å®ä½“çš„å½¢å¼ï¼Œåƒæ˜¯ &amp;lt; å’Œ &amp;amp;ã€‚ å…¼å®¹htmlçš„å¸¸ç”¨è¯­æ³• åˆ é™¤çº¿ï¼Œä¸€ä¸ªæˆ–ä¸¤ä¸ªæ³¢æµª~~ ä¸‹åˆ’çº¿ï¼Œ&lt;u&gt;&lt;/u&gt; ä¸Šæ ‡ ï¼Œ&lt;sup&gt;&lt;/sup&gt; ä¸‹æ ‡ï¼Œ&lt;sub&gt;&lt;/sub&gt; å°å·å­—ä½“ï¼Œ&lt;small&gt;&lt;/small&gt; å¤§å·å­—ä½“ï¼Œ&lt;big&gt;&lt;/big&gt; æ–‡æœ¬é«˜äº®ï¼Œ&lt;mark&gt;&lt;/mark&gt; violantisä¸»é¢˜ç‰¹æœ‰çš„æ ‡ç­¾æ’ä»¶ ä¼ é€é—¨ ä½¿ç”¨æ ‡ç­¾æ’ä»¶æ—¶,è‹¥è¦æ¢è¡Œï¼Œè¯·ä½¿ç”¨htmlè¯­æ³•&lt;br&gt;,å‡ºç°:æ—¶è¦ä½¿ç”¨åæ–œæ \\","categories":[{"name":"markdown","slug":"markdown","permalink":"http://example.com/categories/markdown/"}],"tags":[{"name":"è¯­æ³•","slug":"è¯­æ³•","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"},{"name":"å‰ç«¯","slug":"å‰ç«¯","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}],"author":"tugumineko"},{"title":"ç´ æ™´ã‚‰ã—ãæ—¥ã€…ï½ä¸é€£ç¶šå­˜åœ¨ï½","slug":"ç´ æ™´ã‚‰ã—ãæ—¥ã€…","date":"2023-12-23T03:36:27.000Z","updated":"2024-05-05T05:09:12.149Z","comments":true,"path":"2023/12/23/ç´ æ™´ã‚‰ã—ãæ—¥ã€…/","permalink":"http://example.com/2023/12/23/%E7%B4%A0%E6%99%B4%E3%82%89%E3%81%97%E3%81%8D%E6%97%A5%E3%80%85/","excerpt":"","text":"ä¸–ç•Œæ˜¯æ²¡æœ‰æ„ä¹‰çš„ã€‚å©´å„¿å“­ç€æ¥åˆ°è¿™ä¸ªä¸–ç•Œ,åˆä¸å¯é¿å…åœ°æ³¨å®šæ­»äº¡ã€‚äººçš„å¥‹æ–—ï¼Œäººçš„æƒ…æ„Ÿï¼Œäººçš„è´¢äº§ï¼Œäººçš„é€‰æ‹©å¯¹äºè¿™ä¸€åˆ‡æ¯«æ— æ„ä¹‰ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä¸çŸ¥é“æ­»äº¡çš„æ„ä¹‰ï¼Œæˆ‘ä»¬æ— æ¯”æƒ§æ€•æ­»äº¡ï¼Œå¯æ˜¯æ— è®ºæ˜¯åŒ–èº«æ•‘ä¸–ä¸»ï¼Œè¿˜æ˜¯è¯•å›¾èµ°åˆ°ä¸–ç•Œçš„å°½å¤´ä¸äº¡è€…ç›¸è§ï¼Œæ­»äº¡ç»ˆä¼šåˆ°æ¥ï¼Œæˆ‘ä»¬æ— æ³•æ„¿ç»ˆã€‚ä¸–ç•Œä¸Šæ²¡æœ‰æ•‘ä¸–ä¸»ï¼Œäººç±»æ²¡æœ‰æ„ä¹‰ï¼Œä¸–ç•Œæ¯«æ— æ„ä¹‰ã€‚ ä¸–ç•Œæ˜¯æœ‰ç•Œé™çš„ã€‚å› ä¸ºä¸‡ç‰©çš†ç”Ÿï¼Œä¸€åˆ‡æœ‰é™ï¼Œç»ˆå°†å›å½’ä¸æ­¤ã€‚æ°´å¤©ä¸€è‰²ï¼Œå¤©ç©ºå›è½¬ï¼Œä¸å¯åˆ°è¾¾ç»ˆç‚¹ã€‚ä¸–ä¸Šæ²¡æœ‰ä¸–ç•Œæœ«æ—¥ï¼Œæˆ‘ä»¬ä¹Ÿä¸å¯å›å½’å¤©ç©ºã€‚å½“æˆ‘ä»¬æ— é™å­˜åœ¨äºä¸–ç•Œï¼Œç¾å¥½çš„æ¯ä¸€å¤©ä¹Ÿç»ˆå°†ç´¢ç„¶æ— å‘³ã€‚ä¸–ç•Œæ²¡æœ‰å°½å¤´ï¼Œå¯æ— é™æœ€ç»ˆå›å½’ç•Œé™ã€‚æ— è®ºæœ‰æ²¡æœ‰ç»ˆä¹‹ç©ºï¼Œä¸–ç•Œéƒ½æ˜¯æœ‰ç•Œé™çš„ã€‚ æˆ‘ä»¬ç«­åŠ›æ¸´æ±‚å¤©ç©ºçš„ç»ˆç‚¹ï¼Œä¸é¡¾ä¸€åˆ‡åœ°è¿½æ±‚æ­»äº¡çš„çœŸç›¸ï¼Œè¿™æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼Œå› ä¸ºçœŸç›¸å­˜åœ¨äºä¸–ç•Œä¹‹å¤–ã€‚ä¸–ç•Œæ˜¯æœ‰ç•Œé™çš„ï¼Œä¸–ç•Œåˆæ²¡æœ‰æ„ä¹‰ã€‚å°½ç®¡å¦‚æ­¤ï¼Œäººè„‘æ¯”å¤©ç©ºæ›´å®½å¹¿ï¼Œæ¯”æµ·æ´‹æ›´å®½é˜”ã€‚æ¯äº²ä½¿é—´å®«å“å¸ç”Ÿäºçš†æœ¨ï¼Œçš†æœ¨ä½¿æ°´ä¸Šç”±å²ç”Ÿäºè‡ªæˆ‘ä¹‹ä¸Šï¼Œç¾½å’²ä½¿çš†æœ¨æˆ˜èƒœè‡ªæˆ‘è€Œé‡ç”Ÿã€‚ä¹Ÿè®¸PTSDè€Œç”Ÿçš„å¤šé‡äººæ ¼ä¼šå¸¦æ¥æ— å°½çš„ç—›è‹¦ï¼Œå¯å¯¹äºçš†æœ¨æ¥è¯´ï¼Œç”±å²çš„å¸®åŠ©ï¼Œé•œå’Œå¸çš„å›å¿†ï¼Œä¸å“å¸çš„å¯¹å³™ï¼Œä¸€åˆ‡éƒ½æ˜¯çœŸå®çš„ã€‚äººçš„æ„ä¹‰ä¸ä¼šå› ä¸ºä¸–ç•Œè€Œæ”¹å˜ï¼Œå¯äººçš„æ„è¯†å¯ä»¥æ”¹å˜ä¸–ç•Œï¼Œæœ€ç»ˆæˆ˜èƒœä¸€åˆ‡ï¼Œç”šè‡³å›å½’å¤©ç©ºã€‚äººçš„æ„è¯†ä¸ä»…å­˜åœ¨äºä¸–ç•Œï¼Œä¹Ÿå­˜åœ¨äºæ¸…æ˜æ¢¦ï¼Œæ›´é‡è¦çš„æ˜¯ï¼Œå®ƒå­˜åœ¨äºéœ€è¦ä½ çš„äººçš„ç²¾ç¥ä¹‹ä¸­ã€‚ç—›è‹¦çš„ä¸ä»…æ˜¯ä½ è‡ªå·±ï¼Œè€Œæ˜¯å¤§å®¶å•Šï¼Œæ˜¯è¿™ä¸ªä¸–ç•Œå•Šã€‚ä¸‡ç‰©è½®å›ï¼Œå‘æ­»è€Œç”Ÿï¼Œå¯ç²¾ç¥æ°¸å­˜ã€‚çœŸç›¸ï¼Œç¡®å®å­˜åœ¨äºä¸–ç•Œä¹‹å¤–ï¼Œå¯å¹¶éæ— æ³•è§¦åŠã€‚ äººå•Šï¼Œå¹¸ç¦åœ°æ´»ä¸‹å»å§ï¼å°½ç®¡ä¸–ç•Œæ²¡æœ‰æ„ä¹‰ï¼Œæˆ‘ä»¬ä¹Ÿè¦åšå¥½æ¯ä¸€ä¸ªé€‰æ‹©ï¼Œä½“ä¼šæ¯ä¸€ä¸æƒ…æ„Ÿï¼Œå®ˆæŠ¤æˆ‘ä»¬çš„ç¾å¥½ï¼Œåº¦è¿‡ç¾å¥½çš„æ¯ä¸€å¤©ï¼Œå°±è®©æˆ‘ä»¬æ°¸å­˜çš„æ„è¯†ï¼Œè¿™ä¸è¿ç»­çš„å­˜åœ¨ï¼Œå»æ¢æ±‚å­˜åœ¨äºä¸–ç•Œä¹‹å¤–çš„çœŸç›¸å§ã€‚","categories":[],"tags":[{"name":"é»„æ²¹","slug":"é»„æ²¹","permalink":"http://example.com/tags/%E9%BB%84%E6%B2%B9/"}],"author":"tugumineko"}],"categories":[{"name":"3DV","slug":"3DV","permalink":"http://example.com/categories/3DV/"},{"name":"CV","slug":"CV","permalink":"http://example.com/categories/CV/"},{"name":"CG","slug":"CG","permalink":"http://example.com/categories/CG/"},{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"cuda","slug":"cuda","permalink":"http://example.com/categories/cuda/"},{"name":"cv","slug":"cv","permalink":"http://example.com/categories/cv/"},{"name":"cg","slug":"cg","permalink":"http://example.com/categories/cg/"},{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"C","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"cpp","slug":"cpp","permalink":"http://example.com/categories/cpp/"},{"name":"vim","slug":"vim","permalink":"http://example.com/categories/vim/"},{"name":"markdown","slug":"markdown","permalink":"http://example.com/categories/markdown/"}],"tags":[{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"3dgs","slug":"3dgs","permalink":"http://example.com/tags/3dgs/"},{"name":"æ¸²æŸ“","slug":"æ¸²æŸ“","permalink":"http://example.com/tags/%E6%B8%B2%E6%9F%93/"},{"name":"æ·±åº¦å­¦ä¹ ","slug":"æ·±åº¦å­¦ä¹ ","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"æ¸¸æˆ","slug":"æ¸¸æˆ","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F/"},{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"Arduino","slug":"Arduino","permalink":"http://example.com/tags/Arduino/"},{"name":"å¤šçº¿ç¨‹","slug":"å¤šçº¿ç¨‹","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"æ•°å­—å›¾åƒå¤„ç†","slug":"æ•°å­—å›¾åƒå¤„ç†","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"è¯­æ³•","slug":"è¯­æ³•","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"åˆ·é¢˜","slug":"åˆ·é¢˜","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"},{"name":"OS","slug":"OS","permalink":"http://example.com/tags/OS/"},{"name":"æ–‡æœ¬ç¼–è¾‘å™¨","slug":"æ–‡æœ¬ç¼–è¾‘å™¨","permalink":"http://example.com/tags/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"å‰ç«¯","slug":"å‰ç«¯","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"é»„æ²¹","slug":"é»„æ²¹","permalink":"http://example.com/tags/%E9%BB%84%E6%B2%B9/"}]}